// Generated by CoffeeScript 1.10.0
(function() {
  var AndType, Any, HasAnnotation, Nothing, OrType, TermDecl, Token, TypeDecl, WithAnnotation, WithGuard, asConstructed, channels, clearLog, contextify, createPredefTree, deepCopyTree, derivedAndOrType, derivedAssignment, derivedConstruction, derivedNameSelect, derivedTermDecl, derivedTypeDecl, findMember, gen, genConstructor, genInitializer, isDefinedInSameContext, isSameReference, isSubType, log, parse, replaceContextWithContext, replaceContextWithPrefix, replaceSelfWithPrefix, requireCompatibility, requireMember, requireTermCompatibility, shallowCopyTree, simplifyType, stderr, stringifyStatements, tabs, tokenize, types,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.compile = function(input, stopAfter) {
    var allOutput, ast, error, error1, message, output, tok, tokens;
    try {
      clearLog();
      tokens = tokenize(input);
      if (stopAfter === "tokens") {
        return ((function() {
          var j, len, results;
          results = [];
          for (j = 0, len = tokens.length; j < len; j++) {
            tok = tokens[j];
            results.push(tok.print());
          }
          return results;
        })()).join('\n');
      }
      ast = parse(tokens);
      if (stopAfter === "trees") {
        return ast.stringify(0);
      }
      contextify(ast, createPredefTree(), ast);

      /*
      		predefCtx = createPredefContext()   # create a context for predefined types
      		doTypeCompleters(ast, predefCtx.fresh(ast))   # generate subcontexts and info() functions
      
      		outputBuffer = []
      		[bases, ignore] = linearizedForConstruction(ast, predefCtx)
      		genConstructor(bases, ast.ctx, predefCtx, 0, outputBuffer)
      		outputBuffer.push(";")
      		output = outputBuffer.join("")
       */
      allOutput = [output];
      if (channels[types]) {
        allOutput.push("/** Types log:\n\n" + channels[types].join("\n") + "\n**/");
      }
      if (channels[stderr]) {
        allOutput.push("/** Stderr log:\n\n" + channels[stderr].join("\n") + "\n**/");
      }
      return allOutput.join("\n\n");
    } catch (error1) {
      error = error1;
      message = error.message != null ? error.message : error;
      message = message.toUpperCase().startsWith("ERROR") || message.toUpperCase().startsWith("INTERNAL COMPILER ERROR") ? message : "Error: " + message;
      output = [message];
      if (channels[types]) {
        output.push("Types log:\n\n" + channels[types].join("\n"));
      }
      if (channels[stderr]) {
        output.push("Stderr log:\n\n" + channels[stderr].join("\n"));
      }
      if (error.stack != null) {
        output.push("COMPILER STACKTRACE:\n" + error.stack);
      }
      return output.join("\n\n");
    }
  };

  channels = {};

  stderr = "stderr";

  types = "types";

  clearLog = function() {
    return channels = {};
  };

  log = function(ch, msg) {
    if (!channels[ch]) {
      return channels[ch] = [msg];
    } else {
      return channels[ch].push(msg);
    }
  };

  Any = {
    type: "ANY",
    stringify: function(indent) {
      return "Any";
    }
  };

  Nothing = {
    type: "NOTHING",
    stringify: function(indent) {
      return "Nothing";
    }
  };

  AndType = function(lhsTyp, rhsTyp) {
    return {
      type: "AND-TYPE",
      lhs: lhsTyp,
      rhs: rhsTyp,
      stringify: function(indent) {
        return lhsTyp.stringify(indent) + " & " + rhsTyp.stringify(indent);
      }
    };
  };

  OrType = function(lhsTyp, rhsTyp) {
    return {
      type: "OR-TYPE",
      lhs: lhsTyp,
      rhs: rhsTyp,
      stringify: function(indent) {
        return lhsTyp.stringify(indent) + " | " + rhsTyp.stringify(indent);
      }
    };
  };


  /* TYPE OPERATIONS */

  shallowCopyTree = function(t) {
    return {
      type: t.type,
      ctx: t.ctx,
      line: t.line,
      column: t.column,
      annots: t.annots
    };
  };

  derivedNameSelect = function(t, prefix) {
    var t1;
    if (prefix === t.prefix) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.id = t.id;
      t1.ID = t.ID;
      t1.prefix = prefix;
      return t1;
    }
  };

  derivedAndOrType = function(tree, lhs, rhs) {
    if (lhs === tree.lhs && rhs === tree.rhs) {
      return tree;
    } else if (tree.type === "AND-TYPE") {
      return AndType(lhs, rhs);
    } else if (tree.type === "OR-TYPE") {
      return OrType(lhs, rhs);
    }
  };

  derivedTypeDecl = function(t, rhsUpper, rhsLower) {
    var t1;
    if (t.rhsUpper === rhsUpper && t.rhsLower === rhsLower) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.rhsUpper = rhsUpper;
      t1.rhsLower = rhsLower;
      return t1;
    }
  };

  derivedTermDecl = function(t, rhs) {
    var t1;
    if (t.rhs === rhs) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.rhs = rhs;
      return t1;
    }
  };

  derivedAssignment = function(t, guard1, lhs1, rhs1) {
    var t1;
    if (t.guard === guard1 && t.lhs === lhs1 && t.rhs === rhs1) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.guard = guard1;
      t1.lhs = lhs1;
      t1.rhs = rhs1;
      return t1;
    }
  };

  derivedConstruction = function(t, typTree) {
    var t1;
    if (t.typTree === typTree) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.typTree = typTree;
      return t1;
    }
  };

  simplifyType = function(tree) {
    var tree2;
    if (tree.type === "TYPE-BOUNDS") {
      tree2 = derivedTypeBounds(tree, simplifyType(tree.lower), simplifyType(tree.upper));
      if (tree2.lower === tree2.upper) {
        return tree2.lower;
      } else {
        return tree2;
      }
    } else if (tree.type === "AND-TYPE") {
      tree2 = derivedAndOrType(tree, simplifyType(tree.lhs), simplifyType(tree.rhs));
      if (tree2.lhs === tree2.rhs) {
        return tree2.lhs;
      } else if (tree2.lhs === Nothing || tree2.rhs === Nothing) {
        return Nothing;
      } else if (tree2.lhs === Any) {
        return tree2.rhs;
      } else if (tree2.rhs === Any) {
        return tree2.lhs;
      } else {
        return tree2;
      }
    } else if (tree.type === "OR-TYPE") {
      tree2 = derivedAndOrType(tree, simplifyType(tree.lhs), simplifyType(tree.rhs));
      if (tree2.lhs === tree2.rhs) {
        return tree2.lhs;
      } else if (tree2.lhs === Any || tree2.rhs === Any) {
        return Any;
      } else if (tree2.lhs === Nothing) {
        return tree2.rhs;
      } else if (tree2.rhs === Nothing) {
        return tree2.lhs;
      } else {
        return tree2;
      }
    } else {
      return tree;
    }
  };

  deepCopyTree = function(t, mutator, insideStatement) {
    var anyDifferent, guard1, lhs1, prefix1, rhs, rhs1, rhsLower, rhsUpper, st, st1, stmt1, t1, typTree1;
    t1 = (function() {
      var j, len, ref;
      if (t.type === "TYPE-SELECT" || t.type === "TERM-SELECT") {
        prefix1 = deepCopyTree(t.prefix, mutator, insideStatement);
        return derivedNameSelect(t, prefix1);
      } else if (t.type === "STATEMENTS") {
        stmt1 = shallowCopyTree(t);
        stmt1.statements = [];
        anyDifferent = false;
        ref = t.statements;
        for (j = 0, len = ref.length; j < len; j++) {
          st = ref[j];
          st1 = deepCopyTree(st, mutator, true);
          if (st1 !== st) {
            anyDifferent = true;
          }
          stmt1.statements.push(st1);
        }
        stmt1.stringify = function(indent) {
          return stringifyStatements(stmt1, indent);
        };
        if (anyDifferent) {
          return stmt1;
        } else {
          return t;
        }
      } else if (t.type === "AND-TYPE" || t.type === "OR-TYPE") {
        lhs1 = deepCopyTree(t.lhs, mutator, insideStatement);
        rhs1 = deepCopyTree(t.rhs, mutator, insideStatement);
        return derivedAndOrType(t, lhs1, rhs1);
      } else if (t.type === "TYPE-DECL") {
        rhsUpper = deepCopyTree(t.rhsUpper, mutator, false);
        rhsLower = deepCopyTree(t.rhsLower, mutator, false);
        return derivedTypeDecl(t, rhsUpper, rhsLower);
      } else if (t.type === "TERM-DECL") {
        rhs = deepCopyTree(t.rhs, mutator, false);
        return derivedTermDecl(t, rhs);
      } else if (t.type === "TERM-ASSIGN") {
        guard1 = t.guard ? deepCopyTree(t.guard, mutator) : void 0;
        lhs1 = t.lhs.type === "id" ? t.lhs : deepCopyTree(t.lhs, mutator, true);
        rhs1 = deepCopyTree(t.rhs, mutator, true);
        return derivedAssignment(t, guard1, lhs1, rhs1);
      } else if (t.type === "CONSTRUCT") {
        typTree1 = deepCopyTree(t.typTree, mutator, false);
        return derivedConstruction(t, typTree1);
      } else {
        return t;
      }
    })();
    return mutator(t1, insideStatement);
  };

  replaceContextWithPrefix = function(typ, ctx, prefix) {
    return deepCopyTree(typ, function(t, insideStatement) {
      var startCtx, t1;
      if (t.type === "ID") {
        startCtx = insideStatement ? t.ctx : t.ctx.outer;
        if (getDefContext(t.match, startCtx) === ctx) {
          t1 = shallowCopyTree(t);
          t1.type = "TYPE-SELECT";
          t1.ID = t.match;
          t1.prefix = prefix;
          t1.stringify = function(indent) {
            return t1.ID + "." + (t1.prefix.stringify(indent));
          };
          return t1;
        }
      }
      if (t.type === "id") {
        startCtx = insideStatement ? t.ctx : t.ctx.outer;
        if (getDefContext(t.match, startCtx) === ctx) {
          t1 = shallowCopyTree(t);
          t1.type = "TERM-SELECT";
          t1.id = t.match;
          t1.prefix = prefix;
          t1.stringify = function(indent) {
            return t1.id + "." + (t1.prefix.stringify(indent));
          };
          return t1;
        }
      }
      return t;
    });
  };

  replaceContextWithContext = function(typ, fromCtx, toCtx) {
    return deepCopyTree(typ, function(t, insideStatement) {
      var startCtx, t1;
      if (t.type === "ID") {
        startCtx = insideStatement ? t.ctx : t.ctx.outer;
        if (getDefContext(t.match, startCtx) === fromCtx) {
          t1 = shallowCopyTree(t);
          t1.type = "ID";
          t1.ctx = toCtx;
          t1.match = t.match;
          t1.stringify = function(indent) {
            return "" + t1.match;
          };
          return t1;
        }
      }
      if (t.type === "id") {
        startCtx = insideStatement ? t.ctx : t.ctx.outer;
        if (getDefContext(t.match, startCtx) === fromCtx) {
          t1 = shallowCopyTree(t);
          t1.type = "id";
          t1.ctx = toCtx;
          t1.match = t.match;
          t1.stringify = function(indent) {
            return "" + t1.match;
          };
          return t1;
        }
      }
      return t;
    });
  };


  /* CONTEXTS AND SYMBOL/MEMBER LOOKUP */

  createPredefTree = function() {
    var predefTree;
    predefTree = {
      type: "STATEMENTS",
      statements: []
    };
    predefTree.stringify = function(indent) {
      return "{ (predefined symbols) }";
    };
    predefTree.statements.push(TypeDecl(Token("ID", "Any", void 0, void 0), Any, Any));
    predefTree.statements.push(TypeDecl(Token("ID", "Nothing", void 0, void 0), Nothing, Nothing));
    predefTree.statements.push(TermDecl(Token("ID", "???", void 0, void 0), Nothing));
    return predefTree;
  };


  /*
  createPredefContext = () ->
  	predefTree = createPredefTree()
  	ctx = freshContext(undefined, predefTree)
  	ctx.outer = ctx  # circular reference to outermost context (for convenience)
  	Any.ctx = ctx   # hack: make the contexts of predefined types point to the predef context
  	Nothing.ctx = ctx
  	ctx
   */


  /*
  freshContext = (outer, typTree) ->
  	ctx = {}
  
  	if outer
  		ctx.nestLevel = outer.nestLevel + 1
  		ctx.outer = outer
  	else
  		ctx.nestLevel = 0
  		ctx.outer = undefined
  
  	ctx.indents = tabs(ctx.nestLevel)
  
  	ctx.name = "c#{ctx.nestLevel}"
  
  	ctx.fresh = (typTree) -> freshContext(ctx, typTree)
  
  	ctx.findMember = (name, returnLowerBound, logIndent) ->
  		 * Find the actual statement blocks that define the members of this context.
  		asConstructed = typeAsConstructed(typTree, ctx.outer)
  		 * Unlike the above, the context for the call to findMember is undefined.
  		 * Since the asConstructed tree no longer includes names of base types, the context is never referenced, so we don't pass one.
  		findMember(name, asConstructed, undefined, returnLowerBound, logIndent)
  
  	ctx
  
  findMember = (name, typTree, ctx, returnLowerBound, logIndent) ->  # params: name to find, type tree to look into, enclosing context to resolve type/term names in the type tree
  
  	if typTree.type is "STATEMENTS"
  		found = undefined
  		for st in typTree.statements
  			if st.type is "TYPE-DECL" and st.lhs.match is name
  				if found then throw new Error("Duplicate definition of '#{name}' on line #{st.lhs.line} character #{st.lhs.column}")
  				found = if returnLowerBound then st.rhsLower else st.rhsUpper
  			else if st.type is "TERM-DECL" and st.lhs.match is name
  				if found then throw new Error("Duplicate definition of '#{name}' on line #{st.lhs.line} character #{st.lhs.column}")
  				found = st.rhs
  		found
  
  	else if typTree.type is "ANY"
  		undefined
  
  	else if typTree.type is "NOTHING"
  		throw new Error("Attempt to find member '#{name}' in type Nothing, which contains contradictory definitions of '#{name}'.")
  		 * Note on Nothing: (July 2, 2016)
  		 *   Nothing contains all possible members, which means that for any given name,
  		 * Nothing contains contradictory definitions. Since we can't return anything sensical,
  		 * we throw an exception.
  		 *   There is the possibility of a type that contains contradictory definitions for
  		 * some names, but not for others. For example, the ReadonlyNothing type would return
  		 * a result for the mutability member, but not for other members.
  
  	else if typTree.type is "ID"
  		[widenedIdCtx, widenedIdTree] = widen(typTree, ctx)
  		findMember(name, widenedIdTree, widenedIdCtx, returnLowerBound)
  
  	else if typTree.type is "TYPE-SELECT"
  		[widenedCtx, widenedTyp] = widen(typTree, ctx)
  		findMember(name, widenedTyp, widenedCtx, returnLowerBound)
  
  	else if typTree.type is "AND-TYPE"
  		lhsType = findMember(name, typTree.lhs, ctx, returnLowerBound)
  		rhsType = findMember(name, typTree.rhs, ctx, returnLowerBound)
  		if (not lhsType) or (lhsType is rhsType)
  			rhsType
  		else if not rhsType
  			lhsType
  		else if returnLowerBound
  			OrType(lhsType, rhsType)
  		else
  			AndType(lhsType, rhsType)
  
  	else
  		throw new Error("Internal compiler error: Unexpected #{typTree.type} tree in findMember")
  
   * Widen a term or named type to its corresponding type tree.
   * For named types or terms, returns the given context.
   * For constructors, returns the context for that constructor itself.
  widen = (tree, ctx, returnLowerBound, logIndent = 0) ->
  
  	if tree.type is "id"
  		log(types, tabs(logIndent) + "Widening #{tree.match} to its declared type" + (if returnLowerBound then " (getting lower bound)" else ""))
  		typ = requireMemberInContext(tree.match, ctx, tree, returnLowerBound, logIndent+1)
  		 *
  		 * Replace the expanded type's original context with the current context.
  		 * Identifiers referring to the original context will now refer to the current context.
  		 *
  		log(types, "Replacing context #{typ.ctx.name} with context #{ctx.name}")
  		typ = replaceContextWithContext(typ, typ.ctx, ctx)
  		log(types, "Result: " + typ.stringify(0))
  
  		#ctx = requireDefContext(tree.match, ctx, tree)  #TODO: do we want this?
  		[ctx, typ]
  
  	else if tree.type is "ID"
  		log(types, tabs(logIndent) + "Widening #{tree.match} to its declared type" + (if returnLowerBound then " (getting lower bound)" else ""))
  		typ = requireMemberInContext(tree.match, ctx, tree, returnLowerBound, logIndent+1)
  		 *
  		 * Replace the expanded type's original context with the current context.
  		 * Replacing the context makes the returned type look as if it were declared right here; as if the named ID was replaced directly with the expansion.
  		 *
  		log(types, "Replacing context #{typ.ctx.name} with context #{ctx.name}")
  		typ = replaceContextWithContext(typ, typ.ctx, ctx)
  		log(types, "Result: " + typ.stringify(0))
  
  		#ctx = requireDefContext(tree.match, ctx, tree)  #TODO: do we want this?
  		[ctx, typ]
  
  	else if tree.type is "TERM-SELECT"
  		log(types, tabs(logIndent) + "Widening term selection #{tree.stringify(logIndent+1)} to its declared type" + (if returnLowerBound then " (getting lower bound)" else ""))
  		[prefixCtx, prefixTyp] = widen(tree.prefix, ctx, false, logIndent+1)
  		typ = requireMemberInType(tree.id, prefixTyp, prefixCtx, tree, returnLowerBound)
  		 *
  		 * Replace the expanded type's original context with the current prefix.
  		 * Replacing the context makes the returned type look as if it were declared right here; as if the named ID was replaced directly with the expansion.
  		 *
  		log(types, "Replacing context #{typ.ctx.name} with prefix #{tree.prefix.stringify(0)}")
  		typ = replaceContextWithPrefix(typ, typ.ctx, tree.prefix)
  		log(types, "Result: " + typ.stringify(0))
  
  		[prefixCtx, typ]
  
  	else if tree.type is "TYPE-SELECT"
  		log(types, tabs(logIndent) + "Widening type selection #{tree.stringify(logIndent+1)} to its declared type" + (if returnLowerBound then " (getting lower bound)" else ""))
  		[prefixCtx, prefixTyp] = widen(tree.prefix, ctx, false, logIndent+1)
  		typ = requireMemberInType(tree.ID, prefixTyp, prefixCtx, tree, returnLowerBound)
  		 *
  		 * Replace the expanded type's original context with the current prefix.
  		 * Replacing the context makes the returned type look as if it were declared right here; as if the named ID was replaced directly with the expansion.
  		 *
  		log(types, "Replacing context #{typ.ctx.name} with prefix #{tree.prefix.stringify(0)}")
  		typ = replaceContextWithPrefix(typ, typ.ctx, tree.prefix)
  		log(types, "Result: " + typ.stringify(0))
  
  		[prefixCtx, typ]
  
  	else if tree.type is "CONSTRUCT"
  		log(types, tabs(logIndent) + "Widening object #{tree.stringify(logIndent+1)} to its type-as-constructed")
  		asConstructed = typeAsConstructed(tree.typTree, ctx)
  		[tree.typTree.ctx, asConstructed]  # context is context of self-type
  
  	else
  		throw new Error("Unexpected #{tree.type} tree in widen")
  
  
  findMemberInContext = (name, ctx, returnLowerBound, logIndent) ->
  	found = ctx.findMember(name, returnLowerBound, logIndent)
  	if found
  		found
  	else if ctx isnt ctx.outer
  		findMemberInContext(name, ctx.outer, returnLowerBound, logIndent)
  	else
  		undefined
  
   * Finds the context that defines the given name, if it is in ctx or enclosing.
  getDefContext = (name, ctx) ->
  	if ctx.findMember(name)
  		ctx
  	else if ctx isnt ctx.outer
  		getDefContext(name, ctx.outer)
  	else
  		undefined
  
   * Throws an error if the given name is not defined in the given or enclosing contexts.
  requireMemberInContext = (name, ctx, sourceTree, returnLowerBound, logIndent) ->
  	typTree = findMemberInContext(name, ctx, returnLowerBound, logIndent)
  	if not typTree
  		throw new Error("Name '#{name}' is not defined at line #{sourceTree.line} character #{sourceTree.column}")
  	typTree
  
  requireMemberInType = (name, typTree, ctx, sourceTree, returnLowerBound, logIndent) ->
  	found = findMember(name, typTree, ctx, returnLowerBound, logIndent)
  	if not found
  		throw new Error("Member '#{name}' at line #{sourceTree.line} character #{sourceTree.column} could not be found")
  	found
  
  requireDefContext = (name, ctx, sourceTree) ->
  	found = getDefContext(name, ctx)
  	if not found
  		throw new Error("Name '#{name}' is not defined at line #{sourceTree.line} character #{sourceTree.column}")
  	found
   */


  /* BASE/CONSTRUCTOR TYPE QUERIES */


  /*
  typeAsConstructed = (tree, ctx) ->
  	[bases, problemBase, stmts] = linearizedForConstruction(tree, ctx)
  	if bases is false
  		throw new Error("Cannot construct object at line #{tree.line} character #{tree.column} because base type #{problemBase.stringify(0)} is non-constructible.")
  	typ = Any
  	for stmt in stmts
  		if typ is Any
  			typ = stmt
  		else
  			typ = AndType(typ, stmt)
  	typ
  
  typeAsLinearized = (tree, ctx) ->
  	[bases, problemBase, stmts] = linearizedForConstruction(tree, ctx)
  	if bases is false
  		throw new Error("Cannot construct object at line #{tree.line} character #{tree.column} because base type #{problemBase.stringify(0)} is non-constructible.")
  	typ = Any
  	for base in bases
  		if typ is Any
  			typ = base
  		else
  			typ = AndType(typ, base)
  	typ
  
   * Finds the sequence of base types needed to construct an object of the given type tree.
   * Returns a triple [lin, base, statements].
   *   If the type is constructible, lin is an array of base types. If not, lin is false and base is the base type that cannot be constructed.
   *   statements is the list of statement blocks that contain member definitions.
  linearizedForConstruction = (tree, ctx) ->
  
  	if tree._linearization
  		return [tree._linearization, undefined, tree._statements]
  	else
  		tree._linearization = []
  		tree._statements = []
  
  	if tree.type in ["ID", "TYPE-SELECT"]
  		tree._linearization.push tree
  
  		 * Make sure we can linearize higher base classes
  		[wCtx, wTyp] = widen(tree, ctx, true)
  		[lin, ignore, stmt] = linearizedForConstruction(wTyp, wCtx)
  		if lin is false
  			tree._linearization = false
  			return [false, tree, undefined]
  		tree._statements = tree._statements.concat stmt
  
  	else if tree.type is "AND-TYPE"
  		[linLhs, baseLhs, stmtLhs] = linearizedForConstruction(tree.lhs, ctx)
  		if linLhs is false
  			tree._linearization = false
  			return [false, baseLhs, undefined]
  
  		[linRhs, baseRhs, stmtRhs] = linearizedForConstruction(tree.rhs, ctx)
  		if linRhs is false
  			tree._linearization = false
  			return [false, baseRhs, undefined]
  
  		tree._linearization = tree._linearization.concat linLhs
  		tree._statements = tree._statements.concat stmtLhs
  		tree._linearization = tree._linearization.concat linRhs
  		tree._statements = tree._statements.concat stmtRhs
  
  	else if tree.type is "OR-TYPE"
  		 * Here, we've got to choose which branch of the OrType gets instantiated.
  		 * The default policy I go with here is to select the leftmost branch unless it is non-constructible.
  		 * By choosing the leftmost branch, members of types earlier in the linearization order override members later in the order.
  		 * The result of this policy is that declarations are narrowed from right to left, but assignments are executed from
  		 *  left to right. This allows the most specific declarations and the earliest-executed terms to be grouped together
  		 *  in the leftmost base type.
  		log(types, "Considering OrType #{tree.stringify(0)}")
  		[linLhs, baseLhs, stmtLhs] = linearizedForConstruction(tree.lhs, ctx)
  		if linLhs is false
  			[linRhs, baseRhs, stmtRhs] = linearizedForConstruction(tree.rhs, ctx)
  			if linRhs is false
  				tree._linearization = false
  				return [false, baseRhs, undefined]
  			tree._linearization = tree._linearization.concat linRhs
  			tree._statements = tree._statements.concat stmtRhs
  		else
  			tree._linearization = tree._linearization.concat linLhs
  			tree._statements = tree._statements.concat stmtLhs
  
  	else if tree.type is "NOTHING"
  		tree._linearization = false
  		return [false, tree, undefined]
  
  	else if tree.type is "STATEMENTS"
  		tree._linearization.push tree
  		tree._statements.push tree
  
  	else if tree.type is "ANY"
  		 * No action needed
  
  	else
  		throw new Error("Internal compiler error: Expected a type tree in linearizedForConstruction, got #{tree.type} tree")
  
  	#TODO: remove duplicates?
  	[tree._linearization, undefined, tree._statements]
   */


  /* CONTEXTIFY */

  findMember = function(name, typTree, lowerBound) {
    var expanded, j, len, lhsTyp, ref, rhsTyp, st;
    if (typTree.type === "STATEMENTS") {
      ref = typTree.statements;
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        if (st.type === "TYPE-DECL" && st.lhs.match === name) {
          if (lowerBound) {
            return st.rhsLower;
          } else {
            return st.rhsUpper;
          }
        } else if (st.type === "TERM-DECL" && st.lhs.match === name) {
          return st.rhs;
        }
      }
      return void 0;
    } else if (typTree.type === "ID" || typTree.type === "TYPE-SELECT") {
      expanded = requireMember(typTree, false);
      return findMember(name, expanded, lowerBound);
    } else if (typTree.type === "AND-TYPE") {
      lhsTyp = findMember(name, typTree.lhs, lowerBound);
      rhsTyp = findMember(name, typTree.rhs, lowerBound);
      if (lhsTyp && rhsTyp) {
        if (lowerBound) {
          return OrType(lhsTyp, rhsTyp);
        } else {
          return AndType(lhsTyp, rhsTyp);
        }
      } else if (lhsTyp) {
        return lhsTyp;
      } else {
        return rhsTyp;
      }
    } else if (typTree.type === "OR-TYPE") {
      lhsTyp = findMember(name, typTree.lhs, lowerBound);
      rhsTyp = findMember(name, typTree.rhs, lowerBound);
      if (lhsTyp && rhsTyp) {
        if (lowerBound) {
          return AndType(lhsTyp, rhsTyp);
        } else {
          return OrType(lhsTyp, rhsTyp);
        }
      } else {
        return void 0;
      }
    } else if (typTree.type === "CONSTRUCT") {
      return findMember(name, asConstructed(typTree.typTree));
    } else if (typTree.type === "ANY") {
      return void 0;
    } else if (typTree.type === "NOTHING") {
      throw new Error("Attempt to find member '" + name + "' in type Nothing, which contains contradictory definitions of '" + name + "'.");
    } else {
      throw new Error("Internal compiler error: Expected a type tree in findMember(\"" + name + "\"), got '" + typTree.type + "' tree");
    }
  };

  asConstructed = function(typTree) {
    return typTree;
  };

  requireMember = function(nameTree, lowerBound) {
    var enclosing, prefixTyp, typ, typTree;
    typTree = (function() {
      if (nameTree.type === "id" || nameTree.type === "ID") {
        typ = void 0;
        enclosing = nameTree.enclosing;
        while (enclosing && !typ) {
          typ = findMember(nameTree.match, enclosing, lowerBound);
          enclosing = enclosing.enclosing;
        }
        nameTree.definingTree = enclosing;
        return typ;
      } else if (nameTree.type === "TYPE-SELECT") {
        prefixTyp = requireMember(nameTree.prefix, false);
        typ = findMember(nameTree.ID, prefixTyp, lowerBound);
        typ = replaceSelfWithPrefix(typ, prefixTyp, nameTree.prefix);
        return typ;
      } else if (nameTree.type === "TERM-SELECT") {
        prefixTyp = requireMember(nameTree.prefix, false);
        typ = findMember(nameTree.id, prefixTyp, lowerBound);
        typ = replaceSelfWithPrefix(typ, prefixTyp, nameTree.prefix);
        return typ;
      } else if (nameTree.type === "CONSTRUCT") {
        return nameTree;
      } else {
        throw new Error("Internal compiler error: Expected name tree in requireMember, got '" + nameTree.type + "'");
      }
    })();
    if (!typTree) {
      throw new Error("Error: Unable to find type of '" + (nameTree.stringify(0)) + "' on line " + nameTree.line + " character " + nameTree.column);
    } else {
      return typTree;
    }
  };

  replaceSelfWithPrefix = function(typ, enclosing, prefix) {
    return deepCopyTree(typ, function(t) {
      var t1;
      if (t.type === "ID") {
        requireMember(t);
        if (t.definingTree === enclosing) {
          log(types, "Replacing self." + t.match + " with " + (prefix.stringify(0)) + "." + t.match + " where self:" + (enclosing.stringify(0)));
          t1 = shallowCopyTree(t);
          t1.type = "TYPE-SELECT";
          t1.ID = t.match;
          t1.prefix = prefix;
          t1.stringify = function(indent) {
            return (t1.prefix.stringify(indent)) + "." + t1.ID;
          };
          return t1;
        }
      }
      if (t.type === "id") {
        requireMember(t);
        if (t.definingTree === enclosing) {
          log(types, "Replacing self." + t.match + " with " + (prefix.stringify(0)) + "." + t.match + " where self:" + (enclosing.stringify(0)));
          t1 = shallowCopyTree(t);
          t1.type = "TERM-SELECT";
          t1.id = t.match;
          t1.prefix = prefix;
          t1.stringify = function(indent) {
            return "#" + (t1.prefix.stringify(indent)) + ".{t1.id}";
          };
          return t1;
        }
      }
      return t;
    });

    /*
    	deepCopyTree(typ, (t, insideStatement) ->
    		 *
    		 * For every id and ID that is defined in the given context, turn it into a select with the given prefix.
    		 * We need to transform prefix-less identifiers only, since only identifiers are implicitly understood
    		 * to be prefixed with a self-reference.
    		 *
    		if t.type is "ID"
    			startCtx = if insideStatement then t.ctx else t.ctx.outer   # if we're inside a statement, look up in the current context, otherwise enclosing context
    			if getDefContext(t.match, startCtx) is ctx
    				t1 = shallowCopyTree(t)
    				t1.type = "TYPE-SELECT"
    				t1.ID = t.match
    				t1.prefix = prefix
    				t1.stringify = (indent) -> "#{t1.ID}.#{t1.prefix.stringify(indent)}"
    				return t1
    		if t.type is "id"
    			startCtx = if insideStatement then t.ctx else t.ctx.outer
    			if getDefContext(t.match, startCtx) is ctx
    				t1 = shallowCopyTree(t)
    				t1.type = "TERM-SELECT"
    				t1.id = t.match
    				t1.prefix = prefix
    				t1.stringify = (indent) -> "#{t1.id}.#{t1.prefix.stringify(indent)}"
    				return t1
    		t
    	)
     */
  };

  contextify = function(currentTree, enclosingTree, freshTree) {
    var j, len, ref, results, st;
    if (tree.type === "STATEMENTS") {
      freshTree.enclosing = enclosingTree;
      enclosingTree = freshTree;
      ref = tree.statements;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        if (st.type === "TERM-DECL") {
          results.push(contextify(st.rhs, enclosingTree, st.rhs));
        } else if (st.type === "TYPE-DECL") {
          contextify(st.rhsLower, enclosingTree, st.rhsLower);
          results.push(contextify(st.rhsUpper, enclosingTree, st.rhsUpper));
        } else if (st.type === "TYPE-ASSIGN") {
          results.push(contextify(st.rhs, enclosingTree, st.rhs));
        } else if (st.type === "TERM-ASSIGN") {
          if (st.guard) {
            contextify(st.guard, enclosingTree, freshTree);
          }
          contextify(st.lhs, enclosingTree, freshTree);
          results.push(contextify(st.rhs, enclosingTree, freshTree));
        } else {
          throw new Error("Internal compiler error: Unexpected '" + tree.type + "' tree in statement block");
        }
      }
      return results;
    } else if (tree.type === "ID" || tree.type === "id") {
      return currentTree.enclosing = enclosingTree;
    } else if (tree.type === "TYPE-SELECT" || tree.type === "TERM-SELECT") {
      return contextify(tree.prefix, enclosingTree, freshTree);
    } else if (tree.type === "AND-TYPE" || tree.type === "OR-TYPE") {
      contextify(tree.lhs, enclosingTree, freshTree);
      return contextify(tree.rhs, enclosingTree, freshTree);
    } else if (tree.type === "CONSTRUCT") {
      return contextify(tree.typTree, enclosingTree, tree.typTree);
    } else {
      throw new Error("Internal compiler error: Unexpected '" + tree.type + "' tree in contextify");
    }
  };


  /* LAZY INFO FUNCTIONS ... TODO: Do we really need these? */


  /*
  doTypeCompleters = (tree, ctx) ->
  
  	tree.ctx = ctx
  
  	if tree.type is "STATEMENTS"
  		for st in tree.statements
  			doStatementCompleters(st, tree.ctx)
  
  	else if tree.type is "ID"
  		 * TODO?
  
  	else if tree.type is "TYPE-SELECT"
  		doTermCompleters(tree.prefix, ctx)
  
  	else if tree.type is "AND-TYPE" or tree.type is "OR-TYPE"
  		doTypeCompleters(tree.lhs, ctx)
  		doTypeCompleters(tree.rhs, ctx)
  
  	else
  		throw new Error("Unexpected #{tree.type} tree in doTypeCompleters")
  
  
  doTermCompleters = (tree, ctx) ->
  
  	if tree.type is "id"
  		tree.info = () ->
  			requireMemberInContext(tree.match, ctx, tree)
  
  	else if tree.type is "TERM-SELECT"
  		tree.info = () ->
  			requireMemberInType(tree.id, tree.prefix.info(), ctx, tree)
  		doTermCompleters(tree.prefix, ctx)
  
  	else if tree.type is "CONSTRUCT"
  		ctx = ctx.fresh(tree.typTree)
  		 * Note on info() functions: The invariant of info() is that it always returns a type tree (not a statement or a term).
  		 * There are at least two variants on info(): return the type tree as-is, or return a STATEMENTS tree containing linearized declarations.
  		 *  (We do the former here.)
  		tree.info = () ->
  			tree.typTree
  		doTypeCompleters(tree.typTree, ctx)
  
  	else
  		throw new Error("Unexpected #{tree.type} tree in doTermCompleters")
  
  doStatementCompleters = (tree, ctx) ->
  	if tree.type is "TERM-DECL"
  		doTypeCompleters(tree.rhs, ctx)
  
  	else if tree.type is "TYPE-DECL"
  		doTypeCompleters(tree.rhsLower, ctx.fresh(tree.rhsLower))
  		doTypeCompleters(tree.rhsUpper, ctx.fresh(tree.rhsUpper))
  
  	else if tree.type is "TYPE-ASSIGN"
  		doTypeCompleters(tree.lhs, ctx)
  		doTypeCompleters(tree.rhs, ctx)
  
  	else if tree.type is "TERM-ASSIGN"
  		doTermCompleters(tree.lhs, ctx)
  		doTermCompleters(tree.rhs, ctx)
  
  	else
  		doTermCompleters(tree, ctx)  # assume anything else is a term
   */


  /* TYPE COMPARISONS */

  isSubType = function(t0, ctx0, t1, ctx1) {
    var j, len, member0, member0lower, member0upper, ref, ref1, ref2, ref3, ref4, st1, wctx0, wctx1, wtyp0, wtyp1;
    log(types, (t0.stringify(0)) + " <:? " + (t1.stringify(0)));
    if (t0 === t1) {
      return true;
    } else if (t0 === Nothing) {
      return true;
    } else if (t1 === Any) {
      return true;
    } else if (t0 === Any) {
      return false;
    } else if (t1 === Nothing) {
      return false;
    } else if (t1.type === "TYPE-SELECT") {
      if (t0.type === "TYPE-SELECT" && t0.ID === t1.ID && isSameReference(t0.prefix, ctx0, t1.prefix, ctx1)) {
        return true;
      } else {
        ref = widen(t1.prefix, ctx1, true), wctx1 = ref[0], wtyp1 = ref[1];
        substThis();
        return isSubType(t0, ctx0, wtyp1, wctx1);
      }
    } else if (t1.type === "ID") {
      if (t0.type === "ID" && t0.match === t1.match && isDefinedInSameContext(t0, ctx0, t1, ctx1)) {
        return true;
      } else {
        ref1 = widen(t1, ctx1, true), wctx1 = ref1[0], wtyp1 = ref1[1];
        return isSubType(t0, ctx0, wtyp1, wctx1);
      }
    } else if (t1.type === "AND-TYPE") {
      return isSubType(t0, ctx0, t1.lhs, ctx1) && isSubType(t0, ctx0, t1.rhs, ctx1);
    } else if (t1.type === "OR-TYPE") {
      return isSubType(t0, ctx0, t1.lhs, ctx1) || isSubType(t0, ctx0, t1.rhs, ctx1);
    } else if (t0.type === "ID") {
      ref2 = widen(t0, ctx0, false), wctx0 = ref2[0], wtyp0 = ref2[1];
      return isSubType(wtyp0, wctx0, t1, ctx1);
    } else if (t0.type === "TYPE-SELECT") {
      ref3 = widen(t0, ctx0, false), wctx0 = ref3[0], wtyp0 = ref3[1];
      return isSubType(wtyp0, wctx0, t1, ctx1);
    } else if (t0.type === "AND-TYPE") {
      return isSubType(t0.lhs, ctx0, t1, ctx1) || isSubType(t0.rhs, ctx0, t1, ctx1);
    } else if (t0.type === "OR-TYPE") {
      return isSubType(t0.lhs, ctx0, t1, ctx1) && isSubType(t0.rhs, ctx0, t1, ctx1);
    } else if (!(t0.type === "STATEMENTS" && t1.type === "STATEMENTS")) {
      throw new Error("Internal compiler error: Expected types in isSubType, but attempted to compare a " + t0.type + " tree with a " + t1.type + " tree");
    } else {
      ref4 = t1.statements;
      for (j = 0, len = ref4.length; j < len; j++) {
        st1 = ref4[j];
        if (st1.type === "TYPE-DECL") {
          member0upper = findMember(st1.lhs, t0, ctx0, false);
          if (!member0upper) {
            log(types, "Failure to find member " + st.lhs + " in type " + t0);
            return false;
          }
          if (!isSubType(member0upper, ctx0, st1.rhsUpper, ctx1)) {
            log(types, member0upper + ", the upper bound of " + st1.lhs + " in " + t0 + ", is not compatible with " + st1.rhsUpper);
            return false;
          }
          member0lower = findMember(st1.lhs, t0, ctx0, true);
          if (!isSubType(st1.rhsLower, ctx1, member0lower, ctx0)) {
            log(types, st1.rhsLower + " is not compatible with " + member0lower + ", the lower bound of " + st1.lhs + " in " + t0);
            return false;
          }
        } else if (st1.type === "TERM-DECL") {
          member0 = findMember(st1.lhs, t0, ctx0, false);
          if (!member0) {
            log(types, "Failure to find member " + st1.lhs + " in type " + t0);
            return false;
          }
          if (!isSubType(member0, ctx0, st1.rhs, ctx1)) {
            log(types, "Type " + member0 + " declared for field " + st1.lhs + " is not compatible with type " + st1.rhs);
            return false;
          }
          if (!isSubType(st1.rhs, ctx1, member0, ctx0)) {
            log(types, "Type " + st1.rhs + " declared for field " + st1.lhs + " is not compatible with type " + member0);
            return false;
          }
        }
      }
      return true;
    }
  };

  isSameReference = function(tree0, ctx0, tree1, ctx1) {
    if (tree0.type === "id") {
      return tree1.type === "id" && tree0.match === tree1.match && isDefinedInSameContext(tree0, ctx0, tree1, ctx1);
    } else if (tree0.type === "TERM-SELECT") {
      return tree1.type === "TERM-SELECT" && tree0.id === tree1.id && isSameReference(tree0.prefix, ctx0, tree1.prefix, ctx1);
    } else {
      return false;
    }
  };

  isDefinedInSameContext = function(tree0, ctx0, tree1, ctx1) {
    return requireDefContext(tree0.match, ctx0, tree0) === requireDefContext(tree1.match, ctx1, tree1);
  };

  requireCompatibility = function(t0, ctx0, t1, ctx1, whereTree) {
    if (isSubType(t0, ctx0, t1, ctx1)) {
      return true;
    } else {
      throw new Error("Type error: expected: " + (t1.stringify(0)) + "\n\tGot: " + (t0.stringify(0)) + "\n\tOn line " + whereTree.line + " character " + whereTree.column);
    }
  };

  requireTermCompatibility = function(tree0, tree1, ctx) {
    var ctx0, ctx1, ref, ref1, ref2, ref3, t0, t1;
    if (!((ref = tree0.type) === "id" || ref === "TERM-SELECT" || ref === "CONSTRUCT")) {
      throw new Error("Internal compiler error: Expected term in requireTermCompatibility, got " + tree0.type);
    }
    if (!((ref1 = tree1.type) === "id" || ref1 === "TERM-SELECT" || ref1 === "CONSTRUCT")) {
      throw new Error("Internal compiler error: Expected term in requireTermCompatibility, got " + tree1.type);
    }
    ref2 = widen(tree0, ctx, false), ctx0 = ref2[0], t0 = ref2[1];
    ref3 = widen(tree1, ctx, false), ctx1 = ref3[0], t1 = ref3[1];
    requireCompatibility(t0, ctx0, t1, ctx1, tree1);
    return log(types, "Successfully compared type " + (t0.stringify(0)) + " to " + (t1.stringify(0)) + " on line " + tree1.line);
  };


  /* CODEGEN */

  gen = function(tree, ctx, indent, output) {
    var baseWithProblem, bases, defCtx, j, k, len, len1, prefixCtx, prefixType, ref, ref1, ref2, ref3, ref4, ref5, results, st;
    if (tree.type === "STATEMENTS") {
      ref = tree.statements;
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        if (st.type === "TYPE-DECL") {
          ref1 = linearizedForConstruction(st.rhsLower, ctx), bases = ref1[0], baseWithProblem = ref1[1];
          if (bases) {
            output.push(tabs(indent));
            defCtx = requireDefContext(st.lhs.match, ctx, tree);
            output.push("if(!" + defCtx.name + "." + st.lhs.match + "){");
            output.push(defCtx.name + "." + st.lhs.match);
            output.push(" = ");
            genInitializer(bases, st.rhsLower.ctx, ctx, indent, output);
            output.push(";}\n");
          }
        }
      }
      ref2 = tree.statements;
      results = [];
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        st = ref2[k];
        if (st.type === "TERM-ASSIGN") {
          requireTermCompatibility(st.rhs, st.lhs, ctx);
          output.push(tabs(indent));
          if (st.guard) {
            output.push("if(");
            gen(st.guard.condition, ctx, indent, output);
            output.push("){ ");
          }
          gen(st.lhs, ctx, indent, output);
          output.push(" = ");
          gen(st.rhs, ctx, indent, output);
          if (st.guard) {
            output.push(" }");
          }
          results.push(output.push(";\n"));
        } else if ((ref3 = st.type) === "id" || ref3 === "TERM-SELECT" || ref3 === "CONSTRUCT") {
          output.push(tabs(indent));
          if (st.guard) {
            output.push("if(");
            gen(st.guard.condition, ctx, indent, output);
            output.push("){ ");
          }
          gen(st, ctx, indent, output);
          if (st.guard) {
            output.push(" }");
          }
          results.push(output.push(";\n"));
        } else {
          if (st.guard) {
            throw new Error("Unexpected guard on " + st.type + " statement on line " + st.guard.line);
          } else {
            results.push(void 0);
          }
        }
      }
      return results;
    } else if (tree.type === "CONSTRUCT") {
      ref4 = linearizedForConstruction(tree.typTree, ctx), bases = ref4[0], baseWithProblem = ref4[1];
      if (bases === false) {
        throw new Error("Cannot construct the object at line " + tree.line + " character " + tree.column + " because base type '" + (baseWithProblem.stringify(0)) + "' is non-constructible.");
      }
      return genConstructor(bases, tree.typTree.ctx, ctx, indent, output);
    } else if (tree.type === "id") {
      if (tree.match === "???") {
        return output.push("(function(){ throw new Error('Not Implemented'); })()");
      } else {
        defCtx = requireDefContext(tree.match, ctx, tree);
        return output.push(defCtx.name + "." + tree.match);
      }
    } else if (tree.type === "TERM-SELECT") {
      ref5 = widen(tree.prefix, ctx), prefixCtx = ref5[0], prefixType = ref5[1];
      requireMemberInType(tree.id, prefixType, prefixCtx, tree);
      gen(tree.prefix, ctx, indent, output);
      output.push(".");
      return output.push(tree.id);
    }
  };

  genInitializer = function(bases, ctx, outer, indent, output) {
    var base, defCtx, j, len;
    output.push("function(" + ctx.name + "){\n");
    for (j = 0, len = bases.length; j < len; j++) {
      base = bases[j];
      if (base.type === "STATEMENTS") {
        gen(base, ctx, indent + 1, output);
      } else if (base.type === "ID") {
        defCtx = requireDefContext(base.match, outer, base);
        output.push(tabs(indent + 1));
        output.push(defCtx.name + "." + base.match + "(" + ctx.name + ");\n");
      } else if (base.type === "TYPE-SELECT") {
        output.push(tabs(indent + 1));
        gen(base.prefix, outer, indent + 1, output);
        output.push("." + base.ID + "(" + ctx.name + ");\n");
      } else if (base.type === "ANY") {

      } else {
        throw new Error("Internal compiler error: Unexpected base type tree " + base.type + " in genConstructor. Line " + tree.line + " character " + tree.column);
      }
    }
    output.push(tabs(indent + 1));
    output.push("return " + ctx.name + ";\n");
    output.push(tabs(indent));
    return output.push("}");
  };

  genConstructor = function(bases, ctx, outer, indent, output) {
    var base, defCtx, j, len;
    output.push("(function(" + ctx.name + "){\n");
    for (j = 0, len = bases.length; j < len; j++) {
      base = bases[j];
      if (base.type === "STATEMENTS") {
        gen(base, ctx, indent + 1, output);
      } else if (base.type === "ID") {
        if (base.match !== "Any") {
          defCtx = requireDefContext(base.match, outer, base);
          output.push(tabs(indent + 1));
          output.push(defCtx.name + "." + base.match + "(" + ctx.name + ");\n");
        }
      } else if (base.type === "TYPE-SELECT") {
        output.push(tabs(indent + 1));
        gen(base.prefix, outer, indent + 1, output);
        output.push("." + base.ID + "(" + ctx.name + ");\n");
      } else if (base.type === "ANY") {

      } else {
        throw new Error("Internal compiler error: Unexpected base type tree " + base.type + " in genConstructor. Line " + tree.line + " character " + tree.column);
      }
    }
    output.push(tabs(indent + 1));
    output.push("return " + ctx.name + ";\n");
    output.push(tabs(indent));
    return output.push("})({})");
  };


  /* PARSER */

  Token = function(tokType, text, line, column) {
    var tk;
    tk = {
      type: tokType,
      match: text,
      line: line,
      column: column,
      isToken: true
    };
    tk.stringify = function() {
      return tk.match.replace('\n', '\\n');
    };
    tk.print = function() {
      return tk.type + ", \"" + (tk.match.replace('\n', '\\n')) + "\", line " + tk.line + ", character " + tk.column;
    };
    return tk;
  };

  TypeDecl = function(lhs, rhsLower, rhsUpper) {
    var t;
    t = {
      type: "TYPE-DECL",
      alttypes: ["STATEMENT"],
      lhs: lhs,
      rhsLower: rhsLower,
      rhsUpper: rhsUpper,
      line: lhs.line,
      column: lhs.column
    };
    t.stringify = function(indent) {
      return t.lhs.stringify(indent) + ": at most " + t.rhsUpper.stringify(indent) + " at least " + t.rhsLower.stringify(indent);
    };
    t.subtrees = function() {
      return [t.lhs, t.rhsLower, t.rhsUpper];
    };
    return t;
  };

  TermDecl = function(lhs, rhs) {
    var t;
    t = {
      type: "TERM-DECL",
      alttypes: ["STATEMENT"],
      lhs: lhs,
      rhs: rhs,
      line: lhs.line,
      column: lhs.column
    };
    if (t.lhs.isVal) {
      WithAnnotation(t, "@final");
    }
    t.stringify = function(indent) {
      return t.lhs.stringify(indent) + ": " + t.rhs.stringify(indent);
    };
    t.subtrees = function() {
      return [t.lhs, t.rhs];
    };
    return t;
  };

  WithAnnotation = function(t, annot) {
    if (t.annots) {
      return t.annots.push(annot);
    } else {
      return t.annots = [annot];
    }
  };

  HasAnnotation = function(t, annot) {
    return t.annots && (indexOf.call(t.annots, annot) >= 0);
  };

  WithGuard = function(guard, statement) {
    var prevStringify, prevSubtrees;
    statement.guard = guard;
    prevStringify = statement.stringify;
    statement.stringify = function(indent) {
      return guard.stringify(indent) + prevStringify(indent);
    };
    prevSubtrees = statement.subtrees;
    statement.subtrees = function() {
      return [statement.guard].concat(prevSubtrees());
    };
    return statement;
  };

  parse = function(tokens) {
    var begin, expected, fromTopOfStack, i, matches, reduce, shift, showTypes, stack, stack_contents, t, unreducedTokenCount;
    stack = [];
    unreducedTokenCount = function() {
      var i, j, ref;
      for (i = j = 1, ref = stack.length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        if (!stack[stack.length - i].isToken) {
          return i - 1;
        }
      }
      return stack.length;
    };
    matches = function(types, skip) {
      var elem, i, j, ref, ref1;
      if (skip == null) {
        skip = 0;
      }
      if (types.length <= stack.length - skip) {
        for (i = j = 0, ref = types.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          if (types[i] !== "*") {
            elem = stack[stack.length - types.length + i - skip];
            if (elem.type !== types[i] && !(elem.alttypes && (ref1 = types[i], indexOf.call(elem.alttypes, ref1) >= 0))) {
              return false;
            }
          }
        }
        return true;
      } else {
        return false;
      }
    };
    fromTopOfStack = function(i) {
      if (i == null) {
        i = 0;
      }
      if (i > stack.length - 1) {
        return void 0;
      } else {
        return stack[stack.length - 1 - i];
      }
    };
    shift = function() {
      var t;
      t = tokens.shift();
      if (t.type === "id") {
        t.alttypes = ["TERM"];
      }
      if (t.type === "ID") {
        t.alttypes = ["TYPE"];
      }
      return stack.push(t);
    };
    expected = function(description) {
      var t, value;
      if (stack.length > 0) {
        t = stack[stack.length - 1];
        value = t.isToken ? t.match.replace('\n', '\\n') : t.stringify(0);
        throw "Parse error on line " + t.line + " character " + t.column + " : Expected " + description + "; got " + t.type + " with value \"" + value + "\"";
      } else {
        throw "Parse error with empty stack: Expected " + description;
      }
    };
    reduce = function() {

      /* Handle Comments */
      var ID, _typTree, a, b, c, condition, construct, guard, id, lhs, lparen, nl, nw, prefix, prevStringify, prevSubtrees, rhs, rhsLower, rhsUpper, statement, stmt, stmts, t, term;
      if (matches(["COMMENT"])) {
        stack.pop();
        return true;
      }
      if (matches(["START-BLOCK-COMMENT", "END-BLOCK-COMMENT"])) {
        stack.pop();
        stack.pop();
        return true;
      }
      if (matches(["START-BLOCK-COMMENT", "START-BLOCK-COMMENT"])) {
        return false;
      }
      if (matches(["START-BLOCK-COMMENT", "*"])) {
        stack.pop();
        return true;
      }

      /* Recognize ids that are really keywords */
      if (matches(["id"])) {
        if (fromTopOfStack(0).match === "new") {
          fromTopOfStack(0).type = "NEW";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "var") {
          fromTopOfStack(0).type = "VAR";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "val") {
          fromTopOfStack(0).type = "VAL";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "type") {
          fromTopOfStack(0).type = "TYPE-KEYWORD";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "if") {
          fromTopOfStack(0).type = "IF";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "then") {
          fromTopOfStack(0).type = "THEN";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "outer") {
          fromTopOfStack(0).type = "OUTER";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
      }
      if (matches(["id", "id"])) {
        a = fromTopOfStack(1);
        b = fromTopOfStack(0);
        if (a.match === "at" && b.match === "least") {
          stack.pop();
          a.type = "ATLEAST";
          a.match = a.match + " " + b.match;
          a.alttypes = void 0;
          return true;
        }
        if (a.match === "at" && b.match === "most") {
          stack.pop();
          a.type = "ATMOST";
          a.match = a.match + " " + b.match;
          a.alttypes = void 0;
          return true;
        }
      }

      /* Selections */
      if (matches(["IF", "TERM", "THEN"])) {
        stack.pop();
        condition = stack.pop();
        stack.pop();
        guard = {
          type: "GUARD",
          condition: condition,
          line: condition.line,
          column: condition.column
        };
        guard.stringify = function(indent) {
          return "if " + (guard.condition.stringify(indent)) + " then ";
        };
        guard.subtrees = function() {
          return [guard.condition];
        };
        stack.push(guard);
        return true;
      }
      if (matches(["GUARD", "STATEMENT"])) {
        statement = stack.pop();
        guard = stack.pop();
        stack.push(WithGuard(guard, statement));
        return true;
      }
      if (matches(["GUARD", "*", "NEWLINE"])) {
        nl = stack.pop();
        term = stack.pop();
        guard = stack.pop();
        stack.push(WithGuard(guard, term));
        stack.push(nl);
        return true;
      }
      if (matches(["TERM", "DOT", "id"])) {
        id = stack.pop();
        stack.pop();
        prefix = stack.pop();
        t = {
          type: "TERM-SELECT",
          alttypes: ["TERM"],
          prefix: prefix,
          id: id.match,
          line: id.line,
          column: id.column
        };
        t.stringify = function(indent) {
          return t.prefix.stringify(indent) + ("." + t.id);
        };
        t.subtrees = function() {
          return [t.prefix];
        };
        stack.push(t);
        return true;
      }
      if (matches(["TERM", "DOT", "ID"])) {
        ID = stack.pop();
        stack.pop();
        prefix = stack.pop();
        t = {
          type: "TYPE-SELECT",
          alttypes: ["TYPE"],
          prefix: prefix,
          ID: ID.match,
          line: ID.line,
          column: ID.column
        };
        t.stringify = function(indent) {
          return t.prefix.stringify(indent) + ("." + t.ID);
        };
        t.subtrees = function() {
          return [t.prefix];
        };
        stack.push(t);
        return true;
      }
      if (matches(["VAR", "id", "COLON"])) {
        c = stack.pop();
        id = stack.pop();
        stack.pop();
        id.isVar = true;
        stack.push(id);
        stack.push(c);
        return true;
      }
      if (matches(["VAL", "id", "COLON"])) {
        c = stack.pop();
        id = stack.pop();
        stack.pop();
        id.isVal = true;
        stack.push(id);
        stack.push(c);
        return true;
      }
      if (matches(["TYPE-KEYWORD", "ID", "COLON"])) {
        c = stack.pop();
        ID = stack.pop();
        stack.pop();
        stack.push(ID);
        stack.push(c);
        return true;
      }
      if (matches(["ID", "COLON", "*", "*", "*", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["ATMOST", "TYPE", "ATLEAST", "TYPE"])) {
          rhsLower = stack.pop();
          stack.pop();
          rhsUpper = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        } else if (matches(["ATLEAST", "TYPE", "ATMOST", "TYPE"])) {
          rhsUpper = stack.pop();
          stack.pop();
          rhsLower = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        }
      }
      if (matches(["ID", "COLON", "*", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["ATMOST", "TYPE"])) {
          rhsUpper = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          rhsLower = Token("ID", "Nothing", rhsUpper.line, rhsUpper.column);
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        } else if (matches(["ATLEAST", "TYPE"])) {
          rhsLower = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          rhsUpper = Token("ID", "Any", rhsLower.line, rhsLower.column);
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        }
      }
      if (matches(["ID", "COLON", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhs, rhs));
          return true;
        } else {
          expected("TYPE in declaration of " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["id", "COLON", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TermDecl(lhs, rhs));
          return true;
        } else {
          expected("TYPE in declaration of " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["ID", "EQUALS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TYPE-ASSIGN",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhs: rhs,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + " = " + t.rhs.stringify(indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhs];
          };
          stack.push(t);
          return true;
        } else {
          expected("TYPE in assignment to " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["id", "EQUALS", "*", "NEWLINE"]) || matches(["TERM-SELECT", "EQUALS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TERM"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TERM-ASSIGN",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhs: rhs,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + " = " + t.rhs.stringify(indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhs];
          };
          stack.push(t);
          return true;
        } else {
          expected("TERM in assignment to " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["TYPE", "AND", "TYPE"])) {
        rhs = stack.pop();
        stack.pop();
        lhs = stack.pop();
        t = {
          type: "AND-TYPE",
          alttypes: ["TYPE"],
          lhs: lhs,
          rhs: rhs,
          line: lhs.line,
          column: lhs.column
        };
        t.stringify = function(indent) {
          return t.lhs.stringify(indent) + " & " + t.rhs.stringify(indent);
        };
        t.subtrees = function() {
          return [t.lhs, t.rhs];
        };
        stack.push(t);
        return true;
      }
      if (matches(["TYPE", "OR", "TYPE"])) {
        rhs = stack.pop();
        stack.pop();
        lhs = stack.pop();
        t = {
          type: "OR-TYPE",
          alttypes: ["TYPE"],
          lhs: lhs,
          rhs: rhs,
          line: lhs.line,
          column: lhs.column
        };
        t.stringify = function(indent) {
          return t.lhs.stringify(indent) + " | " + t.rhs.stringify(indent);
        };
        t.subtrees = function() {
          return [t.lhs, t.rhs];
        };
        stack.push(t);
        return true;
      }
      if (matches(["AT", "id", "TYPE"])) {
        t = stack.pop();
        id = stack.pop();
        stack.pop();
        WithAnnotation(t, id);
        prevStringify = t.stringify;
        prevSubtrees = t.subtrees;
        t.stringify = function(indent) {
          return "@" + t.id.match + " " + prevStringify(indent);
        };
        t.subtrees = function() {
          return prevSubtrees().concat([t.typ]);
        };
        stack.push(t);
        return true;
      }
      if (matches(["STATEMENTS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TERM"])) {
          stmt = stack.pop();
          stmts = stack.pop();
          stmts.statements.push(stmt);
          stmts.line = stmt.line;
          stmts.column = stmt.column;
          stack.push(stmts);
          return true;
        } else {
          expected("STATEMENT");
        }
      }
      if (matches(["STATEMENTS", "STATEMENT"])) {
        stmt = stack.pop();
        stmts = stack.pop();
        stmts.statements.push(stmt);
        stmts.line = stmt.line;
        stmts.column = stmt.column;
        stack.push(stmts);
        return true;
      }
      if (matches(["LBRACE"])) {
        lparen = fromTopOfStack();
        begin(lparen.line, lparen.column);
        return true;
      }
      if (matches(["LBRACE", "STATEMENTS", "RBRACE"])) {
        stack.pop();
        stmts = stack.pop();
        stack.pop();
        stack.push(stmts);
        return true;
      }
      if (matches(["*", "DOT", "NEW"])) {
        nw = stack.pop();
        stack.pop();
        if (matches(["TYPE"])) {
          _typTree = stack.pop();
          construct = {
            type: "CONSTRUCT",
            alttypes: ["TERM"],
            typTree: _typTree,
            line: nw.line,
            column: nw.column
          };
          construct.stringify = function(indent) {
            return (construct.typTree.stringify(indent)) + ".new";
          };
          construct.subtrees = function() {
            return [construct.typTree];
          };
          stack.push(construct);
          return true;
        } else {
          throw new Error("Expected type in object construction on line " + nw.line + " character " + nw.column + ", got " + (fromTopOfStack(0).stringify(0)));
        }
      }
      if (matches(["STATEMENTS", "NEWLINE"])) {
        stack.pop();
        return true;
      }
    };
    begin = function(ln, col) {
      var stmts;
      stmts = {
        type: "STATEMENTS",
        alttypes: ["TYPE"],
        statements: [],
        line: ln,
        column: col
      };
      stmts.stringify = function(indent) {
        return stringifyStatements(stmts, indent);
      };
      stmts.subtrees = function() {
        return stmts.statements;
      };
      stmts.print = stmts.stringify;
      return stack.push(stmts);
    };
    showTypes = function(t) {
      var s, typ;
      s = t.type;
      if (t.alttypes) {
        s = s + " & " + ((function() {
          var j, len, ref, results;
          ref = t.alttypes;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            typ = ref[j];
            results.push(typ);
          }
          return results;
        })()).join(" & ");
      }
      return s;
    };
    begin(1, 1);
    while (true) {
      while (reduce()) {
        true;
      }
      if (tokens[0].type === "EOF" || unreducedTokenCount() >= 8) {
        break;
      }
      shift();
    }
    if (stack.length !== 1) {
      i = -1;
      stack_contents = ((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = stack.length; j < len; j++) {
          t = stack[j];
          i += 1;
          results.push("Item " + i + ": " + (showTypes(t)) + "\n" + (t.stringify(0)));
        }
        return results;
      })()).join("\n\n");
      throw "Parse error: Unreduced items on stack at End-of-Input. Stack contents:\n\n" + stack_contents;
    }
    return stack[0];
  };

  tokenize = function(input) {
    var Whitespace, column, consumeNextToken, getNextToken, line, t, tk, tokenList, tokens;
    line = 1;
    column = 1;
    tokenList = [
      {
        name: "id",
        regex: /^([a-z][a-zA-z0-9_]*|\?\?\?)/
      }, {
        name: "ID",
        regex: /^[A-Z][a-zA-z0-9_]*/
      }, {
        name: "NEWLINE",
        regex: /^(\n|\r\n|\r)/
      }, {
        name: "COMMENT",
        regex: /^\/\/.*/
      }, {
        name: "START-BLOCK-COMMENT",
        regex: /^\/\*/
      }, {
        name: "END-BLOCK-COMMENT",
        regex: /^\*\//
      }, {
        name: "DOT",
        regex: /^\./
      }, {
        name: "AND",
        regex: /^&/
      }, {
        name: "OR",
        regex: /^\|/
      }, {
        name: "AT",
        regex: /^@/
      }, {
        name: "EQUALS",
        regex: /^=/
      }, {
        name: "LPAREN",
        regex: /^\(/
      }, {
        name: "RPAREN",
        regex: /^\)/
      }, {
        name: "LBRACE",
        regex: /^{/
      }, {
        name: "RBRACE",
        regex: /^}/
      }, {
        name: "COLON",
        regex: /^:/
      }, {
        name: "SEMI",
        regex: /^;/
      }, {
        name: "EOF",
        regex: /^$/
      }
    ];
    Whitespace = {
      name: "SPACE",
      regex: /^[\t \v\f]+/
    };
    getNextToken = function() {
      var j, len, length, matches, tok;
      matches = Whitespace.regex.exec(input);
      if (matches) {
        input = input.substring(matches[0].length);
        column += matches[0].length;
      }
      for (j = 0, len = tokenList.length; j < len; j++) {
        tok = tokenList[j];
        matches = tok.regex.exec(input);
        if (matches) {
          return Token(tok.name, matches[0], line, column);
        }
      }
      length = input.indexOf('\n');
      if (length <= 0) {
        length = input.length;
      }
      throw "Tokenization error on line " + line + " character " + column + " : Unable to match a token starting at '" + (input.substring(0, length)) + "'";
    };
    consumeNextToken = function() {
      var tok;
      tok = getNextToken();
      input = input.substring(tok.match.length);
      column += tok.match.length;
      if (tok.type === "NEWLINE") {
        column = 1;
        line += 1;
      }
      return tok;
    };
    tokens = [];
    while (true) {
      t = consumeNextToken();
      if (t.type === "RBRACE" || t.type === "EOF") {
        tk = Token("NEWLINE", "\n", t.line, t.column);
        tk.stringify = function() {
          return "(synthetic \\n)";
        };
        tk.print = function() {
          return "synthetic NEWLINE on line " + t.line + ", char " + t.column;
        };
        tokens.push(tk);
      }
      tokens.push(t);
      if (t.type === "EOF") {
        break;
      }
    }
    return tokens;
  };

  stringifyStatements = function(stmts, indent) {
    var stmt;
    return "{\n" + ((function() {
      var j, len, ref, results;
      ref = stmts.statements;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        stmt = ref[j];
        results.push(tabs(indent + 1) + stmt.stringify(indent + 1) + "\n");
      }
      return results;
    })()).join("") + tabs(indent) + "}";
  };

  tabs = function(indent) {
    return "\t".repeat(indent);
  };

}).call(this);
