// Generated by CoffeeScript 1.10.0
(function() {
  var AndType, Any, HasAnnotation, Nothing, OrType, TermDecl, Token, TypeDecl, WithAnnotation, WithGuard, asConstructed, channels, clearLog, condenseBasesForConstruction, containsBase, contextify, createPredefTree, deepCopyTree, definingTree, derivedAndOrType, derivedAssignment, derivedConstruction, derivedGuard, derivedNameSelect, derivedTermDecl, derivedTypeDecl, findMember, fullyInlined, gen, genBaseCalls, genCtor, genProgram, genTypeInitializer, isSameReference, isSubType, log, lookupMember, maybeGenGuard, parse, replaceSelfWithPrefix, replaceSelfWithSelf, requireMember, shallowCopyTree, stderr, stringify, stringifyStatements, tabs, tokenize, types,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.compile = function(input, stopAfter) {
    var allOutput, ast, enclosing, error, error1, fresh, message, output, tok, tokens;
    try {
      clearLog();
      tokens = tokenize(input);
      if (stopAfter === "tokens") {
        return ((function() {
          var j, len, results;
          results = [];
          for (j = 0, len = tokens.length; j < len; j++) {
            tok = tokens[j];
            results.push(tok.print());
          }
          return results;
        })()).join('\n');
      }
      ast = parse(tokens);
      if (stopAfter === "trees") {
        return stringify(ast);
      }
      enclosing = createPredefTree();
      fresh = ast;
      contextify(ast, enclosing, fresh);
      output = genProgram(ast);
      allOutput = [output];
      if (channels[types]) {
        allOutput.push("/** Types log:\n\n" + channels[types].join("\n") + "\n**/");
      }
      if (channels[stderr]) {
        allOutput.push("/** Stderr log:\n\n" + channels[stderr].join("\n") + "\n**/");
      }
      return allOutput.join("\n\n");
    } catch (error1) {
      error = error1;
      message = error.message != null ? error.message : error;
      message = message.toUpperCase().startsWith("ERROR") || message.toUpperCase().startsWith("INTERNAL COMPILER ERROR") ? message : "Error: " + message;
      output = [message];
      if (channels[types]) {
        output.push("Types log:\n\n" + channels[types].join("\n"));
      }
      if (channels[stderr]) {
        output.push("Stderr log:\n\n" + channels[stderr].join("\n"));
      }
      if (error.stack != null) {
        output.push("COMPILER STACKTRACE:\n" + error.stack);
      }
      return output.join("\n\n");
    }
  };

  channels = {};

  stderr = "stderr";

  types = "types";

  clearLog = function() {
    return channels = {};
  };

  log = function(ch, msg) {
    if (!channels[ch]) {
      return channels[ch] = [msg];
    } else {
      return channels[ch].push(msg);
    }
  };

  Any = {
    type: "ANY",
    stringify: function(indent) {
      return "Any";
    }
  };

  Nothing = {
    type: "NOTHING",
    stringify: function(indent) {
      return "Nothing";
    }
  };

  AndType = function(lhsTyp, rhsTyp) {
    return {
      type: "AND-TYPE",
      lhs: lhsTyp,
      rhs: rhsTyp,
      stringify: function(indent) {
        return stringify(lhsTyp, indent) + " & " + stringify(rhsTyp, indent);
      }
    };
  };

  OrType = function(lhsTyp, rhsTyp) {
    return {
      type: "OR-TYPE",
      lhs: lhsTyp,
      rhs: rhsTyp,
      stringify: function(indent) {
        return stringify(lhsTyp, indent) + " | " + stringify(rhsTyp, indent);
      }
    };
  };


  /* TYPE OPERATIONS */

  shallowCopyTree = function(t) {
    return {
      type: t.type,
      ctx: t.ctx,
      line: t.line,
      column: t.column,
      annots: t.annots
    };
  };

  derivedNameSelect = function(t, prefix) {
    var t1;
    if (prefix === t.prefix) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.id = t.id;
      t1.ID = t.ID;
      t1.prefix = prefix;
      return t1;
    }
  };

  derivedAndOrType = function(tree, lhs, rhs) {
    if (lhs === tree.lhs && rhs === tree.rhs) {
      return tree;
    } else if (tree.type === "AND-TYPE") {
      return AndType(lhs, rhs);
    } else if (tree.type === "OR-TYPE") {
      return OrType(lhs, rhs);
    }
  };

  derivedTypeDecl = function(t, lhs, rhsUpper, rhsLower) {
    var t1;
    if (t.lhs === lhs && t.rhsUpper === rhsUpper && t.rhsLower === rhsLower) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.lhs = lhs;
      t1.rhsUpper = rhsUpper;
      t1.rhsLower = rhsLower;
      return t1;
    }
  };

  derivedTermDecl = function(t, lhs, rhs) {
    var t1;
    if (t.lhs === lhs && t.rhs === rhs) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.lhs = lhs;
      t1.rhs = rhs;
      return t1;
    }
  };

  derivedAssignment = function(t, guard1, lhs1, rhs1) {
    var t1;
    if (t.guard === guard1 && t.lhs === lhs1 && t.rhs === rhs1) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.guard = guard1;
      t1.lhs = lhs1;
      t1.rhs = rhs1;
      return t1;
    }
  };

  derivedGuard = function(t, condition) {
    var t1;
    if (t.condition === condition) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.condition = condition;
      return t1;
    }
  };

  derivedConstruction = function(t, guard, typTree) {
    var t1;
    if (t.typTree === typTree && t.guard === guard) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.typTree = typTree;
      t1.guard = guard;
      return t1;
    }
  };

  deepCopyTree = function(t, mutator, insideStatement) {
    var anyDifferent, guard1, lhs1, prefix1, rhs, rhs1, rhsLower, rhsUpper, st, st1, stmt1, t1, typTree1;
    t1 = (function() {
      var j, len, ref;
      if (t.type === "TYPE-SELECT" || t.type === "TERM-SELECT") {
        prefix1 = deepCopyTree(t.prefix, mutator, insideStatement);
        return derivedNameSelect(t, prefix1);
      } else if (t.type === "STATEMENTS") {
        stmt1 = shallowCopyTree(t);
        stmt1.statements = [];
        anyDifferent = false;
        ref = t.statements;
        for (j = 0, len = ref.length; j < len; j++) {
          st = ref[j];
          st1 = deepCopyTree(st, mutator, true);
          if (st1 !== st) {
            anyDifferent = true;
          }
          stmt1.statements.push(st1);
        }
        if (anyDifferent) {
          return stmt1;
        } else {
          return t;
        }
      } else if (t.type === "AND-TYPE" || t.type === "OR-TYPE") {
        lhs1 = deepCopyTree(t.lhs, mutator, insideStatement);
        rhs1 = deepCopyTree(t.rhs, mutator, insideStatement);
        return derivedAndOrType(t, lhs1, rhs1);
      } else if (t.type === "TYPE-DECL") {
        rhsUpper = deepCopyTree(t.rhsUpper, mutator, false);
        rhsLower = deepCopyTree(t.rhsLower, mutator, false);
        return derivedTypeDecl(t, t.lhs, rhsUpper, rhsLower);
      } else if (t.type === "TERM-DECL") {
        rhs = deepCopyTree(t.rhs, mutator, false);
        return derivedTermDecl(t, t.lhs, rhs);
      } else if (t.type === "TERM-ASSIGN") {
        guard1 = t.guard ? derivedGuard(t.guard, deepCopyTree(t.guard.condition, mutator)) : void 0;
        lhs1 = t.lhs.type === "id" ? t.lhs : deepCopyTree(t.lhs, mutator, true);
        rhs1 = deepCopyTree(t.rhs, mutator, true);
        return derivedAssignment(t, guard1, lhs1, rhs1);
      } else if (t.type === "CONSTRUCT") {
        guard1 = t.guard ? derivedGuard(t.guard, deepCopyTree(t.guard.condition, mutator)) : void 0;
        typTree1 = deepCopyTree(t.typTree, mutator, false);
        return derivedConstruction(t, guard1, typTree1);
      } else {
        return t;
      }
    })();
    return mutator(t1, insideStatement);
  };

  createPredefTree = function() {
    var predefTree;
    predefTree = {
      type: "STATEMENTS",
      statements: []
    };
    predefTree.stringify = function(indent) {
      return "{ (predefined symbols) }";
    };
    predefTree.statements.push(TypeDecl(Token("ID", "Any", void 0, void 0), Any, Any));
    predefTree.statements.push(TypeDecl(Token("ID", "Nothing", void 0, void 0), Nothing, Nothing));
    predefTree.statements.push(TermDecl(Token("ID", "???", void 0, void 0), Nothing));
    return predefTree;
  };

  findMember = function(name, typTree, lowerBound) {
    var expanded, j, len, lhsTyp, ref, rhsTyp, st;
    if (typTree.type === "STATEMENTS") {
      ref = typTree.statements;
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        if (st.type === "TYPE-DECL" && st.lhs.match === name) {
          if (lowerBound) {
            return st.rhsLower;
          } else {
            return st.rhsUpper;
          }
        } else if (st.type === "TERM-DECL" && st.lhs.match === name) {
          return st.rhs;
        }
      }
      return void 0;
    } else if (typTree.type === "ID" || typTree.type === "TYPE-SELECT") {
      expanded = requireMember(typTree, false);
      return findMember(name, expanded, lowerBound);
    } else if (typTree.type === "AND-TYPE") {
      lhsTyp = findMember(name, typTree.lhs, lowerBound);
      rhsTyp = findMember(name, typTree.rhs, lowerBound);
      if (lhsTyp && rhsTyp) {
        if (lowerBound) {
          return OrType(lhsTyp, rhsTyp);
        } else {
          return AndType(lhsTyp, rhsTyp);
        }
      } else if (lhsTyp) {
        return lhsTyp;
      } else {
        return rhsTyp;
      }
    } else if (typTree.type === "OR-TYPE") {
      lhsTyp = findMember(name, typTree.lhs, lowerBound);
      rhsTyp = findMember(name, typTree.rhs, lowerBound);
      if (lhsTyp && rhsTyp) {
        if (lowerBound) {
          return AndType(lhsTyp, rhsTyp);
        } else {
          return OrType(lhsTyp, rhsTyp);
        }
      } else {
        return void 0;
      }
    } else if (typTree.type === "CONSTRUCT") {
      return findMember(name, fullyInlined(typTree.typTree));
    } else if (typTree.type === "ANY") {
      return void 0;
    } else if (typTree.type === "NOTHING") {
      return void 0;
    } else {
      throw new Error("Internal compiler error: Expected a type tree in findMember(\"" + name + "\"), got '" + typTree.type + "' tree");
    }
  };

  containsBase = function(typTree, base) {
    var ref;
    if (typTree === base) {
      return true;
    } else if (typTree.type === "AND-TYPE") {
      return containsBase(typTree.lhs, base) || containsBase(typTree.rhs, base);
    } else if ((ref = typTree.type) === "STATEMENTS" || ref === "ANY" || ref === "NOTHING" || ref === "ID" || ref === "TYPE-SELECT") {
      return false;
    } else {
      throw new Error("Internal compiler error: Expected a fully-expanded type tree in containsBase, got '" + typTree.type + "' tree");
    }
  };

  condenseBasesForConstruction = function(typTree, expandName) {
    var expanded, lhsExpanded, ref;
    if ((ref = typTree.type) === "STATEMENTS" || ref === "ANY" || ref === "NOTHING") {
      return typTree;
    } else if (typTree.type === "ID" || typTree.type === "TYPE-SELECT") {
      if (expandName(typTree)) {
        expanded = requireMember(typTree, true);
        return condenseBasesForConstruction(expanded, expandName);
      } else {
        return typTree;
      }
    } else if (typTree.type === "AND-TYPE") {
      return AndType(condenseBasesForConstruction(typTree.lhs, expandName), condenseBasesForConstruction(typTree.rhs, expandName));
    } else if (typTree.type === "OR-TYPE") {
      lhsExpanded = condenseBasesForConstruction(typTree.lhs, function(t) {
        return true;
      });
      if (containsBase(lhsExpanded, Nothing)) {
        return condenseBasesForConstruction(typTree.rhs, expandName);
      } else {
        return condenseBasesForConstruction(typTree.lhs, expandName);
      }
    } else {
      throw new Error("Internal compiler error: Expected a type tree in condenseBasesForConstruction, got '" + typTree.type + "' tree");
    }
  };

  asConstructed = function(typTree) {
    if (!typTree.asConstructed) {
      typTree.asConstructed = condenseBasesForConstruction(typTree, function(t) {
        return false;
      });
    }
    return typTree.asConstructed;
  };

  fullyInlined = function(typTree) {
    if (!typTree.fullyInlined) {
      typTree.fullyInlined = condenseBasesForConstruction(typTree, function(t) {
        return true;
      });
    }
    return typTree.fullyInlined;
  };

  lookupMember = function(nameTree, lowerBound) {
    var enclosing, prefixTyp, typ, typTree;
    return typTree = (function() {
      if (nameTree.type === "id" || nameTree.type === "ID") {
        typ = void 0;
        enclosing = nameTree.enclosing;
        while (enclosing) {
          typ = findMember(nameTree.match, fullyInlined(enclosing), lowerBound);
          if (typ) {
            nameTree.definingTree = enclosing;
            if (typ.enclosing !== enclosing) {
              typ = replaceSelfWithSelf(typ, typ.enclosing, enclosing);
            }
            break;
          }
          enclosing = enclosing.enclosing;
        }
        return typ;
      } else if (nameTree.type === "TYPE-SELECT") {
        prefixTyp = requireMember(nameTree.prefix, false);
        typ = findMember(nameTree.ID, prefixTyp, lowerBound);
        typ = replaceSelfWithPrefix(typ, typ.enclosing, nameTree.prefix);
        return typ;
      } else if (nameTree.type === "TERM-SELECT") {
        prefixTyp = requireMember(nameTree.prefix, false);
        typ = findMember(nameTree.id, prefixTyp, lowerBound);
        typ = replaceSelfWithPrefix(typ, typ.enclosing, nameTree.prefix);
        return typ;
      } else if (nameTree.type === "CONSTRUCT") {
        return nameTree;
      } else {
        throw new Error("Internal compiler error: Expected name tree in lookupMember, got '" + nameTree.type + "'");
      }
    })();
  };

  requireMember = function(nameTree, lowerBound) {
    var typTree;
    typTree = lookupMember(nameTree, lowerBound);
    if (!typTree) {
      throw new Error("Error: Unable to find type of '" + (stringify(nameTree)) + "' on line " + nameTree.line + " character " + nameTree.column);
    } else {
      return typTree;
    }
  };

  definingTree = function(tree) {
    if (tree.type === "ID" || tree.type === "id") {
      if (!tree.definingTree) {
        requireMember(tree);
      }
      return tree.definingTree;
    } else {
      throw new Error("Internal compiler error: Expected id/ID tree in definingTree, got '" + tree.type + "' tree");
    }
  };

  replaceSelfWithPrefix = function(typ, enclosing, prefix) {
    return deepCopyTree(typ, function(t) {
      var t1;
      if (t.type === "ID") {
        if (definingTree(t) === enclosing) {
          log(types, "Replacing " + enclosing.selfName + "." + t.match + " with " + (stringify(prefix)) + "." + t.match + " where " + enclosing.selfName + ":" + (stringify(enclosing)));
          t1 = shallowCopyTree(t);
          t1.type = "TYPE-SELECT";
          t1.ID = t.match;
          t1.prefix = prefix;
          t1.stringify = function(indent) {
            return (stringify(t1.prefix, indent)) + "." + t1.ID;
          };
          return t1;
        }
      }
      if (t.type === "id") {
        if (definingTree(t) === enclosing) {
          log(types, "Replacing " + enclosing.selfName + "." + t.match + " with " + (stringify(prefix)) + "." + t.match + " where " + enclosing.selfName + ":" + (stringify(enclosing)));
          t1 = shallowCopyTree(t);
          t1.type = "TERM-SELECT";
          t1.id = t.match;
          t1.prefix = prefix;
          t1.stringify = function(indent) {
            return (stringify(t1.prefix, indent)) + "." + t1.id;
          };
          return t1;
        }
      }
      return t;
    });
  };

  replaceSelfWithSelf = function(typ, enclosing, newEnclosing) {
    return deepCopyTree(typ, function(t) {
      var t1;
      if (t.type === "ID" || t.type === "id") {
        if (definingTree(t) === enclosing) {
          t1 = shallowCopyTree(t);
          t1.definingTree = newEnclosing;
          t1.match = t.match;
          return t1;
        }
      }
      return t;
    });
  };

  contextify = function(tree, enclosingTree, freshTree) {
    var j, len, ref, results, st;
    if (tree.type === "STATEMENTS") {
      freshTree.enclosing = enclosingTree;
      enclosingTree = freshTree;
      ref = tree.statements;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        if (st.type === "TERM-DECL") {
          results.push(contextify(st.rhs, enclosingTree, st.rhs));
        } else if (st.type === "TYPE-DECL") {
          contextify(st.rhsLower, enclosingTree, st.rhsLower);
          results.push(contextify(st.rhsUpper, enclosingTree, st.rhsUpper));
        } else if (st.type === "TYPE-ASSIGN") {
          results.push(contextify(st.rhs, enclosingTree, st.rhs));
        } else if (st.type === "TERM-ASSIGN") {
          if (st.guard) {
            contextify(st.guard.condition, enclosingTree, freshTree);
          }
          contextify(st.lhs, enclosingTree, freshTree);
          results.push(contextify(st.rhs, enclosingTree, freshTree));
        } else {
          results.push(contextify(st, enclosingTree, freshTree));
        }
      }
      return results;
    } else if (tree.type === "ID" || tree.type === "id") {
      if (tree.guard) {
        contextify(tree.guard.condition, enclosingTree, freshTree);
      }
      return tree.enclosing = enclosingTree;
    } else if (tree.type === "TYPE-SELECT" || tree.type === "TERM-SELECT") {
      if (tree.guard) {
        contextify(tree.guard.condition, enclosingTree, freshTree);
      }
      return contextify(tree.prefix, enclosingTree, freshTree);
    } else if (tree.type === "AND-TYPE" || tree.type === "OR-TYPE") {
      contextify(tree.lhs, enclosingTree, freshTree);
      return contextify(tree.rhs, enclosingTree, freshTree);
    } else if (tree.type === "CONSTRUCT") {
      if (tree.guard) {
        contextify(tree.guard.condition, enclosingTree, freshTree);
      }
      return contextify(tree.typTree, enclosingTree, tree.typTree);
    } else {
      throw new Error("Internal compiler error: Unexpected '" + tree.type + "' tree in contextify");
    }
  };


  /* TYPE COMPARISONS */

  isSubType = function(t0, t1) {
    var j, len, member0, name1, ref, st0lower, st0upper, st1, t0upper, t1lower;
    log(types, (stringify(t0)) + " <:? " + (stringify(t1)));
    if (t0 === t1) {
      return true;
    } else if (t0 === Nothing) {
      return true;
    } else if (t1 === Any) {
      return true;
    } else if (t0 === Any) {
      return false;
    } else if (t1 === Nothing) {
      return false;
    } else if (t1.type === "AND-TYPE") {
      return isSubType(t0, t1.lhs) && isSubType(t0, t1.rhs);
    } else if (t1.type === "OR-TYPE") {
      return isSubType(t0(t1.lhs)) || isSubType(t0, t1.rhs);
    } else if (t0.type === "AND-TYPE") {
      return isSubType(t0.lhs, t1) || isSubType(t0.rhs, t1);
    } else if (t0.type === "OR-TYPE") {
      return isSubType(t0.lhs, t1) && isSubType(t0.rhs, t1);
    } else if (t1.type === "CONSTRUCT") {
      return isSubType(t0, t1.typTree);
    } else if (t0.type === "CONSTRUCT") {
      return isSubType(t0.typTree, t1);
    } else if (t1.type === "TYPE-SELECT" && t0.type === "TYPE-SELECT" && t0.ID === t1.ID && isSameReference(t0.prefix, t1.prefix)) {
      return true;
    } else if (t1.type === "ID" && t0.type === "ID" && t0.match === t1.match && definingTree(t0) === definingTree(t1)) {
      return true;
    } else if (t0.type === "TYPE-SELECT" || t0.type === "ID") {
      t0upper = requireMember(t0, false);
      return isSubType(t0upper, t1);
    } else if (t1.type === "TYPE-SELECT" || t1.type === "ID") {
      t1lower = requireMember(t1, true);
      return isSubType(t0, t1lower);
    } else if (!(t0.type === "STATEMENTS" && t1.type === "STATEMENTS")) {
      throw new Error("Internal compiler error: Expected types in isSubType, but attempted to compare a " + t0.type + " tree with a " + t1.type + " tree");
    } else {
      ref = t1.statements;
      for (j = 0, len = ref.length; j < len; j++) {
        st1 = ref[j];
        if (st1.type === "TYPE-DECL") {
          name1 = st1.lhs.match;
          st0upper = findMember(name1, t0, false);
          st0lower = findMember(name1, t0, true);
          if (!st0upper) {
            log(types, "isSubType: Failure to find member " + name1 + " in type " + (stringify(t0)));
            return false;
          }
          if (!isSubType(st0upper, st1.rhsUpper)) {
            log(types, "isSubType: " + (stringify(st0upper)) + ", the upper bound of " + name1 + " in " + (stringify(t0)) + ", is not compatible with " + (stringify(st1.rhsUpper)));
            return false;
          }
          if (!isSubType(st1.rhsLower, st1lower)) {
            log(types, "isSubType: " + (stringify(st1.rhsLower)) + " is not compatible with " + (stringify(st0lower)) + ", the lower bound of " + name1 + " in " + (stringify(t0)));
            return false;
          }
        } else if (st1.type === "TERM-DECL") {
          name1 = st1.lhs.match;
          member0 = findMember(name1, t0);
          if (!member0) {
            log(types, "isSubType: Failure to find member " + name1 + " in type " + (stringify(t0)));
            return false;
          }
          if (!isSubType(member0, st1.rhs)) {
            log(types, "isSubType: Type " + (stringify(member0)) + " declared for field " + name1 + " is not compatible with type " + (stringify(st1.rhs)));
            return false;
          }
          if (!isSubType(st1.rhs, member0)) {
            log(types, "isSubType: Type " + (stringify(st1.rhs)) + " declared for field " + name1 + " is not compatible with type " + (stringify(member0)));
            return false;
          }
        }
      }
      return true;
    }
  };

  isSameReference = function(tree0, tree1) {
    if (tree0.type === "id") {
      return tree1.type === "id" && tree0.match === tree1.match && definingTree(tree0) === definingTree(tree1);
    } else if (tree0.type === "TERM-SELECT") {
      return tree1.type === "TERM-SELECT" && tree0.id === tree1.id && isSameReference(tree0.prefix, tree1.prefix);
    } else if (tree0.type === "CONSTRUCT") {
      return tree1.type === "CONSTRUCT" && tree0.typTree === tree1.typTree;
    } else {
      throw new Error("Internal compiler error: Expected a term tree in isSameReference, got '" + tree0.type + "' tree");
    }
  };


  /* CODEGEN */

  genProgram = function(ast) {
    var getId, output, uniqueId;
    uniqueId = -1;
    getId = function() {
      uniqueId += 1;
      return uniqueId;
    };
    output = [];
    genCtor(ast, true, getId, 0, output);
    output.push(";");
    return output.join("");
  };

  genBaseCalls = function(base, fresh, getId, indent, output) {
    var j, k, len, len1, lowerLhs, ref, ref1, ref2, results, selfName, st, upperRhs;
    if (base.type === "STATEMENTS") {
      ref = base.statements;
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        if (st.type === "TYPE-DECL") {
          genTypeInitializer(fresh, st.lhs.match, st.rhsLower, getId, indent + 1, output);
        }
      }
      ref1 = base.statements;
      results = [];
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        st = ref1[k];
        if (st.type === "TERM-ASSIGN") {
          output.push(tabs(indent + 1));
          maybeGenGuard(st, getId, indent + 1, output);
          gen(st.lhs, getId, indent + 1, output);
          output.push(" = ");
          gen(st.rhs, getId, indent + 1, output);
          output.push(";\n");
          upperRhs = lookupMember(st.rhs, false);
          lowerLhs = lookupMember(st.lhs, true);
          if (!isSubType(upperRhs, lowerLhs)) {
            throw new Error("Type mismatch:\n\tExpected: " + (stringify(lowerLhs, 1)) + "\n\tGot: " + (stringify(upperRhs, 1)) + "\n\tLine " + st.line + " character " + st.column);
          } else {
            results.push(void 0);
          }
        } else if ((ref2 = st.type) === "id" || ref2 === "TERM-SELECT" || ref2 === "CONSTRUCT") {
          output.push(tabs(indent + 1));
          maybeGenGuard(st, getId, indent + 1, output);
          gen(st, getId, indent + 1, output);
          results.push(output.push(";\n"));
        } else {
          results.push(void 0);
        }
      }
      return results;
    } else if (base.type === "ID") {
      if (base.match !== "Any") {
        requireMember(base, true);
        selfName = base.definingTree.selfName;
        output.push(tabs(indent + 1));
        return output.push(selfName + "." + base.match + "(" + fresh.selfName + ");\n");
      }
    } else if (base.type === "TYPE-SELECT") {
      output.push(tabs(indent + 1));
      gen(base.prefix, getId, indent + 1, output);
      return output.push("." + base.ID + "(" + fresh.selfName + ");\n");
    } else if (base.type === "AND-TYPE") {
      genBaseCalls(base.lhs, fresh, getId, indent, output);
      return genBaseCalls(base.rhs, fresh, getId, indent, output);
    } else if (base.type === "ANY") {

    } else {
      throw new Error("Internal compiler error: Unexpected base type tree " + base.type + " in genBaseCalls. Line " + base.line + " character " + base.column);
    }
  };

  maybeGenGuard = function(tree, getId, indent, output) {
    if (tree.guard) {
      output.push("if (");
      gen(guard.condition, getId, indent, output);
      return output.push(") ");
    }
  };

  genCtor = function(tree, isConcrete, getId, indent, output) {
    var cType, cannotBeNothing;
    tree.selfName = "self" + getId();
    cType = asConstructed(tree);
    cannotBeNothing = isConcrete ? fullyInlined(cType) : cType;
    if (containsBase(cannotBeNothing, Nothing)) {
      throw new Error("Error: Attempt to initialize an object with a base type of Nothing on line " + tree.line + " character " + tree.column);
    }
    if (isConcrete) {
      output.push("(");
    }
    output.push("function(" + tree.selfName + ") {\n");
    genBaseCalls(cType, tree, getId, indent, output);
    output.push(tabs(indent + 1));
    output.push("return " + tree.selfName + ";\n");
    output.push(tabs(indent));
    output.push("}");
    if (isConcrete) {
      return output.push(")({})");
    }
  };

  genTypeInitializer = function(fresh, name, typTree, getId, indent, output) {
    if (!containsBase(fullyInlined(typTree), Nothing)) {
      output.push(tabs(indent));
      output.push("if(!" + fresh.selfName + "." + name + ")\n");
      output.push(tabs(indent + 1));
      output.push(fresh.selfName + "." + name);
      output.push(" = ");
      genCtor(typTree, false, getId, indent + 1, output);
      return output.push(";\n");
    }
  };

  gen = function(tree, getId, indent, output) {
    if (tree.type === "id") {
      output.push(definingTree(tree).selfName);
      output.push(".");
      return output.push(tree.match);
    } else if (tree.type === "TERM-SELECT") {
      gen(tree.prefix, getId, indent, output);
      output.push(".");
      return output.push(tree.id);
    } else if (tree.type === "CONSTRUCT") {
      return genCtor(tree.typTree, true, getId, indent, output);
    } else {
      throw new Error("Internal compiler error: Expected term tree in gen function, got " + tree.type + " tree");
    }
  };


  /* PRINTING */

  stringify = function(t, indent) {
    var prefix;
    if (indent == null) {
      indent = 0;
    }
    if (t.type === "id" || t.type === "ID") {
      prefix = t.definingTree ? t.definingTree.selfName ? t.definingTree.selfName + "." : "<<unnamed>>." : t.enclosing ? "<<" + t.enclosing.selfName + " or enclosing>>." : "";
      return "" + prefix + t.match;
    } else if (t.type === "TERM-SELECT") {
      return (stringify(t.prefix, indent)) + "." + t.id;
    } else if (t.type === "TYPE-SELECT") {
      return (stringify(t.prefix, indent)) + "." + t.ID;
    } else if (t.type === "CONSTRUCT") {
      return stringify(t.typTree, indent) + ".new";
    } else if (t.type === "TERM-DECL") {
      return (stringify(t.lhs, indent)) + " : " + (stringify(t.rhs, indent));
    } else if (t.type === "TYPE-DECL") {
      return (stringify(t.lhs, indent)) + " : at least " + (stringify(t.rhsLower, indent)) + " at most " + (stringify(t.rhsUpper, indent));
    } else if (t.type === "STATEMENTS") {
      return stringifyStatements(t, indent);
    } else if (t.stringify) {
      return t.stringify(indent);
    } else {
      return "<< " + t.type + " tree >>";
    }
  };

  stringifyStatements = function(stmts, indent) {
    var stmt;
    return "{\n" + ((function() {
      var j, len, ref, results;
      ref = stmts.statements;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        stmt = ref[j];
        results.push(tabs(indent + 1) + stringify(stmt, indent + 1) + "\n");
      }
      return results;
    })()).join("") + tabs(indent) + "}";
  };

  tabs = function(indent) {
    return "\t".repeat(indent);
  };


  /* PARSER */

  Token = function(tokType, text, line, column) {
    var tk;
    tk = {
      type: tokType,
      match: text,
      line: line,
      column: column,
      isToken: true
    };
    tk.stringify = function() {
      return tk.match.replace('\n', '\\n');
    };
    tk.print = function() {
      return tk.type + ", \"" + (tk.match.replace('\n', '\\n')) + "\", line " + tk.line + ", character " + tk.column;
    };
    return tk;
  };

  TypeDecl = function(lhs, rhsLower, rhsUpper) {
    var t;
    t = {
      type: "TYPE-DECL",
      alttypes: ["STATEMENT"],
      lhs: lhs,
      rhsLower: rhsLower,
      rhsUpper: rhsUpper,
      line: lhs.line,
      column: lhs.column
    };
    t.stringify = function(indent) {
      return t.lhs.stringify(indent) + ": at most " + t.rhsUpper.stringify(indent) + " at least " + t.rhsLower.stringify(indent);
    };
    t.subtrees = function() {
      return [t.lhs, t.rhsLower, t.rhsUpper];
    };
    return t;
  };

  TermDecl = function(lhs, rhs) {
    var t;
    t = {
      type: "TERM-DECL",
      alttypes: ["STATEMENT"],
      lhs: lhs,
      rhs: rhs,
      line: lhs.line,
      column: lhs.column
    };
    if (t.lhs.isVal) {
      WithAnnotation(t, "@final");
    }
    t.stringify = function(indent) {
      return t.lhs.stringify(indent) + ": " + t.rhs.stringify(indent);
    };
    t.subtrees = function() {
      return [t.lhs, t.rhs];
    };
    return t;
  };

  WithAnnotation = function(t, annot) {
    if (t.annots) {
      return t.annots.push(annot);
    } else {
      return t.annots = [annot];
    }
  };

  HasAnnotation = function(t, annot) {
    return t.annots && (indexOf.call(t.annots, annot) >= 0);
  };

  WithGuard = function(guard, statement) {
    var prevStringify, prevSubtrees;
    statement.guard = guard;
    prevStringify = statement.stringify;
    statement.stringify = function(indent) {
      return guard.stringify(indent) + prevStringify(indent);
    };
    prevSubtrees = statement.subtrees;
    statement.subtrees = function() {
      return [statement.guard].concat(prevSubtrees());
    };
    return statement;
  };

  parse = function(tokens) {
    var begin, expected, fromTopOfStack, i, matches, reduce, shift, showTypes, stack, stack_contents, t, unreducedTokenCount;
    stack = [];
    unreducedTokenCount = function() {
      var i, j, ref;
      for (i = j = 1, ref = stack.length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        if (!stack[stack.length - i].isToken) {
          return i - 1;
        }
      }
      return stack.length;
    };
    matches = function(types, skip) {
      var elem, i, j, ref, ref1;
      if (skip == null) {
        skip = 0;
      }
      if (types.length <= stack.length - skip) {
        for (i = j = 0, ref = types.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          if (types[i] !== "*") {
            elem = stack[stack.length - types.length + i - skip];
            if (elem.type !== types[i] && !(elem.alttypes && (ref1 = types[i], indexOf.call(elem.alttypes, ref1) >= 0))) {
              return false;
            }
          }
        }
        return true;
      } else {
        return false;
      }
    };
    fromTopOfStack = function(i) {
      if (i == null) {
        i = 0;
      }
      if (i > stack.length - 1) {
        return void 0;
      } else {
        return stack[stack.length - 1 - i];
      }
    };
    shift = function() {
      var t;
      t = tokens.shift();
      if (t.type === "id") {
        t.alttypes = ["TERM"];
      }
      if (t.type === "ID") {
        t.alttypes = ["TYPE"];
      }
      return stack.push(t);
    };
    expected = function(description) {
      var t, value;
      if (stack.length > 0) {
        t = stack[stack.length - 1];
        value = t.isToken ? t.match.replace('\n', '\\n') : t.stringify(0);
        throw "Parse error on line " + t.line + " character " + t.column + " : Expected " + description + "; got " + t.type + " with value \"" + value + "\"";
      } else {
        throw "Parse error with empty stack: Expected " + description;
      }
    };
    reduce = function() {

      /* Handle Comments */
      var ID, _typTree, a, b, c, condition, construct, guard, id, lhs, lparen, nl, nw, prefix, prevStringify, prevSubtrees, rhs, rhsLower, rhsUpper, statement, stmt, stmts, t, term;
      if (matches(["COMMENT"])) {
        stack.pop();
        return true;
      }
      if (matches(["START-BLOCK-COMMENT", "END-BLOCK-COMMENT"])) {
        stack.pop();
        stack.pop();
        return true;
      }
      if (matches(["START-BLOCK-COMMENT", "START-BLOCK-COMMENT"])) {
        return false;
      }
      if (matches(["START-BLOCK-COMMENT", "*"])) {
        stack.pop();
        return true;
      }

      /* Recognize ids that are really keywords */
      if (matches(["id"])) {
        if (fromTopOfStack(0).match === "new") {
          fromTopOfStack(0).type = "NEW";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "var") {
          fromTopOfStack(0).type = "VAR";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "val") {
          fromTopOfStack(0).type = "VAL";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "type") {
          fromTopOfStack(0).type = "TYPE-KEYWORD";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "if") {
          fromTopOfStack(0).type = "IF";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "then") {
          fromTopOfStack(0).type = "THEN";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "outer") {
          fromTopOfStack(0).type = "OUTER";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
      }
      if (matches(["id", "id"])) {
        a = fromTopOfStack(1);
        b = fromTopOfStack(0);
        if (a.match === "at" && b.match === "least") {
          stack.pop();
          a.type = "ATLEAST";
          a.match = a.match + " " + b.match;
          a.alttypes = void 0;
          return true;
        }
        if (a.match === "at" && b.match === "most") {
          stack.pop();
          a.type = "ATMOST";
          a.match = a.match + " " + b.match;
          a.alttypes = void 0;
          return true;
        }
      }

      /* Selections */
      if (matches(["IF", "TERM", "THEN"])) {
        stack.pop();
        condition = stack.pop();
        stack.pop();
        guard = {
          type: "GUARD",
          condition: condition,
          line: condition.line,
          column: condition.column
        };
        guard.stringify = function(indent) {
          return "if " + (guard.condition.stringify(indent)) + " then ";
        };
        guard.subtrees = function() {
          return [guard.condition];
        };
        stack.push(guard);
        return true;
      }
      if (matches(["GUARD", "STATEMENT"])) {
        statement = stack.pop();
        guard = stack.pop();
        stack.push(WithGuard(guard, statement));
        return true;
      }
      if (matches(["GUARD", "*", "NEWLINE"])) {
        nl = stack.pop();
        term = stack.pop();
        guard = stack.pop();
        stack.push(WithGuard(guard, term));
        stack.push(nl);
        return true;
      }
      if (matches(["TERM", "DOT", "id"])) {
        id = stack.pop();
        stack.pop();
        prefix = stack.pop();
        t = {
          type: "TERM-SELECT",
          alttypes: ["TERM"],
          prefix: prefix,
          id: id.match,
          line: id.line,
          column: id.column
        };
        t.stringify = function(indent) {
          return t.prefix.stringify(indent) + ("." + t.id);
        };
        t.subtrees = function() {
          return [t.prefix];
        };
        stack.push(t);
        return true;
      }
      if (matches(["TERM", "DOT", "ID"])) {
        ID = stack.pop();
        stack.pop();
        prefix = stack.pop();
        t = {
          type: "TYPE-SELECT",
          alttypes: ["TYPE"],
          prefix: prefix,
          ID: ID.match,
          line: ID.line,
          column: ID.column
        };
        t.stringify = function(indent) {
          return t.prefix.stringify(indent) + ("." + t.ID);
        };
        t.subtrees = function() {
          return [t.prefix];
        };
        stack.push(t);
        return true;
      }
      if (matches(["VAR", "id", "COLON"])) {
        c = stack.pop();
        id = stack.pop();
        stack.pop();
        id.isVar = true;
        stack.push(id);
        stack.push(c);
        return true;
      }
      if (matches(["VAL", "id", "COLON"])) {
        c = stack.pop();
        id = stack.pop();
        stack.pop();
        id.isVal = true;
        stack.push(id);
        stack.push(c);
        return true;
      }
      if (matches(["TYPE-KEYWORD", "ID", "COLON"])) {
        c = stack.pop();
        ID = stack.pop();
        stack.pop();
        stack.push(ID);
        stack.push(c);
        return true;
      }
      if (matches(["ID", "COLON", "*", "*", "*", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["ATMOST", "TYPE", "ATLEAST", "TYPE"])) {
          rhsLower = stack.pop();
          stack.pop();
          rhsUpper = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        } else if (matches(["ATLEAST", "TYPE", "ATMOST", "TYPE"])) {
          rhsUpper = stack.pop();
          stack.pop();
          rhsLower = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        }
      }
      if (matches(["ID", "COLON", "*", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["ATMOST", "TYPE"])) {
          rhsUpper = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          rhsLower = Token("ID", "Nothing", rhsUpper.line, rhsUpper.column);
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        } else if (matches(["ATLEAST", "TYPE"])) {
          rhsLower = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          rhsUpper = Token("ID", "Any", rhsLower.line, rhsLower.column);
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        }
      }
      if (matches(["ID", "COLON", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhs, rhs));
          return true;
        } else {
          expected("TYPE in declaration of " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["id", "COLON", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TermDecl(lhs, rhs));
          return true;
        } else {
          expected("TYPE in declaration of " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["ID", "EQUALS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TYPE-ASSIGN",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhs: rhs,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + " = " + t.rhs.stringify(indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhs];
          };
          stack.push(t);
          return true;
        } else {
          expected("TYPE in assignment to " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["id", "EQUALS", "*", "NEWLINE"]) || matches(["TERM-SELECT", "EQUALS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TERM"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TERM-ASSIGN",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhs: rhs,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + " = " + t.rhs.stringify(indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhs];
          };
          stack.push(t);
          return true;
        } else {
          expected("TERM in assignment to " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["TYPE", "AND", "TYPE"])) {
        rhs = stack.pop();
        stack.pop();
        lhs = stack.pop();
        t = {
          type: "AND-TYPE",
          alttypes: ["TYPE"],
          lhs: lhs,
          rhs: rhs,
          line: lhs.line,
          column: lhs.column
        };
        t.stringify = function(indent) {
          return t.lhs.stringify(indent) + " & " + t.rhs.stringify(indent);
        };
        t.subtrees = function() {
          return [t.lhs, t.rhs];
        };
        stack.push(t);
        return true;
      }
      if (matches(["TYPE", "OR", "TYPE"])) {
        rhs = stack.pop();
        stack.pop();
        lhs = stack.pop();
        t = {
          type: "OR-TYPE",
          alttypes: ["TYPE"],
          lhs: lhs,
          rhs: rhs,
          line: lhs.line,
          column: lhs.column
        };
        t.stringify = function(indent) {
          return t.lhs.stringify(indent) + " | " + t.rhs.stringify(indent);
        };
        t.subtrees = function() {
          return [t.lhs, t.rhs];
        };
        stack.push(t);
        return true;
      }
      if (matches(["AT", "id", "TYPE"])) {
        t = stack.pop();
        id = stack.pop();
        stack.pop();
        WithAnnotation(t, id);
        prevStringify = t.stringify;
        prevSubtrees = t.subtrees;
        t.stringify = function(indent) {
          return "@" + t.id.match + " " + prevStringify(indent);
        };
        t.subtrees = function() {
          return prevSubtrees().concat([t.typ]);
        };
        stack.push(t);
        return true;
      }
      if (matches(["STATEMENTS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TERM"])) {
          stmt = stack.pop();
          stmts = stack.pop();
          stmts.statements.push(stmt);
          stmts.line = stmt.line;
          stmts.column = stmt.column;
          stack.push(stmts);
          return true;
        } else {
          expected("STATEMENT");
        }
      }
      if (matches(["STATEMENTS", "STATEMENT"])) {
        stmt = stack.pop();
        stmts = stack.pop();
        stmts.statements.push(stmt);
        stmts.line = stmt.line;
        stmts.column = stmt.column;
        stack.push(stmts);
        return true;
      }
      if (matches(["LBRACE"])) {
        lparen = fromTopOfStack();
        begin(lparen.line, lparen.column);
        return true;
      }
      if (matches(["LBRACE", "STATEMENTS", "RBRACE"])) {
        stack.pop();
        stmts = stack.pop();
        stack.pop();
        stack.push(stmts);
        return true;
      }
      if (matches(["*", "DOT", "NEW"])) {
        nw = stack.pop();
        stack.pop();
        if (matches(["TYPE"])) {
          _typTree = stack.pop();
          construct = {
            type: "CONSTRUCT",
            alttypes: ["TERM"],
            typTree: _typTree,
            line: nw.line,
            column: nw.column
          };
          construct.stringify = function(indent) {
            return (construct.typTree.stringify(indent)) + ".new";
          };
          construct.subtrees = function() {
            return [construct.typTree];
          };
          stack.push(construct);
          return true;
        } else {
          throw new Error("Expected type in object construction on line " + nw.line + " character " + nw.column + ", got " + (fromTopOfStack(0).stringify(0)));
        }
      }
      if (matches(["STATEMENTS", "NEWLINE"])) {
        stack.pop();
        return true;
      }
    };
    begin = function(ln, col) {
      var stmts;
      stmts = {
        type: "STATEMENTS",
        alttypes: ["TYPE"],
        statements: [],
        line: ln,
        column: col
      };
      stmts.stringify = function(indent) {
        return stringifyStatements(stmts, indent);
      };
      stmts.subtrees = function() {
        return stmts.statements;
      };
      stmts.print = stmts.stringify;
      return stack.push(stmts);
    };
    showTypes = function(t) {
      var s, typ;
      s = t.type;
      if (t.alttypes) {
        s = s + " & " + ((function() {
          var j, len, ref, results;
          ref = t.alttypes;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            typ = ref[j];
            results.push(typ);
          }
          return results;
        })()).join(" & ");
      }
      return s;
    };
    begin(1, 1);
    while (true) {
      while (reduce()) {
        true;
      }
      if (tokens[0].type === "EOF" || unreducedTokenCount() >= 8) {
        break;
      }
      shift();
    }
    if (stack.length !== 1) {
      i = -1;
      stack_contents = ((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = stack.length; j < len; j++) {
          t = stack[j];
          i += 1;
          results.push("Item " + i + ": " + (showTypes(t)) + "\n" + (t.stringify(0)));
        }
        return results;
      })()).join("\n\n");
      throw "Parse error: Unreduced items on stack at End-of-Input. Stack contents:\n\n" + stack_contents;
    }
    return stack[0];
  };

  tokenize = function(input) {
    var Whitespace, column, consumeNextToken, getNextToken, line, t, tk, tokenList, tokens;
    line = 1;
    column = 1;
    tokenList = [
      {
        name: "id",
        regex: /^([a-z][a-zA-z0-9_]*|\?\?\?)/
      }, {
        name: "ID",
        regex: /^[A-Z][a-zA-z0-9_]*/
      }, {
        name: "NEWLINE",
        regex: /^(\n|\r\n|\r)/
      }, {
        name: "COMMENT",
        regex: /^\/\/.*/
      }, {
        name: "START-BLOCK-COMMENT",
        regex: /^\/\*/
      }, {
        name: "END-BLOCK-COMMENT",
        regex: /^\*\//
      }, {
        name: "DOT",
        regex: /^\./
      }, {
        name: "AND",
        regex: /^&/
      }, {
        name: "OR",
        regex: /^\|/
      }, {
        name: "AT",
        regex: /^@/
      }, {
        name: "EQUALS",
        regex: /^=/
      }, {
        name: "LPAREN",
        regex: /^\(/
      }, {
        name: "RPAREN",
        regex: /^\)/
      }, {
        name: "LBRACE",
        regex: /^{/
      }, {
        name: "RBRACE",
        regex: /^}/
      }, {
        name: "COLON",
        regex: /^:/
      }, {
        name: "SEMI",
        regex: /^;/
      }, {
        name: "EOF",
        regex: /^$/
      }
    ];
    Whitespace = {
      name: "SPACE",
      regex: /^[\t \v\f]+/
    };
    getNextToken = function() {
      var j, len, length, matches, tok;
      matches = Whitespace.regex.exec(input);
      if (matches) {
        input = input.substring(matches[0].length);
        column += matches[0].length;
      }
      for (j = 0, len = tokenList.length; j < len; j++) {
        tok = tokenList[j];
        matches = tok.regex.exec(input);
        if (matches) {
          return Token(tok.name, matches[0], line, column);
        }
      }
      length = input.indexOf('\n');
      if (length <= 0) {
        length = input.length;
      }
      throw "Tokenization error on line " + line + " character " + column + " : Unable to match a token starting at '" + (input.substring(0, length)) + "'";
    };
    consumeNextToken = function() {
      var tok;
      tok = getNextToken();
      input = input.substring(tok.match.length);
      column += tok.match.length;
      if (tok.type === "NEWLINE") {
        column = 1;
        line += 1;
      }
      return tok;
    };
    tokens = [];
    while (true) {
      t = consumeNextToken();
      if (t.type === "RBRACE" || t.type === "EOF") {
        tk = Token("NEWLINE", "\n", t.line, t.column);
        tk.stringify = function() {
          return "(synthetic \\n)";
        };
        tk.print = function() {
          return "synthetic NEWLINE on line " + t.line + ", char " + t.column;
        };
        tokens.push(tk);
      }
      tokens.push(t);
      if (t.type === "EOF") {
        break;
      }
    }
    return tokens;
  };

}).call(this);
