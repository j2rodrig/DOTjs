// Generated by CoffeeScript 1.10.0
(function() {
  var AddSymbolFromNamedType, AddSymbolFromTree, AndType, Any, CreateGlobalContext, Name, NameLookup, NameSelect, Nothing, OrType, Statement, Token, TypeBounds, contextify, demandSubType, gen, isSubType, lookupSymbolInContext, lowerBoundStatements, members, parse, printTyp, stringifyMembershipSet, strtyp, tabs, tokenize, typTree,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.compile = function(input, stopAfter) {
    var ast, debugOutput, error, error1, tok, tokens;
    try {
      tokens = tokenize(input);
      if (stopAfter === "tokens") {
        return ((function() {
          var j, len, results;
          results = [];
          for (j = 0, len = tokens.length; j < len; j++) {
            tok = tokens[j];
            results.push(tok.print());
          }
          return results;
        })()).join('\n');
      }
      ast = parse(tokens);
      if (stopAfter === "trees") {
        return ast.print(0);
      }
      debugOutput = contextify(CreateGlobalContext(), ast);
      if (stopAfter === "symbols") {
        return debugOutput;
      }
      return gen(ast);
    } catch (error1) {
      error = error1;
      if (error.stack) {
        return error.stack;
      } else {
        return error;
      }
    }
  };


  /*
  
  NOTES
  
  Compilers are Databases
  
  	Should I structure this compiler like Odersky's core ER (Entity Relationship) diagram?
  	Yes, that seems like a good idea.
  
  	Should I literally build tables of entities here?
  	No. But something more flexible than what Martin did is a good idea.
  
  	Is the flexibility issue I'm seeing an interface problem?
  	Yes.
  
  	How do I do infterfaces better?
  	Just think - ...
  
  What's a Type?
  
  	A type is what we know (or assume) about something.
  
  	A type may be associated with a tree (but it doesn't have to be).
  	A type may be associated with a symbol (but it doesn't have to be).
  
  	So what does a type do?
  
  	What do we want to do with a type?
  
  	We want to make sure that for every term selection p.x, p contains x.
  	We want to make sure that for every type selection p.T, p contains T.
  	We want to make sure that for every term assignment a = b, b is substitutable for a.
  	We want to make sure that for every term assignment a = b, a is assignable.
  	(Assignability is [among other things] related to variance and privacy: a field is not writable/assignable if its type is covariant and non-private [which is notably the case for all fields in DOT].)
  	We want to make sure that for every instance creation T.new, all needed members of T are known.
  	For every declaration block '{ stmts }', we want to know what declarations it contains.
  	The type of a statement block must be related to: 1. The declarations in that block (which may be inferred), and 2. the sequence of assignments in that block (term and type assignments).
  
  	What about subtyping?
  	'{ stmts1 }' <: '{ stmts2 }' if for every declaration in stmts2 there is a compatible declaration in stmts1. That is, for all D2 in stmts2, there exists a D1 in stmts1 s.t. D1 <: D2. This interpretation of statement-block subtyping is compatible with the idea that the type of a statement block is the intersection of all declarations in that block.
  
  
  	Declaration subsumption
  	We only have 2 kinds of declarations.
  	Type declarations have the form 'ID : A .. B' where A and B are types.
  	Term declarations have the form 'id : T' where T is a type.
  
  	'id1:T1' <: 'id2:T2' if T1 == T2. (May be relaxed if T1 or T2 is covariant or contravariant.)
  
  	'ID1:A1..B1 <: ID2:A2..B2' if A2 <: A1 and B1 <: B2.
  
  
  	Inheritance of Field Types
  	Despite DOT, it seems like field types should be invariant under inheritance, unless stated otherwise.
  	What does this mean for subtyping?
  
  	Scala has separate notions of a getter and setter.
  	Say, for example, A <: B. And:
  		trait D { var f: A }
  		trait E extends D { var f: B = ??? }
  	If we try
  		new E{}
  	Scala won't take it because the setter for f:A has not been defined.
  	The getter for f:A is overridden by f:B, so that part's OK.
  
  	Maybe we need to find out how getters and setters work in DOTjs:
  	{
  		f: A
  		GetF = {
  			out value: A
  			value = f
  		}
  		SetF = {
  			in value: A
  			f = value
  		}
  	}
  	Calling:
  	{
  		fOut = GetF.new.value
  		SetF{ value = fIn }.new
  	}
  	Mixing in:
  	{
  		f: B
  		GetF = {  // presence of public getter constrains f's type <: A&B
  			out value: B  // "out" means there's no way to assign outside of this object*
  			value = f
  		}
  		SetF = {  // presence of public setter constrains A|B <: f's type
  			in value: B   // "in" means there's no way to read outside of this object**
  			f = value
  		}
  	}
  	* Assignments to the value can occur within the statement block where the value is declared.
  	  Field f can be arbitrarily assigned within the block because mixin composition occurs
  	  over such assignments, and they can be type-checked at the time of object instantiation.
  	** Reads of the value can occur within the statement block where the value is declared.
  	  Like assignments, reads of values within the statement block are type-checked at the
  	  point of object creation. Access to the final type of the field allows this.
  
  
  	Mixins, declarations, and assignments
  
  	Declarations are order-agnostic. Regardless of mixin ordering, all declarations must be satisfied.
  	Satisfaction of declarations means:
  		For every declared type T, the upper bound must be no less than the lower bound.
  		All assignments to T must be within those bounds.
  		For every publically-readable field fo declared with type FO, FO serves as an upper bound
  		of the actual type of fo. For every publically-writable field fi with type FI, FI serves
  		as a lower bound of the actual type of fi.
  
  	Assignments are order-dependent.
  
  	Type assignments must be evaluated at compile time.
  	Term assignments may be evaluated at runtime.
  
  	A type assignment remains in effect only until the type is re-assigned
  	(a type assignment is a temporary narrowing of type bounds).
  
  	Here's the key:
  	Declarations participate in the static type of an object, but assignments do not.
  	(Although it is possible to infer certain declarations given a set of assignments.)
  
  	Example of type assignment:
  	J = {
  		L = Int
  		f: L
  		f = 3
  		L = String  // changes the type of L for subsequent statements
  		g: L
  		g = "Hi!"
  	}
  	j = J.new
  	l: j.L   // j.L is a string here, since that was the last assignment to L in j
  	l = "Hi again!"
  
  	Key note: (
  		All term members start as undefined, all type members as Undefined.
  		When are errors generated on use of undefined or Undefined?
  	)
  
  	Path-dependent subtyping rules allow j.L to be equal to j.L,
  	but another path k.L is not necessarily equal to j.L.
  
  (Triple venti vanilla frappucino)
   */


  /*
  APPROACH TO TYPE CHECKING
  
  A function to get the bounds on a tree's type. (What's the result here?)
  
  A function to get the declarations on a tree's type. There are lower- and upper-bound versions.
  
  A function to get the assignments on a tree's type. Ther result is always a constructible lower bound.
  
  
  HOW TO TYPECHECK: A & { x = y } . new
  
  Register a new context for A & { x = y }    # reflects creation of new object
  Linearize statements in A & { x = y }
  Resolve and check explicit declarations in A & { x = y }
  	(the declarations in A are thereby entered into the newly-created current context.)
  Generate type aliases from type assignments (and check that they are within declared bounds).
  Infer field types (term declarations) from term assignments (where needed).
  
  Specific to { x = y }:
  	Check that y.type <: x.widen.
  	Which involves:
  		Look up y in the context where y is used (in this case, the newly-created current context)
  		Look up x in the context where x is used (in this case, the newly-created current context)
  Generalization:
  	Check that term assignments have compatible types.
  	The type of a path p is simply p itself.
  	If necessary, p is widened to its declared type.
  
  Path-dependence and A:
  	( assume A is { y: Y;  y = a } )
  	Lookup of y from { x = y } produces type Y, which may be in A's outer context.
  	( assume { Y: at least L at most U ; A = { y: Y;  y = a } } )
  	The type of p.y in "p = A & { x = y } . new" is: p.Y
  		because Y is invariant with respect to a particular object reference p.
  	So Y without a prefix is always equal to Y without a prefix, and p.Y === p.Y.
  		But: Y != p.Y and p.Y != q.Y  ---> path-dependence.
  		(unless Y is aliased to another type which does compare.)
  
  Code Generation
  
  Given A & { x = y } . new  where A is  { y: Y;  y = a }  :
  
  Generation for A:
  	function A(obj_A) {
  		var r = {};
  		r.y = a;
  		return r;
  	}
  Generation for A & { x = y } . new:
  	(function() {
  		var r = {};
  
  		return r;
  	})();
  
  ???
   */

  gen = function(tree) {
    var j, len, lhsTyp, ref, rhsTyp, s, st, typ;
    if (tree.type === "CONSTRUCT") {
      return gen(tree.typTree);
    } else if (tree.type === "STATEMENTS") {
      s = [];
      ref = lowerBoundStatements(typTree(tree));
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        s.push(gen(st.tree));
      }
      return s.join("\n");
    } else if (tree.type === "TERM-ASSIGN") {
      lhsTyp = typTree(tree.lhs);
      rhsTyp = typTree(tree.rhs);
      demandSubType(rhsTyp, lhsTyp);
      return gen(tree.lhs) + " = " + gen(tree.rhs);
    } else if (tree.type === "TYPE-ASSIGN") {
      return "/* " + tree.lhs + " = " + (printTyp(typTree(tree.rhs), 0)) + " */";
    } else {
      typ = typTree(tree);
      if (tree.type === "id") {
        return tree.match;
      } else if (tree.type === "TERM-SELECT") {
        return gen(tree.prefix) + "." + tree.id;
      } else {
        throw "Internal compiler error: Request for unimplemented code generation for " + tree.type + " tree on line " + tree.line + " character " + tree.column;
      }
    }
  };

  demandSubType = function(a, b) {
    if (!isSubType(a, b)) {
      throw ("Type Error : Expected " + (printTyp(b, 1)) + "\n") + (" Got " + (printTyp(a, 1)) + "\n") + ("on line " + b.tree.line + " character " + b.tree.column);
    }
  };

  isSubType = function(a, b) {
    if (a === Nothing || b === Any) {
      return true;
    }
    if (b === Nothing || a === Any) {
      return false;
    }
    if (a === b) {
      return true;
    }
    return true;
  };

  Name = function(name, info, tree) {
    return {
      typtyp: "NAME",
      name: name,
      info: info,
      tree: tree
    };
  };

  Statement = function(tree) {
    return {
      typtyp: "STATEMENT",
      tree: tree
    };
  };

  TypeBounds = function(lowerInfo, upperInfo, tree) {
    return {
      typtyp: "BOUNDS",
      lowerInfo: lowerInfo,
      upperInfo: upperInfo,
      tree: tree,
      members: function() {
        return members(upperInfo());
      }
    };
  };

  NameSelect = function(name, prefixInfo, tree) {
    var typ;
    typ = {
      typtyp: "NAME-SELECT",
      name: name,
      prefixInfo: prefixInfo,
      tree: tree
    };
    typ.info = function() {
      var infoTree, prefixMembers;
      prefixMembers = members(typ.prefixInfo());
      if (!prefixMembers[typ.name]) {
        throw "Error : Member named '" + typ.name + "' was not found at line " + typ.tree.line + " character " + typ.tree.column;
      }
      infoTree = prefixMembers[typ.name];
      return typTree(infoTree);
    };
    return typ;
  };

  NameLookup = function(name, tree) {
    var typ;
    typ = {
      typtyp: "NAME-LOOKUP",
      name: name,
      tree: tree
    };
    typ.info = function() {
      var symInfoTree;
      symInfoTree = typ.tree.context.lookupSymbol(typ.name, typ.tree.line, typ.tree.column).rhs;
      return typTree(symInfoTree);
    };
    return typ;
  };

  AndType = function(components, tree) {
    var typ;
    typ = {
      typtyp: "AND-TYPE",
      components: components,
      tree: tree
    };
    typ.members = function() {
      var _members, c, j, len, ref;
      if (typ._members) {
        return typ._members;
      }
      _members = {};
      ref = typ.components;
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        if (c.typtyp === "NAME") {
          _members[c.name] = c.info;
        }
      }
      typ._members = _members;
      return typ._members;
    };
    return typ;
  };

  OrType = function(components, tree) {
    var typ;
    typ = {
      typtyp: "OR-TYPE",
      components: components,
      tree: tree
    };
    typ.members = function() {
      throw "Unimplemented: request for membership of OR-TYPE";
    };
    return typ;
  };

  printTyp = function(typ, indent) {
    var st;
    if (indent == null) {
      indent = 0;
    }
    if (typ.typtyp === "AND-TYPE") {
      return "{\n" + ((function() {
        var j, len, ref, results;
        ref = typ.components;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          st = ref[j];
          results.push(tabs(indent + 1) + printTyp(st, indent + 1) + "\n");
        }
        return results;
      })()).join("") + tabs(indent) + "}";
    } else if (typ.typtyp === "NAME") {
      return typ.name + ": " + printTyp(typ.info(), indent);
    } else if (typ.typtyp === "STATEMENT") {
      return "(stmt) " + typ.tree.stringify(indent);
    } else if (typ.typtyp === "NAME-SELECT") {
      return printTyp(typ.prefixInfo(), indent) + "." + typ.name;
    } else if (typ.typtyp === "NAME-LOOKUP") {
      return typ.name;
    } else if (typ.typtyp === "BOUNDS") {
      return "at least " + printTyp(typ.lowerInfo(), indent) + " at most " + printTyp(typ.upperInfo(), indent);
    } else {
      return "(unimplemented printTyp for '" + typ.typtyp + "' type')";
    }
  };

  members = function(typ) {
    if (typ.members) {
      return typ.members();
    }
    if (typ._members) {
      return typ._members;
    }
    typ._members = (function() {
      if (typ.typtyp.info) {
        return members(typ.info());
      } else {
        throw "Internal compiler error : Request for membership of type '" + typ + "' is unimplemented. Line " + typ.tree.line + " character " + typ.tree.column;
      }
    })();
    return typ._members;
  };

  lowerBoundStatements = function(typIn) {
    var _lowerBoundStatements, alreadyLinearized, linearized;
    linearized = [];
    alreadyLinearized = [];
    _lowerBoundStatements = function(typ) {
      var c, j, len, ref, results;
      if (indexOf.call(alreadyLinearized, typ) >= 0) {
        return;
      }
      alreadyLinearized.push(typ);
      if (typ.typtyp === "AND-TYPE") {
        ref = typ.components;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          if (c.typtyp === "NAME") {
            results.push(true);
          } else if (c.typtyp === "STATEMENT") {
            results.push(linearized.push(c));
          } else {
            results.push(_lowerBoundStatements(c));
          }
        }
        return results;
      } else {
        throw "Internal Compiler Error: Requested lower-bound linearization of " + typ.typtyp + " type is not implemented. Line " + typ.tree.line + " character " + typ.tree.column;
      }
    };
    _lowerBoundStatements(typIn);
    return linearized;
  };

  typTree = function(tree) {
    var components, fn, j, len, ref, ref1, st, typ;
    if (tree.typ) {
      return tree.typ;
    }
    typ = void 0;
    if (tree.type === "STATEMENTS") {
      components = [];
      ref = tree.statements;
      fn = function(st) {
        var lowerInfo, upperInfo;
        if (st.type === "TYPE-DECL") {
          lowerInfo = function() {
            return typTree(st.rhsLower);
          };
          upperInfo = function() {
            return typTree(st.rhsUpper);
          };
          return components.push(Name(st.lhs.match, (function() {
            return TypeBounds(lowerInfo, upperInfo);
          }), st));
        } else if (st.type === "TERM-DECL") {
          return components.push(Name(st.lhs.match, (function() {
            return typTree(st.rhs);
          }), st));
        } else {
          return components.push(Statement(st));
        }
      };
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        fn(st);
      }
      typ = AndType(components, tree);
    } else if (tree.type === "TYPE-SELECT") {
      typ = NameSelect(tree.ID, (function() {
        return typTree(tree.prefix);
      }), tree);
    } else if (tree.type === "TERM-SELECT") {
      typ = NameSelect(tree.id, (function() {
        return typTree(tree.prefix);
      }), tree);
    } else if ((ref1 = tree.type) === "ID" || ref1 === "id") {
      typ = NameLookup(tree.match, tree);
    } else if (tree.type === "AND-TYPE") {
      typ = AndType([typTree(tree.lhs), typTree(tree.rhs)], tree.rhs);
    } else if (tree.type === "OR-TYPE") {
      typ = OrType([typTree(tree.lhs), typTree(tree.rhs)], tree.rhs);
    } else if (tree.type === "CONSTRUCT") {
      typ = typTree(tree.typTree);
    } else {
      throw "Internal compiler error : Request for type of " + tree.type + " tree is not implemented";
    }
    tree.typ = typ;
    return typ;
  };

  strtyp = function(tree, indent) {
    var j, len, m, mInfo, outp, output, ref;
    output = [];
    if (tree.lowerBoundMembership) {
      mInfo = [];
      ref = tree.lowerBoundMembership;
      for (j = 0, len = ref.length; j < len; j++) {
        m = ref[j];
        if (m.type === "TERM-DECL") {
          mInfo.push("" + m.lhs.match + (strtyp(m.rhs, indent + 1)));
        }
      }
      output.push((mInfo.length < 2 ? "{ " + mInfo.join("") + " }" : "{\n" + mInfo.join("\n") + "\n}"));
    }
    outp = output.join(" ");
    if (outp) {
      return " : " + outp + " ";
    } else {
      return "";
    }
  };


  /*
  What is a type anyway?
  It is (according to Odersky) just what you type (literally).
  Viewpoint adaptation needs to occur, due to path-dependent typing. ->
  	This means subtitutions need to occur, and types need to be clonable. (this is why types are not mere trees)
  (Membership is a separate issue.)
  (Type inference is a separate issue.)
   */


  /*
  We only type-check terms?
   */


  /*
  DOT types.
  
  See: Rompf and Amin. "From F to DOT: Type Soundness Proofs with Definitional Interpreters." Tech Report 2015.
   */

  Any = {
    typtyp: "AND-TYPE",
    components: []
  };

  Nothing = {
    typtyp: "NOTHING"
  };

  Token = function(tokType, text, line, column) {
    var tk;
    tk = {
      type: tokType,
      match: text,
      line: line,
      column: column,
      isToken: true
    };
    tk.stringify = function() {
      return tk.match.replace('\n', '\\n');
    };
    tk.print = function() {
      return tk.type + ", \"" + (tk.match.replace('\n', '\\n')) + "\", line " + tk.line + ", character " + tk.column;
    };
    return tk;
  };

  CreateGlobalContext = function() {
    var context;
    context = {
      symbols: {},
      outerContext: void 0
    };
    AddSymbolFromNamedType(context, "Any", Any);
    AddSymbolFromNamedType(context, "Nothing", Nothing);
    context.lookupSymbol = function(name, line, column) {
      return lookupSymbolInContext(context, name, line, column);
    };
    return context;
  };

  lookupSymbolInContext = function(context, symName, line, column) {
    if (symName in context.symbols) {
      return context.symbols[symName];
    } else if (context.outerContext) {
      return context.outerContext.lookupSymbol(symName, line, column);
    } else {
      throw "Symbol '" + symName + "' not found at line " + line + " character " + column;
    }
  };

  stringifyMembershipSet = function(mems, indent) {
    var id, out, summary;
    out = [];
    for (id in mems) {
      summary = mems[id];
      out.push(tabs(indent + 1) + id + " : " + summary.tree.stringify(indent + 1) + "\n");
    }
    return "{\n" + out.join("") + tabs(indent) + "}";
  };

  AddSymbolFromNamedType = function(context, name, typ) {
    var sym;
    sym = {
      name: name,
      typ: typ
    };
    context.symbols[name] = sym;
    return sym;
  };

  AddSymbolFromTree = function(context, name, defTree, line, column) {
    var sym;
    sym = {
      name: name,
      rhs: defTree,
      line: line,
      column: column
    };
    context.symbols[name] = sym;
    return sym;
  };

  contextify = function(outerContext, tree) {
    var j, k, len, len1, output, prevDef, ref, ref1, subtree, symName, t;
    output = [];
    tree.context = outerContext;
    if (tree.type === "STATEMENTS") {
      tree.context = {
        symbols: {},
        outerContext: outerContext,
        lookupSymbol: function(name, line, column) {
          return lookupSymbolInContext(tree.context, name, line, column);
        }
      };
      ref = tree.statements;
      for (j = 0, len = ref.length; j < len; j++) {
        t = ref[j];
        if (t.type === "TERM-DECL" || t.type === "TYPE-ASSIGN") {
          symName = t.lhs.match;
          prevDef = tree.context.symbols[symName];
          if (prevDef) {
            throw "Duplicate definition of " + symName + ": line " + prevDef.line + " and line " + t.line;
          }
          AddSymbolFromTree(tree.context, symName, t.rhs, t.line, t.column);
          output.push("(line " + t.line + " character " + t.column + ") " + symName + " : " + (t.rhs.stringify(0)));
        }
      }
    }
    if (tree.subtrees) {
      ref1 = tree.subtrees();
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        subtree = ref1[k];
        output = output.concat(contextify(tree.context, subtree));
      }
    } else if (!tree.isToken) {
      throw "Internal compiler error: Function \"subtrees\" not found during traveral of " + tree.type + " tree at line " + tree.line + " character " + tree.column + ". Value: " + tree.value;
    }
    return output.join("\n");
  };

  parse = function(tokens) {
    var begin, expected, fromTopOfStack, i, matches, reduce, shift, showTypes, stack, stack_contents, t, unreducedTokenCount;
    stack = [];
    unreducedTokenCount = function() {
      var i, j, ref;
      for (i = j = 1, ref = stack.length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        if (!stack[stack.length - i].isToken) {
          return i - 1;
        }
      }
      return stack.length;
    };
    matches = function(types, skip) {
      var elem, i, j, ref, ref1;
      if (skip == null) {
        skip = 0;
      }
      if (types.length <= stack.length - skip) {
        for (i = j = 0, ref = types.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          if (types[i] !== "*") {
            elem = stack[stack.length - types.length + i - skip];
            if (elem.type !== types[i] && !(elem.alttypes && (ref1 = types[i], indexOf.call(elem.alttypes, ref1) >= 0))) {
              return false;
            }
          }
        }
        return true;
      } else {
        return false;
      }
    };
    fromTopOfStack = function(i) {
      if (i == null) {
        i = 0;
      }
      if (i > stack.length - 1) {
        return void 0;
      } else {
        return stack[stack.length - 1 - i];
      }
    };
    shift = function() {
      var t;
      t = tokens.shift();
      if (t.type === "id") {
        t.alttypes = ["TERM"];
      }
      if (t.type === "ID") {
        t.alttypes = ["TYPE"];
      }
      return stack.push(t);
    };
    expected = function(description) {
      var t, value;
      if (stack.length > 0) {
        t = stack[stack.length - 1];
        value = t.isToken ? t.match.replace('\n', '\\n') : t.stringify(0);
        throw "Parse error on line " + t.line + " character " + t.column + " : Expected " + description + "; got " + t.type + " with value \"" + value + "\"";
      } else {
        throw "Parse error with empty stack: Expected " + description;
      }
    };
    reduce = function() {

      /* Handle Comments */
      var ID, TypeDecl, _typTree, a, b, construct, id, lhs, lparen, nw, prefix, rhs, rhsLower, rhsUpper, stmt, stmts, t;
      if (matches(["COMMENT"])) {
        stack.pop();
        return true;
      }
      if (matches(["START-BLOCK-COMMENT", "END-BLOCK-COMMENT"])) {
        stack.pop();
        stack.pop();
        return true;
      }
      if (matches(["START-BLOCK-COMMENT", "START-BLOCK-COMMENT"])) {
        return false;
      }
      if (matches(["START-BLOCK-COMMENT", "*"])) {
        stack.pop();
        return true;
      }

      /* Recognize ids that are really keywords */
      if (matches(["id"])) {
        if (fromTopOfStack(0).match === "new") {
          fromTopOfStack(0).type = "NEW";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
      }
      if (matches(["id", "id"])) {
        a = fromTopOfStack(1);
        b = fromTopOfStack(0);
        if (a.match === "at" && b.match === "least") {
          stack.pop();
          a.type = "ATLEAST";
          a.match = a.match + " " + b.match;
          a.alttypes = void 0;
          return true;
        }
        if (a.match === "at" && b.match === "most") {
          stack.pop();
          a.type = "ATMOST";
          a.match = a.match + " " + b.match;
          a.alttypes = void 0;
          return true;
        }
      }

      /* Selections */
      if (matches(["TERM", "DOT", "id"])) {
        id = stack.pop();
        stack.pop();
        prefix = stack.pop();
        t = {
          type: "TERM-SELECT",
          alttypes: ["TERM"],
          prefix: prefix,
          id: id.match,
          line: id.line,
          column: id.column
        };
        t.stringify = function(indent) {
          return t.prefix.stringify(indent) + ("." + t.id + (strtyp(t, indent)));
        };
        t.subtrees = function() {
          return [t.prefix];
        };
        stack.push(t);
        return true;
      }
      if (matches(["TERM", "DOT", "ID"])) {
        ID = stack.pop();
        stack.pop();
        prefix = stack.pop();
        t = {
          type: "TYPE-SELECT",
          alttypes: ["TYPE"],
          prefix: prefix,
          ID: ID.match,
          line: ID.line,
          column: ID.column
        };
        t.stringify = function(indent) {
          return t.prefix.stringify(indent) + ("." + t.ID + (strtyp(t, indent)));
        };
        t.subtrees = function() {
          return [t.prefix];
        };
        stack.push(t);
        return true;
      }
      TypeDecl = function(lhs, rhsLower, rhsUpper) {
        t = {
          type: "TYPE-DECL",
          alttypes: ["STATEMENT"],
          lhs: lhs,
          rhsLower: rhsLower,
          rhsUpper: rhsUpper,
          line: lhs.line,
          column: lhs.column
        };
        t.stringify = function(indent) {
          return t.lhs.stringify(indent) + ": at most " + t.rhsUpper.stringify(indent) + " at least " + t.rhsLower.stringify(indent) + strtyp(t, indent);
        };
        t.subtrees = function() {
          return [t.lhs, t.rhsLower, t.rhsUpper];
        };
        return t;
      };
      if (matches(["ID", "COLON", "*", "*", "*", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["ATMOST", "TYPE", "ATLEAST", "TYPE"])) {
          rhsLower = stack.pop();
          stack.pop();
          rhsUpper = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        } else if (matches(["ATLEAST", "TYPE", "ATMOST", "TYPE"])) {
          rhsUpper = stack.pop();
          stack.pop();
          rhsLower = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        } else {
          expected("TYPE in bounds declaration of " + (fromTopOfStack(5).stringify(0)));
        }
      }
      if (matches(["ID", "COLON", "*", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["ATMOST", "TYPE"])) {
          rhsUpper = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          rhsLower = Token("ID", "Nothing", rhsUpper.line, rhsUpper.column);
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        } else if (matches(["ATLEAST", "TYPE"])) {
          rhsLower = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          rhsUpper = Token("ID", "Any", rhsLower.line, rhsLower.column);
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        } else {
          expected("TYPE in declaration of " + (fromTopOfStack(3).stringify(0)));
        }
      }
      if (matches(["id", "COLON", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TERM-DECL",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhs: rhs,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + ": " + t.rhs.stringify(indent) + strtyp(t, indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhs];
          };
          stack.push(t);
          return true;
        } else {
          expected("TYPE in declaration of " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["ID", "EQUALS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TYPE-ASSIGN",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhs: rhs,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + " = " + t.rhs.stringify(indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhs];
          };
          stack.push(t);
          return true;
        } else {
          expected("TYPE in assignment to " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["id", "EQUALS", "*", "NEWLINE"]) || matches(["TERM-SELECT", "EQUALS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TERM"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TERM-ASSIGN",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhs: rhs,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + " = " + t.rhs.stringify(indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhs];
          };
          stack.push(t);
          return true;
        } else {
          expected("TERM in assignment to " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["TYPE", "AND", "TYPE"])) {
        rhs = stack.pop();
        stack.pop();
        lhs = stack.pop();
        t = {
          type: "AND-TYPE",
          alttypes: ["TYPE"],
          lhs: lhs,
          rhs: rhs,
          line: lhs.line,
          column: lhs.column
        };
        t.stringify = function(indent) {
          return t.lhs.stringify(indent) + " & " + t.rhs.stringify(indent);
        };
        t.subtrees = function() {
          return [t.lhs, t.rhs];
        };
        stack.push(t);
        return true;
      }
      if (matches(["STATEMENTS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TERM"])) {
          stmt = stack.pop();
          stmts = stack.pop();
          stmts.statements.push(stmt);
          stmts.line = stmt.line;
          stmts.column = stmt.column;
          stack.push(stmts);
          return true;
        } else {
          expected("STATEMENT");
        }
      }
      if (matches(["STATEMENTS", "STATEMENT"])) {
        stmt = stack.pop();
        stmts = stack.pop();
        stmts.statements.push(stmt);
        stmts.line = stmt.line;
        stmts.column = stmt.column;
        stack.push(stmts);
        return true;
      }
      if (matches(["LBRACE"])) {
        lparen = fromTopOfStack();
        begin(lparen.line, lparen.column);
        return true;
      }
      if (matches(["LBRACE", "STATEMENTS", "RBRACE"])) {
        stack.pop();
        stmts = stack.pop();
        stack.pop();
        stack.push(stmts);
        return true;
      }
      if (matches(["TYPE", "DOT", "NEW"])) {
        nw = stack.pop();
        stack.pop();
        _typTree = stack.pop();
        construct = {
          type: "CONSTRUCT",
          alttypes: ["TERM"],
          typTree: _typTree,
          line: nw.line,
          column: nw.column
        };
        construct.stringify = function(indent) {
          return ((construct.typTree.stringify(indent)) + ".new") + strtyp(construct, indent);
        };
        construct.subtrees = function() {
          return [construct.typTree];
        };
        stack.push(construct);
        return true;
      }
      if (matches(["STATEMENTS", "NEWLINE"])) {
        stack.pop();
        return true;
      }
    };
    begin = function(ln, col) {
      var stmts;
      stmts = {
        type: "STATEMENTS",
        alttypes: ["TYPE"],
        statements: [],
        line: ln,
        column: col
      };
      stmts.stringify = function(indent) {
        var stmt;
        return "{\n" + ((function() {
          var j, len, ref, results;
          ref = stmts.statements;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            stmt = ref[j];
            results.push(tabs(indent + 1) + stmt.stringify(indent + 1) + "\n");
          }
          return results;
        })()).join("") + tabs(indent) + "}";
      };
      stmts.subtrees = function() {
        return stmts.statements;
      };
      stmts.print = stmts.stringify;
      return stack.push(stmts);
    };
    showTypes = function(t) {
      var s, typ;
      s = t.type;
      if (t.alttypes) {
        s = s + " & " + ((function() {
          var j, len, ref, results;
          ref = t.alttypes;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            typ = ref[j];
            results.push(typ);
          }
          return results;
        })()).join(" & ");
      }
      return s;
    };
    begin(1, 1);
    while (true) {
      while (reduce()) {
        true;
      }
      if (tokens[0].type === "EOF" || unreducedTokenCount() >= 8) {
        break;
      }
      shift();
    }
    if (stack.length !== 1) {
      i = -1;
      stack_contents = ((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = stack.length; j < len; j++) {
          t = stack[j];
          i += 1;
          results.push("Item " + i + ": " + (showTypes(t)) + "\n" + (t.stringify(0)));
        }
        return results;
      })()).join("\n\n");
      throw "Parse error: Unreduced items on stack at End-of-Input. Stack contents:\n\n" + stack_contents;
    }
    return stack[0];
  };

  tokenize = function(input) {
    var Whitespace, column, consumeNextToken, getNextToken, line, t, tk, tokenList, tokens;
    line = 1;
    column = 1;
    tokenList = [
      {
        name: "GUARD_ARROW",
        regex: /^=>/
      }, {
        name: "id",
        regex: /^[a-z][a-zA-z0-9_]*/
      }, {
        name: "ID",
        regex: /^[A-Z][a-zA-z0-9_]*/
      }, {
        name: "NEWLINE",
        regex: /^(\n|\r\n|\r)/
      }, {
        name: "COMMENT",
        regex: /^\/\/.*/
      }, {
        name: "START-BLOCK-COMMENT",
        regex: /^\/\*/
      }, {
        name: "END-BLOCK-COMMENT",
        regex: /^\*\//
      }, {
        name: "DOT",
        regex: /^\./
      }, {
        name: "AND",
        regex: /^&/
      }, {
        name: "OR",
        regex: /^\|/
      }, {
        name: "EQUALS",
        regex: /^=/
      }, {
        name: "LPAREN",
        regex: /^\(/
      }, {
        name: "RPAREN",
        regex: /^\)/
      }, {
        name: "LBRACE",
        regex: /^{/
      }, {
        name: "RBRACE",
        regex: /^}/
      }, {
        name: "COLON",
        regex: /^:/
      }, {
        name: "EOF",
        regex: /^$/
      }
    ];
    Whitespace = {
      name: "SPACE",
      regex: /^[\t \v\f]+/
    };
    getNextToken = function() {
      var j, len, length, matches, tok;
      matches = Whitespace.regex.exec(input);
      if (matches) {
        input = input.substring(matches[0].length);
        column += matches[0].length;
      }
      for (j = 0, len = tokenList.length; j < len; j++) {
        tok = tokenList[j];
        matches = tok.regex.exec(input);
        if (matches) {
          return Token(tok.name, matches[0], line, column);
        }
      }
      length = input.indexOf('\n');
      if (length <= 0) {
        length = input.length;
      }
      throw "Tokenization error on line " + line + " character " + column + " : Unable to match a token starting at '" + (input.substring(0, length)) + "'";
    };
    consumeNextToken = function() {
      var tok;
      tok = getNextToken();
      input = input.substring(tok.match.length);
      column += tok.match.length;
      if (tok.type === "NEWLINE") {
        column = 1;
        line += 1;
      }
      return tok;
    };
    tokens = [];
    while (true) {
      t = consumeNextToken();
      if (t.type === "RBRACE" || t.type === "EOF") {
        tk = Token("NEWLINE", "\n", t.line, t.column);
        tk.stringify = function() {
          return "(synthetic \\n)";
        };
        tk.print = function() {
          return "synthetic NEWLINE on line " + t.line + ", char " + t.column;
        };
        tokens.push(tk);
      }
      tokens.push(t);
      if (t.type === "EOF") {
        break;
      }
    }
    return tokens;
  };

  tabs = function(indent) {
    return "    ".repeat(indent);
  };

}).call(this);
