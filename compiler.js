// Generated by CoffeeScript 1.10.0
(function() {
  var AddSymbolFromNamedType, AddSymbolFromTree, AndType, Any, CreateGlobalContext, DefaultToken, FieldMember, Nothing, OrType, TermSelect, Token, TypeMember, TypeSelect, contextify, findMember, getSummary, lowerBoundMembership, parse, stringifyMembershipSet, strtyp, tabs, tokenize, typeMembers, typecheck, upperBoundMembership,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.compile = function(input, stopAfter) {
    var ast, debugOutput, error, error1, summ, tok, tokens;
    try {
      tokens = tokenize(input);
      if (stopAfter === "tokens") {
        return ((function() {
          var j, len, results;
          results = [];
          for (j = 0, len = tokens.length; j < len; j++) {
            tok = tokens[j];
            results.push(tok.print());
          }
          return results;
        })()).join('\n');
      }
      ast = parse(tokens);
      if (stopAfter === "trees") {
        return ast.print(0);
      }
      debugOutput = contextify(CreateGlobalContext(), ast);
      if (stopAfter === "symbols") {
        return debugOutput;
      }
      summ = getSummary(ast, true);
      if (stopAfter === "types") {
        return stringifyMembershipSet(summ.typeMembers("UPPER"), 0);
      }
    } catch (error1) {
      error = error1;
      if (error.stack) {
        return error.stack;
      } else {
        return error;
      }
    }
  };

  strtyp = function(tree, indent) {
    var j, len, m, mInfo, outp, output, ref;
    output = [];
    if (tree.lowerBoundMembership) {
      mInfo = [];
      ref = tree.lowerBoundMembership;
      for (j = 0, len = ref.length; j < len; j++) {
        m = ref[j];
        if (m.type === "TERM-DECL") {
          mInfo.push("" + m.lhs.match + (strtyp(m.rhs, indent + 1)));
        }
      }
      output.push((mInfo.length < 2 ? "{ " + mInfo.join("") + " }" : "{\n" + mInfo.join("\n") + "\n}"));
    }
    outp = output.join(" ");
    if (outp) {
      return " : " + outp + " ";
    } else {
      return "";
    }
  };

  typecheck = function(tree) {
    var j, len, lhsTyp, members, ref, results, rhsTyp, t;
    if (tree.type === "STATEMENTS") {
      members = lowerBoundMembership(tree);
      results = [];
      for (j = 0, len = members.length; j < len; j++) {
        t = members[j];
        results.push(typecheck(t));
      }
      return results;
    } else if ((ref = tree.type) === "id" || ref === "ID" || ref === "TYPE-SELECT" || ref === "TERM-SELECT") {
      upperBoundMembership(tree);
      return lowerBoundMembership(tree);
    } else if (tree.type === "TERM-ASSIGN") {
      rhsTyp = upperBoundMembership(tree.rhs);
      return lhsTyp = lowerBoundMembership(tree.lhs);
    }
  };

  lowerBoundMembership = function(tree) {
    var members, name, prefixTree, prefixTypeMembers, st;
    if (tree.lowerBoundMembership) {
      return tree.lowerBoundMembership;
    }
    members = void 0;
    if (tree.type === "STATEMENTS") {
      members = tree.statements;
    } else if (tree.type === "ID" || tree.type === "id") {
      members = tree.context.lookupSymbol(tree.match).getMembersForConstruction();
    } else if (tree.type === "TYPE-SELECT" || tree.type === "TERM-SELECT") {
      prefixTree = tree.lhs;
      name = tree.rhs.match;
      prefixTypeMembers = upperBoundMembership(prefixTree);
      st = findMember(name, prefixTypeMembers);
      if (st.type === "TERM-DECL" || st.type === "TYPE-ASSIGN") {
        members = lowerBoundMembership(st.rhs);
      } else {
        throw "Internal compiler error : Unexpected " + st.type + " in lowerBoundMembership";
      }
    } else {
      throw "Unimplemented request for lower-bound membership of " + tree.type + " tree";
    }
    tree.lowerBoundMembership = members;
    return members;
  };

  upperBoundMembership = function(tree) {
    var members, name, prefixTree, prefixTypeMembers, st;
    if (tree.upperBoundMembership) {
      return tree.upperBoundMembership;
    }
    members = void 0;
    if (tree.type === "STATEMENTS") {
      members = tree.statements;
    } else if (tree.type === "ID" || tree.type === "id") {
      members = tree.context.lookupSymbol(tree.match).getMembersConservatively();
    } else if (tree.type === "TYPE-SELECT" || tree.type === "TERM-SELECT") {
      prefixTree = tree.lhs;
      name = tree.rhs.match;
      prefixTypeMembers = upperBoundMembership(prefixTree);
      st = findMember(name, prefixTypeMembers);
      if (st.type === "TERM-DECL" || st.type === "TYPE-ASSIGN") {
        members = upperBoundMembership(st.rhs);
      } else {
        throw "Internal compiler error : Unexpected " + st.type + " in upperBoundMembership";
      }
    } else {
      throw "Unimplemented request for upper-bound membership of " + tree.type + " tree";
    }
    tree.upperBoundMembership = members;
    return members;
  };

  findMember = function(name, statements, lowerBound) {
    var j, lastMatch, len, s;
    if (lowerBound == null) {
      lowerBound = false;
    }
    lastMatch = void 0;
    for (j = 0, len = statements.length; j < len; j++) {
      s = statements[j];
      if (s.type === "TERM-DECL" || s.type === "TYPE-ASSIGN") {
        if (name === s.lhs.match) {
          lastMatch = s;
        }
      }
    }
    return lastMatch;
  };


  /*
  What is a type anyway?
  It is (according to Odersky) just what you type (literally).
  Viewpoint adaptation needs to occur, due to path-dependent typing. ->
  	This means subtitutions need to occur, and types need to be clonable. (this is why types are not mere trees)
  (Membership is a separate issue.)
  (Type inference is a separate issue.)
   */


  /*
  We only type-check terms?
   */


  /*
  DOT types.
  
  See: Rompf and Amin. "From F to DOT: Type Soundness Proofs with Definitional Interpreters." Tech Report 2015.
   */

  Any = {};

  Nothing = {};

  TypeMember = function() {
    return {};
  };

  FieldMember = function() {
    return {};
  };

  TypeSelect = function(prefixTyp, ID) {
    return {};
  };

  TermSelect = function(prefixTyp, id) {
    return {};
  };

  AndType = function(tp1, tp2) {
    return {
      tp1: tp1,
      tp2: tp2
    };
  };

  OrType = function(tp1, tp2) {
    return {
      tp1: tp1,
      tp2: tp2
    };
  };


  /*
  assignTypeTypeAssign = (tree) ->
  	ID = tree.lhs.match
  	rhsType = assignType(tree.rhs)
  	rhsType
  
  assignTypeTypeSelect = (tree) ->
  	prefixType = assignType(tree.prefix)
  	prefixType.findMember(tree.ID)   # how do I avoid infinite loops?
  
  
  #assignType...
  	#tree.context.lookupSymbol()
  
   * A memoized function to assign types to trees.
  assignType = (tree) ->
  	if tree.typ then return tree.typ
  
  	tree.typ =
  		#if tree.type == "STATEMENTS" then assignTypeStatments(tree)
  		#else if tree.type == "TERM-ASSIGN" then assignTypeTermAssign(tree)
  		#else if tree.type == "TYPE-SELECT" then assignTypeTypeSelect(tree)
  
  		if tree.type is "TYPE-ASSIGN" then assignTypeTypeAssign(tree)
  
  		if tree.type is "TYPE-SELECT" then assignTypeTypeSelect(tree)
  
  	tree.typ
   */


  /*
  membershipOfStatements = (tree) ->
  
  	typeMembers = {}
  	for st in tree.statements
  		if st.type is "TYPE-DECL"
  			existing = typeMembers[st.lhs.match]
  			typeMembers[st.lhs.match] =
  				upperBound: if existing then AndType(existng.upperBound, st.rhsUpper) else st.rhsUpper
  				lowerBound: st.rhsLower
  
  	return
  		typeMembers: {}   # ID -> { lowerBound: tree, upperBound: tree }
  		termMembers: {}   # id -> 
  
  getMembershipOf = (tree) ->
  	if tree.type is "STATEMENTS" then membershipOfStatements(tree)
   */

  DefaultToken = function(tkIn, defaultType, defaultText, defaultLine, defaultColumn) {
    if (tkIn) {
      return tkIn;
    } else {
      return Token(defaultType, defaultText, defaultLine, defaultColumn);
    }
  };

  Token = function(tokType, text, line, column) {
    var tk;
    tk = {
      type: tokType,
      match: text,
      line: line,
      column: column,
      isToken: true
    };
    tk.stringify = function() {
      return tk.match.replace('\n', '\\n');
    };
    tk.print = function() {
      return tk.type + ", \"" + (tk.match.replace('\n', '\\n')) + "\", line " + tk.line + ", character " + tk.column;
    };
    return tk;
  };

  CreateGlobalContext = function() {
    var context;
    context = {
      symbols: {},
      outerContext: void 0
    };
    AddSymbolFromNamedType(context, "Any", Any);
    AddSymbolFromNamedType(context, "Nothing", Nothing);
    context.lookupSymbol = function(symName, line, column) {
      if (symName in context.symbols) {
        return context.symbols[symName];
      } else if (context.outerContext) {
        return context.outerContext.lookupSymbol(symName, line, column);
      } else {
        throw "Symbol '" + symName + "' not found at line " + line + " character " + column;
      }
    };
    return context;
  };

  stringifyMembershipSet = function(mems, indent) {
    var id, out, summary;
    out = [];
    for (id in mems) {
      summary = mems[id];
      out.push(tabs(indent + 1) + id + " : " + summary.tree.stringify(indent + 1) + "\n");
    }
    return "{\n" + out.join("") + tabs(indent) + "}";
  };

  getSummary = function(tree, doSubtrees) {
    var summary;
    if (doSubtrees == null) {
      doSubtrees = false;
    }
    if (tree.summary) {
      return tree.summary;
    }
    summary = {
      tree: tree,
      ownerContext: tree.context.outerContext,
      typeMembers: function(which) {
        return typeMembers(tree, which);
      },
      termMembers: function(which) {
        return termMembers(tree, which);
      },
      assignedTypes: function() {
        return null;
      },
      assignedTerms: function() {
        return null;
      }
    };
    tree.summary = summary;
    return summary;
  };

  typeMembers = function(tree, which) {
    var ID, j, len, m, members, ref, st, typTree;
    members = {};
    switch (tree.type) {
      case "STATEMENTS":
        ref = tree.statements;
        for (j = 0, len = ref.length; j < len; j++) {
          st = ref[j];
          if (st.type === "TYPE-DECL") {
            ID = st.lhs.match;
            typTree = which === "UPPER" ? st.rhsUpper : st.rhsLower;
            members[ID] = getSummary(typTree);
          }
        }
        break;
      case "TYPE-SELECT":
        m = getSummary(tree.prefix).typeMembers("LOWER");
        if (!m[tree.ID]) {
          throw "Error : '" + tree.ID + "' is not a member of ${tree.prefix} on line " + tree.line + " character " + tree.column;
        }
        break;
      case "TERM-SELECT":
        m = getSummary(tree.prefix).termMembers("LOWER");
        if (!m[tree.id]) {
          throw "Error : '" + tree.id + "' is not a member of ${tree.prefix} on line " + tree.line + " character " + tree.column;
        }
        typeMembers(m[tree.id], which);
        break;
      case "id":
        members = tree.context.lookupSymbol(tree.lhs.match, tree.line, tree.column).summary.typeMembers(which);
        break;
      case "ID":
        members = tree.context.lookupSymbol(tree.lhs.match, tree.line, tree.column).summary.typeMembers(which);
    }
    return members;
  };


  /*
  findMembers = (tree) ->
  	if tree.membership then return tree.membership
  
  	membership = {}
  
  	if tree.type is "STATEMENTS"
  
  		typeDecls = {}
  		for st in tree.statements
  			if st.type is "TYPE-DECL"
  				ID = st.lhs.match
  				 * TODO: if type member already exists, restrict its bounds
  				typeDecls[ID] =
  					lowerTree: st.rhsLower
  					upperTree: st.rhsUpper
  
  		termDecls = {}
  		for st in tree.statements
  			if st.type is "TERM-DECL"
  				id = st.lhs.match
  				 * TODO: if term decl already exists, it must have the same type
  				termDecls[id] =
  					lowerTree: st.rhs
  					upperTree: st.rhs
  
  		membership.typeDecls = typeDecls
  		membership.termDecls = termDecls
  
  	if tree.type is "AND-TYPE"
  		lhsTyp = findMembers(tree.lhs)
  		rhsTyp = findMembers(tree.rhs)
  		typeDecls = {}
  		for ID, typ of lhsTyp.typeDecls
  			typeDecls
  
  	tree.membership = membership
  	membership
   */

  AddSymbolFromNamedType = function(context, name, typ) {
    var sym;
    sym = {
      name: name,
      typ: typ
    };
    context.symbols[name] = sym;
    sym.summary = function() {
      return sym.typ;
    };
    return sym;
  };

  AddSymbolFromTree = function(context, name, defTree, line, column) {
    var sym;
    sym = {
      name: name,
      rhs: defTree,
      line: line,
      column: column
    };
    context.symbols[name] = sym;
    sym.summary = function() {
      return getSummary(sym.rhs);
    };
    return sym;
  };

  contextify = function(outerContext, tree) {
    var j, k, len, len1, output, prevDef, ref, ref1, subtree, symName, t;
    output = [];
    tree.context = outerContext;
    if (tree.type === "STATEMENTS") {
      tree.context = {
        symbols: {},
        outerContext: outerContext,
        lookupSymbol: outerContext.lookupSymbol
      };
      ref = tree.statements;
      for (j = 0, len = ref.length; j < len; j++) {
        t = ref[j];
        if (t.type === "TERM-DECL" || t.type === "TYPE-ASSIGN") {
          symName = t.lhs.match;
          prevDef = tree.context.symbols[symName];
          if (prevDef) {
            throw "Duplicate definition of " + symName + ": line " + prevDef.line + " and line " + t.line;
          }
          AddSymbolFromTree(tree.context, symName, t.rhs, t.line, t.column);
          output.push("(line " + t.line + " character " + t.column + ") " + symName + " : " + (t.rhs.stringify(0)));
        }
      }
    }
    if (tree.subtrees) {
      ref1 = tree.subtrees();
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        subtree = ref1[k];
        output = output.concat(contextify(tree.context, subtree));
      }
    } else if (!tree.isToken) {
      throw "Internal compiler error: Function \"subtrees\" not found during traveral of " + tree.type + " tree at line " + tree.line + " character " + tree.column + ". Value: " + tree.value;
    }
    return output.join("\n");
  };

  parse = function(tokens) {
    var begin, expected, fromTopOfStack, i, matches, reduce, shift, showTypes, stack, stack_contents, t, unreducedTokenCount;
    stack = [];
    unreducedTokenCount = function() {
      var i, j, ref;
      for (i = j = 1, ref = stack.length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        if (!stack[stack.length - i].isToken) {
          return i - 1;
        }
      }
      return stack.length;
    };
    matches = function(types, skip) {
      var elem, i, j, ref, ref1;
      if (skip == null) {
        skip = 0;
      }
      if (types.length <= stack.length - skip) {
        for (i = j = 0, ref = types.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          if (types[i] !== "*") {
            elem = stack[stack.length - types.length + i - skip];
            if (elem.type !== types[i] && !(elem.alttypes && (ref1 = types[i], indexOf.call(elem.alttypes, ref1) >= 0))) {
              return false;
            }
          }
        }
        return true;
      } else {
        return false;
      }
    };
    fromTopOfStack = function(i) {
      if (i == null) {
        i = 0;
      }
      if (i > stack.length - 1) {
        return void 0;
      } else {
        return stack[stack.length - 1 - i];
      }
    };
    shift = function() {
      var t;
      t = tokens.shift();
      if (t.type === "id") {
        t.alttypes = ["TERM"];
      }
      if (t.type === "ID") {
        t.alttypes = ["TYPE"];
      }
      return stack.push(t);
    };
    expected = function(description) {
      var t, value;
      if (stack.length > 0) {
        t = stack[stack.length - 1];
        value = t.isToken ? t.match.replace('\n', '\\n') : t.stringify(0);
        throw "Parse error on line " + t.line + " character " + t.column + " : Expected " + description + "; got " + t.type + " with value \"" + value + "\"";
      } else {
        throw "Parse error with empty stack: Expected " + description;
      }
    };
    reduce = function() {
      var ID, construct, id, lhs, lparen, nw, prefix, rhs, rhsLower, rhsUpper, stmt, stmts, t, typ;
      if (matches(["TERM", "DOT", "id"])) {
        id = stack.pop();
        stack.pop();
        prefix = stack.pop();
        t = {
          type: "TERM-SELECT",
          alttypes: ["TERM"],
          prefix: prefix,
          id: id.match,
          line: id.line,
          column: id.column
        };
        t.stringify = function(indent) {
          return t.prefix.stringify(indent) + ("." + t.id + (strtyp(t, indent)));
        };
        t.subtrees = function() {
          return [t.prefix];
        };
        stack.push(t);
        return true;
      }
      if (matches(["TERM", "DOT", "ID"])) {
        ID = stack.pop();
        stack.pop();
        prefix = stack.pop();
        t = {
          type: "TYPE-SELECT",
          alttypes: ["TYPE"],
          prefix: prefix,
          ID: ID.match,
          line: ID.line,
          column: ID.column
        };
        t.stringify = function(indent) {
          return t.prefix.stringify(indent) + ("." + t.ID + (strtyp(t, indent)));
        };
        t.subtrees = function() {
          return [t.prefix];
        };
        stack.push(t);
        return true;
      }
      if (matches(["ID", "COLON", "ATMOST", "*", "ATLEAST", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE", "ATLEAST", "TYPE"])) {
          rhsLower = stack.pop();
          stack.pop();
          rhsUpper = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TYPE-DECL",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhsUpper: rhsUpper,
            rhsLower: rhsLower,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + ": at most " + t.rhsUpper.stringify(indent) + " at least " + t.rhsLower.stringify(indent) + strtyp(t, indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhsUpper, t.rhsLower];
          };
          stack.push(t);
          return true;
        } else {
          expected("TYPE in bounds declaration of " + (fromTopOfStack(5).stringify(0)));
        }
      }
      if (matches(["ID", "COLON", "ATMOST", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhsUpper = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TYPE-DECL",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhsUpper: rhsUpper,
            rhsLower: Token("ID", "Nothing", rhsUpper.line, rhsUpper.column),
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + ": at most " + t.rhsUpper.stringify(indent) + " at least " + t.rhsLower.stringify(indent) + strtyp(t, indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhsUpper, t.rhsLower];
          };
          stack.push(t);
          return true;
        } else {
          expected("TYPE in declaration of " + (fromTopOfStack(3).stringify(0)));
        }
      }
      if (matches(["id", "COLON", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TERM-DECL",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhs: rhs,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + ": " + t.rhs.stringify(indent) + strtyp(t, indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhs];
          };
          stack.push(t);
          return true;
        } else {
          expected("TYPE in declaration of " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["ID", "EQUALS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TYPE-ASSIGN",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhs: rhs,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + " = " + t.rhs.stringify(indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhs];
          };
          stack.push(t);
          return true;
        } else {
          expected("TYPE in assignment to " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["id", "EQUALS", "*", "NEWLINE"]) || matches(["TERM-SELECT", "EQUALS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TERM"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TERM-ASSIGN",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhs: rhs,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + " = " + t.rhs.stringify(indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhs];
          };
          stack.push(t);
          return true;
        } else {
          expected("TERM in assignment to " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["TYPE", "AND", "TYPE"])) {
        rhs = stack.pop();
        stack.pop();
        lhs = stack.pop();
        t = {
          type: "AND-TYPE",
          alttypes: ["TYPE"],
          lhs: lhs,
          rhs: rhs,
          line: lhs.line,
          column: lhs.column
        };
        t.stringify = function(indent) {
          return t.lhs.stringify(indent) + " & " + t.rhs.stringify(indent);
        };
        t.subtrees = function() {
          return [t.lhs, t.rhs];
        };
        stack.push(t);
        return true;
      }
      if (matches(["STATEMENTS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TERM"])) {
          stmt = stack.pop();
          stmts = stack.pop();
          stmts.statements.push(stmt);
          stmts.line = stmt.line;
          stmts.column = stmt.column;
          stack.push(stmts);
          return true;
        } else {
          expected("STATEMENT");
        }
      }
      if (matches(["STATEMENTS", "STATEMENT"])) {
        stmt = stack.pop();
        stmts = stack.pop();
        stmts.statements.push(stmt);
        stmts.line = stmt.line;
        stmts.column = stmt.column;
        stack.push(stmts);
        return true;
      }
      if (matches(["LBRACE"])) {
        lparen = fromTopOfStack();
        begin(lparen.line, lparen.column);
        return true;
      }
      if (matches(["LBRACE", "STATEMENTS", "RBRACE"])) {
        stack.pop();
        stmts = stack.pop();
        stack.pop();
        stack.push(stmts);
        return true;
      }
      if (matches(["TYPE", "DOT", "NEW"])) {
        nw = stack.pop();
        stack.pop();
        typ = stack.pop();
        construct = {
          type: "CONSTRUCT",
          alttypes: ["TERM"],
          typ: typ,
          line: nw.line,
          column: nw.column
        };
        construct.stringify = function(indent) {
          return ((construct.typ.stringify(indent)) + ".new") + strtyp(construct, indent);
        };
        construct.subtrees = function() {
          return [construct.typ];
        };
        stack.push(construct);
        return true;
      }
      if (matches(["STATEMENTS", "NEWLINE"])) {
        stack.pop();
        return true;
      }
    };
    begin = function(ln, col) {
      var stmts;
      stmts = {
        type: "STATEMENTS",
        alttypes: ["TYPE"],
        statements: [],
        line: ln,
        column: col
      };
      stmts.stringify = function(indent) {
        var stmt;
        return "{\n" + ((function() {
          var j, len, ref, results;
          ref = stmts.statements;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            stmt = ref[j];
            results.push(tabs(indent + 1) + stmt.stringify(indent + 1) + "\n");
          }
          return results;
        })()).join("") + tabs(indent) + "}";
      };
      stmts.subtrees = function() {
        return stmts.statements;
      };
      stmts.print = stmts.stringify;
      return stack.push(stmts);
    };
    showTypes = function(t) {
      var s, typ;
      s = t.type;
      if (t.alttypes) {
        s = s + " & " + ((function() {
          var j, len, ref, results;
          ref = t.alttypes;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            typ = ref[j];
            results.push(typ);
          }
          return results;
        })()).join(" & ");
      }
      return s;
    };
    begin(1, 1);
    while (true) {
      while (reduce()) {
        true;
      }
      if (tokens[0].type === "EOF" || unreducedTokenCount() >= 8) {
        break;
      }
      shift();
    }
    if (stack.length !== 1) {
      i = -1;
      stack_contents = ((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = stack.length; j < len; j++) {
          t = stack[j];
          i += 1;
          results.push("Item " + i + ": " + (showTypes(t)) + "\n" + (t.stringify(0)));
        }
        return results;
      })()).join("\n\n");
      throw "Parse error: Unreduced items on stack at End-of-Input. Stack contents:\n\n" + stack_contents;
    }
    return stack[0];
  };

  tokenize = function(input) {
    var Whitespace, column, consumeNextToken, getNextToken, line, t, tk, tokenList, tokens;
    line = 1;
    column = 1;
    tokenList = [
      {
        name: "NEW",
        regex: /^new/
      }, {
        name: "IS_DEFINED",
        regex: /^is\s+defined/
      }, {
        name: "SPECIALIZES",
        regex: /^specializes/
      }, {
        name: "SPECIALIZED_BY",
        regex: /^specialized\s+by/
      }, {
        name: "ATLEAST",
        regex: /^at\s+least/
      }, {
        name: "ATMOST",
        regex: /^at\s+most/
      }, {
        name: "GUARD_ARROW",
        regex: /^=>/
      }, {
        name: "id",
        regex: /^[a-z][a-zA-z0-9_]*/
      }, {
        name: "ID",
        regex: /^[A-Z][a-zA-z0-9_]*/
      }, {
        name: "NEWLINE",
        regex: /^(\n|\r\n|\r)/
      }, {
        name: "COMMENT",
        regex: /^\/\/.*/
      }, {
        name: "DOT",
        regex: /^\./
      }, {
        name: "AND",
        regex: /^&/
      }, {
        name: "OR",
        regex: /^\|/
      }, {
        name: "EQUALS",
        regex: /^=/
      }, {
        name: "LPAREN",
        regex: /^\(/
      }, {
        name: "RPAREN",
        regex: /^\)/
      }, {
        name: "LBRACE",
        regex: /^{/
      }, {
        name: "RBRACE",
        regex: /^}/
      }, {
        name: "COLON",
        regex: /^:/
      }, {
        name: "EOF",
        regex: /^$/
      }
    ];
    Whitespace = {
      name: "SPACE",
      regex: /^[\t \v\f]+/
    };
    getNextToken = function() {
      var j, len, length, matches, tok;
      matches = Whitespace.regex.exec(input);
      if (matches) {
        input = input.substring(matches[0].length);
        column += matches[0].length;
      }
      for (j = 0, len = tokenList.length; j < len; j++) {
        tok = tokenList[j];
        matches = tok.regex.exec(input);
        if (matches) {
          return Token(tok.name, matches[0], line, column);
        }
      }
      length = input.indexOf('\n');
      if (length <= 0) {
        length = input.length;
      }
      throw "Tokenization error on line " + line + " character " + column + " : Unable to match a token starting at '" + (input.substring(0, length)) + "'";
    };
    consumeNextToken = function() {
      var tok;
      tok = getNextToken();
      input = input.substring(tok.match.length);
      column += tok.match.length;
      if (tok.type === "NEWLINE") {
        column = 1;
        line += 1;
      }
      return tok;
    };
    tokens = [];
    while (true) {
      t = consumeNextToken();
      if (t.type === "RBRACE" || t.type === "EOF") {
        tk = Token("NEWLINE", "\n", t.line, t.column);
        tk.stringify = function() {
          return "(synthetic \\n)";
        };
        tk.print = function() {
          return "synthetic NEWLINE on line " + t.line + ", char " + t.column;
        };
        tokens.push(tk);
      }
      tokens.push(t);
      if (t.type === "EOF") {
        break;
      }
    }
    return tokens;
  };

  tabs = function(indent) {
    return "    ".repeat(indent);
  };

}).call(this);
