// Generated by CoffeeScript 1.10.0
(function() {
  var AndType, Any, Nothing, OrType, TermDecl, Token, TypeBounds, TypeDecl, WithGuard, channels, clearLog, createPredefContext, derivedAndOrType, derivedTypeBounds, doStatementCompleters, doTermCompleters, doTypeCompleters, findMember, findMemberInContext, freshContext, gen, genConstructor, genInitializer, getDefContext, isSubType, linearizedForConstruction, log, lowerBound, parse, requireCompatibility, requireDefContext, requireMemberInContext, requireMemberInType, simplifyType, stderr, tabs, tokenize, typeAsConstructed, types, upperBound, widen,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.compile = function(input, stopAfter) {
    var allOutput, ast, bases, error, error1, ignore, message, output, outputBuffer, predefCtx, ref, tok, tokens;
    try {
      clearLog();
      tokens = tokenize(input);
      if (stopAfter === "tokens") {
        return ((function() {
          var j, len, results;
          results = [];
          for (j = 0, len = tokens.length; j < len; j++) {
            tok = tokens[j];
            results.push(tok.print());
          }
          return results;
        })()).join('\n');
      }
      ast = parse(tokens);
      if (stopAfter === "trees") {
        return ast.print(0);
      }
      predefCtx = createPredefContext();
      doTypeCompleters(ast, predefCtx.fresh(ast));
      outputBuffer = [];
      ref = linearizedForConstruction(ast, predefCtx), bases = ref[0], ignore = ref[1];
      genConstructor(bases, ast.ctx, predefCtx, 0, outputBuffer);
      outputBuffer.push(";");
      output = outputBuffer.join("");
      allOutput = [output];
      if (channels[types]) {
        allOutput.push("/** Types log:\n\n" + channels[types].join("\n") + "\n**/");
      }
      if (channels[stderr]) {
        allOutput.push("/** Stderr log:\n\n" + channels[stderr].join("\n") + "\n**/");
      }
      return allOutput.join("\n\n");
    } catch (error1) {
      error = error1;
      message = error.message != null ? error.message : error;
      message = message.toUpperCase().startsWith("ERROR") || message.toUpperCase().startsWith("INTERNAL COMPILER ERROR") ? message : "Error: " + message;
      output = [message];
      if (channels[types]) {
        output.push("Types log:\n\n" + channels[types].join("\n"));
      }
      if (channels[stderr]) {
        output.push("Stderr log:\n\n" + channels[stderr].join("\n"));
      }
      if (error.stack != null) {
        output.push("COMPILER STACKTRACE:\n" + error.stack);
      }
      return output.join("\n\n");
    }
  };

  channels = {};

  stderr = "stderr";

  types = "types";

  clearLog = function() {
    return channels = {};
  };

  log = function(ch, msg) {
    if (!channels[ch]) {
      return channels[ch] = [msg];
    } else {
      return channels[ch].push(msg);
    }
  };

  Any = {
    type: "ANY",
    stringify: function(indent) {
      return "Any";
    }
  };

  Nothing = {
    type: "NOTHING",
    stringify: function(indent) {
      return "Nothing";
    }
  };

  AndType = function(lhsTyp, rhsTyp) {
    return {
      type: "AND-TYPE",
      lhs: lhsTyp,
      rhs: rhsTyp,
      stringify: function(indent) {
        return lhsTyp.stringify(indent) + " & " + rhsTyp.stringify(indent);
      }
    };
  };

  OrType = function(lhsTyp, rhsTyp) {
    return {
      type: "OR-TYPE",
      lhs: lhsTyp,
      rhs: rhsTyp,
      stringify: function(indent) {
        return lhsTyp.stringify(indent) + " & " + rhsTyp.stringify(indent);
      }
    };
  };

  TypeBounds = function(typLower, typUpper) {
    return {
      type: "TYPE-BOUNDS",
      lower: typLower,
      upper: typUpper,
      stringify: function(indent) {
        return "at least " + (typLower.stringify(indent)) + " at most " + (typUpper.stringify(indent));
      }
    };
  };


  /* TYPE OPERATIONS */

  derivedTypeBounds = function(tree, lower, upper) {
    if (lower === tree.lower && upper === tree.upper) {
      return tree;
    } else {
      return TypeBounds(lower, upper);
    }
  };

  derivedAndOrType = function(tree, lhs, rhs) {
    if (lhs === tree.lhs && rhs === tree.rhs) {
      return tree;
    } else if (tree.type === "AND-TYPE") {
      return AndType(lhs, rhs);
    } else if (tree.type === "OR-TYPE") {
      return OrType(lhs, rhs);
    }
  };

  lowerBound = function(tree) {
    if (tree.type === "TYPE-BOUNDS") {
      return tree.lower;
    } else {
      return tree;
    }
  };

  upperBound = function(tree) {
    if (tree.type === "TYPE-BOUNDS") {
      return tree.upper;
    } else {
      return tree;
    }
  };

  simplifyType = function(tree) {
    var tree2;
    if (tree.type === "TYPE-BOUNDS") {
      tree2 = derivedTypeBounds(tree, simplifyType(tree.lower), simplifyType(tree.upper));
      if (tree2.lower === tree2.upper) {
        return tree2.lower;
      } else {
        return tree2;
      }
    } else if (tree.type === "AND-TYPE") {
      tree2 = derivedAndOrType(tree, simplifyType(tree.lhs), simplifyType(tree.rhs));
      if (tree2.lhs === tree2.rhs) {
        return tree2.lhs;
      } else if (tree2.lhs === Nothing || tree2.rhs === Nothing) {
        return Nothing;
      } else if (tree2.lhs === Any) {
        return tree2.rhs;
      } else if (tree2.rhs === Any) {
        return tree2.lhs;
      } else {
        return tree2;
      }
    } else if (tree.type === "OR-TYPE") {
      tree2 = derivedAndOrType(tree, simplifyType(tree.lhs), simplifyType(tree.rhs));
      if (tree2.lhs === tree2.rhs) {
        return tree2.lhs;
      } else if (tree2.lhs === Any || tree2.rhs === Any) {
        return Any;
      } else if (tree2.lhs === Nothing) {
        return tree2.rhs;
      } else if (tree2.rhs === Nothing) {
        return tree2.lhs;
      } else {
        return tree2;
      }
    } else {
      return tree;
    }
  };


  /* CONTEXTS AND SYMBOL/MEMBER LOOKUP */

  createPredefContext = function() {
    var ctx, predefTree;
    predefTree = {
      type: "STATEMENTS",
      statements: []
    };
    predefTree.stringify = function(indent) {
      return "{ (predefined symbols) }";
    };
    predefTree.statements.push(TypeDecl(Token("ID", "Any", void 0, void 0), Any, Any));
    predefTree.statements.push(TypeDecl(Token("ID", "Nothing", void 0, void 0), Nothing, Nothing));
    predefTree.statements.push(TermDecl(Token("ID", "???", void 0, void 0), Nothing));
    ctx = freshContext(void 0, predefTree);
    ctx.outer = ctx;
    Any.ctx = ctx;
    Nothing.ctx = ctx;
    return ctx;
  };

  freshContext = function(outer, typTree) {
    var ctx;
    ctx = {};
    if (outer) {
      ctx.nestLevel = outer.nestLevel + 1;
      ctx.outer = outer;
    } else {
      ctx.nestLevel = 0;
      ctx.outer = void 0;
    }
    ctx.indents = tabs(ctx.nestLevel);
    ctx.name = "c" + ctx.nestLevel;
    ctx.fresh = function(typTree) {
      return freshContext(ctx, typTree);
    };
    ctx.findMember = function(name, returnLowerBound, logIndent) {
      var asConstructed;
      asConstructed = typeAsConstructed(typTree, ctx.outer);
      return findMember(name, asConstructed, void 0, returnLowerBound, logIndent);
    };
    return ctx;
  };

  findMember = function(name, typTree, ctx, returnLowerBound, logIndent) {
    var found, j, len, lhsType, ref, ref1, ref2, rhsType, st, widenedCtx, widenedIdCtx, widenedIdTree, widenedTyp;
    if (typTree.type === "STATEMENTS") {
      found = void 0;
      ref = typTree.statements;
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        if (st.type === "TYPE-DECL" && st.lhs.match === name) {
          if (found) {
            throw new Error("Duplicate definition of '" + name + "' on line " + st.lhs.line + " character " + st.lhs.column);
          }
          found = returnLowerBound ? st.rhsLower : st.rhsUpper;
        } else if (st.type === "TERM-DECL" && st.lhs.match === name) {
          if (found) {
            throw new Error("Duplicate definition of '" + name + "' on line " + st.lhs.line + " character " + st.lhs.column);
          }
          found = st.rhs;
        }
      }
      return found;
    } else if (typTree.type === "ANY") {
      return void 0;
    } else if (typTree.type === "NOTHING") {
      throw new Error("Attempt to find member '" + name + "' in type Nothing, which contains contradictory definitions of '" + name + "'.");
    } else if (typTree.type === "ID") {
      ref1 = widen(typTree, ctx), widenedIdCtx = ref1[0], widenedIdTree = ref1[1];
      return findMember(name, widenedIdTree, widenedIdCtx, returnLowerBound);
    } else if (typTree.type === "TYPE-SELECT") {
      ref2 = widen(typTree, ctx), widenedCtx = ref2[0], widenedTyp = ref2[1];
      return findMember(name, widenedTyp, widenedCtx, returnLowerBound);
    } else if (typTree.type === "AND-TYPE") {
      lhsType = findMember(name, typTree.lhs, ctx, returnLowerBound);
      rhsType = findMember(name, typTree.rhs, ctx, returnLowerBound);
      if ((!lhsType) || (lhsType === rhsType)) {
        return rhsType;
      } else if (!rhsType) {
        return lhsType;
      } else if (returnLowerBound) {
        return OrType(lhsType, rhsType);
      } else {
        return AndType(lhsType, rhsType);
      }
    } else {
      throw new Error("Internal compiler error: Unexpected " + typTree.type + " tree in findMember");
    }
  };

  widen = function(tree, ctx, returnLowerBound, logIndent) {
    var asConstructed, prefixCtx, prefixTyp, ref, ref1;
    if (logIndent == null) {
      logIndent = 0;
    }
    if (tree.type === "id") {
      return [ctx, requireMemberInContext(tree.match, ctx, tree, returnLowerBound, logIndent + 1)];
    } else if (tree.type === "ID") {
      log(types, tabs(logIndent) + ("Widening ID " + tree.match + " starting from context " + ctx.name));
      return [ctx, requireMemberInContext(tree.match, ctx, tree, returnLowerBound, logIndent + 1)];
    } else if (tree.type === "TERM-SELECT") {
      log(types, tabs(logIndent) + ("Widening term selection " + (tree.stringify(logIndent + 1)) + " starting from context " + ctx.name));
      ref = widen(tree.prefix, ctx, false, logIndent + 1), prefixCtx = ref[0], prefixTyp = ref[1];
      return [prefixCtx, requireMemberInType(tree.id, prefixTyp, prefixCtx, tree, returnLowerBound)];
    } else if (tree.type === "TYPE-SELECT") {
      log(types, tabs(logIndent) + ("Widening type selection " + (tree.stringify(logIndent + 1)) + " starting from context " + ctx.name));
      ref1 = widen(tree.prefix, ctx, false, logIndent + 1), prefixCtx = ref1[0], prefixTyp = ref1[1];
      return [prefixCtx, requireMemberInType(tree.ID, prefixTyp, prefixCtx, tree, returnLowerBound)];
    } else if (tree.type === "CONSTRUCT") {
      asConstructed = typeAsConstructed(tree.typTree, ctx);
      log(types, tabs(logIndent) + ("Widening constructor " + (asConstructed.stringify(logIndent + 1)) + " starting from context " + ctx.name));
      return [tree.typTree.ctx, asConstructed];
    } else {
      throw new Error("Unexpected " + tree.type + " tree in widen");
    }
  };

  findMemberInContext = function(name, ctx, returnLowerBound, logIndent) {
    var found;
    found = ctx.findMember(name, returnLowerBound, logIndent);
    if (found) {
      return found;
    } else if (ctx !== ctx.outer) {
      return findMemberInContext(name, ctx.outer, returnLowerBound, logIndent);
    } else {
      return void 0;
    }
  };

  getDefContext = function(name, ctx) {
    if (ctx.findMember(name)) {
      return ctx;
    } else if (ctx !== ctx.outer) {
      return getDefContext(name, ctx.outer);
    } else {
      return void 0;
    }
  };

  requireMemberInContext = function(name, ctx, sourceTree, returnLowerBound, logIndent) {
    var typTree;
    typTree = findMemberInContext(name, ctx, returnLowerBound, logIndent);
    if (!typTree) {
      throw new Error("Name '" + name + "' is not defined at line " + sourceTree.line + " character " + sourceTree.column);
    }
    return typTree;
  };

  requireMemberInType = function(name, typTree, ctx, sourceTree, returnLowerBound, logIndent) {
    var found;
    found = findMember(name, typTree, ctx, returnLowerBound, logIndent);
    if (!found) {
      throw new Error("Member '" + name + "' at line " + sourceTree.line + " character " + sourceTree.column + " could not be found");
    }
    return found;
  };

  requireDefContext = function(name, ctx, sourceTree) {
    var found;
    found = getDefContext(name, ctx);
    if (!found) {
      throw new Error("Name '" + name + "' is not defined at line " + sourceTree.line + " character " + sourceTree.column);
    }
    return found;
  };


  /* BASE/CONSTRUCTOR TYPE QUERIES */

  typeAsConstructed = function(tree, ctx) {
    var bases, j, len, problemBase, ref, stmt, stmts, typ;
    ref = linearizedForConstruction(tree, ctx), bases = ref[0], problemBase = ref[1], stmts = ref[2];
    if (bases === false) {
      throw new Error("Cannot construct object at line " + tree.line + " character " + tree.column + " because base type " + (problemBase.stringify(0)) + " is non-constructible.");
    }
    typ = Any;
    for (j = 0, len = stmts.length; j < len; j++) {
      stmt = stmts[j];
      if (typ === Any) {
        typ = stmt;
      } else {
        typ = AndType(typ, stmt);
      }
    }
    return typ;
  };


  /*
  typeAsConstructed = (typTree, ctx) ->
  
  	 * We return the intersection base types here (instead of the original type tree).
  	 * This allows us to look at the membership of the object as actually constructed, rather than
  	 *  a conservative upper-bound approximation.
  	typ = Any
  	for block in findBaseStatementBlocks(typTree, ctx, typTree)
  		typ = AndType(typ, block)
  	typ  # TODO: simplify?
  
  findBaseStatementBlocks = (typTree, ctx, origTypTree) ->
  
  	if typTree._baseStatementBlocks
  		return typTree._baseStatementBlocks
  
  	statementsFound = []
  	basesSeen = []
  
  	[bases, baseWithProblem] = linearizedForConstruction(typTree, ctx)
  	if bases is false
  		throw new Error("Cannot construct object at line #{origTypTree.line} character #{origTypTree.column} because base type #{baseWithProblem.stringify(0)} is non-constructible.")
  
  	for base in bases
  		if not (base in basesSeen)
  			basesSeen.push base
  			if base.type in ["STATEMENTS", "ANY", "NOTHING"]
  				statementsFound.push base
  			else if base.type in ["ID", "TYPE-SELECT"]
  				if not ctx?
  					ctx = base.ctx  # set default context?
  				[wCtx, wTyp] = widen(base, ctx, true)
  				for stmts in findBaseStatementBlocks(wTyp, undefined, origTypTree)  # do we use wTyp.ctx.outer, wCtx, wCtx.outer, undefined, or else for the context?
  					if not (stmts in basesSeen)
  						basesSeen.push stmts
  						statementsFound.push stmts
  			else
  				throw new Error("Internal complier error: unexpected base tree type #{base.type} in findBaseStatementBlocks")
  
  	typTree._baseStatementBlocks = statementsFound
  	statementsFound
   */


  /*
  getBaseTypes = (typTree) ->
  
  	if typTree.type in ["ID", "TYPE-SELECT"]
  		[typTree]
  	else if typTree.type is "TYPE-BOUNDS"
  		 * Get lower bound of TypeBounds types.
  		getBaseTypes(typTree.lower)
  	else if typTree.type is "AND-TYPE"
  		 * AndTypes include bases from both the left-hand side and the right-hand side of the AndType.
  		getBaseTypes(typTree.lhs).concat(getBaseTypes(typTree.rhs))
  	else if typTree.type is "OR-TYPE"
  		 * Choose either the right-hand side or the left-hand side of the OrType.
  		 * Here, we choose the left-hand side unless one of its base types is Nothing.
  		 * (NOTE I don't follow type aliases here, so it is still possible that the LHS is
  		 *  non-constructible even if none of its immediate bases is Nothing.
  		 *  I don't know if this behaviour is reasonable or not.)
  		lhsBases = getBaseTypes(typTree.lhs)
  		rhsBases = getBaseTypes(typTree.rhs)
  		for b in lhsBases
  			if b.type is "NOTHING" or b.match is "Nothing"
  				return rhsBases
  		lhsBases
  	else if typTree.type in ["STATEMENTS", "ANY", "NOTHING"]
  		[typTree]
  	else
  		throw new Error("Internal compiler error: Expected a type tree in getBaseTypes, got #{typTree.type} tree")
   */

  linearizedForConstruction = function(tree, ctx) {
    var baseLhs, baseRhs, ignore, lin, linLhs, linRhs, ref, ref1, ref2, ref3, ref4, ref5, ref6, stmt, stmtLhs, stmtRhs, wCtx, wTyp;
    if (tree._linearization) {
      return [tree._linearization, void 0, tree._statements];
    } else {
      tree._linearization = [];
      tree._statements = [];
    }
    if ((ref = tree.type) === "ID" || ref === "TYPE-SELECT") {
      tree._linearization.push(tree);
      ref1 = widen(tree, ctx, true), wCtx = ref1[0], wTyp = ref1[1];
      ref2 = linearizedForConstruction(wTyp, wCtx), lin = ref2[0], ignore = ref2[1], stmt = ref2[2];
      if (lin === false) {
        tree._linearization = false;
        return [false, tree, void 0];
      }
      tree._statements = tree._statements.concat(stmt);
    } else if (tree.type === "AND-TYPE") {
      ref3 = linearizedForConstruction(tree.lhs, ctx), linLhs = ref3[0], baseLhs = ref3[1], stmtLhs = ref3[2];
      if (linLhs === false) {
        tree._linearization = false;
        return [false, baseLhs, void 0];
      }
      ref4 = linearizedForConstruction(tree.rhs, ctx), linRhs = ref4[0], baseRhs = ref4[1], stmtRhs = ref4[2];
      if (linRhs === false) {
        tree._linearization = false;
        return [false, baseRhs, void 0];
      }
      tree._linearization = tree._linearization.concat(linLhs);
      tree._statements = tree._statements.concat(stmtLhs);
      tree._linearization = tree._linearization.concat(linRhs);
      tree._statements = tree._statements.concat(stmtRhs);
    } else if (tree.type === "OR-TYPE") {
      log(types, "Considering OrType " + (tree.stringify(0)));
      ref5 = linearizedForConstruction(tree.lhs, ctx), linLhs = ref5[0], baseLhs = ref5[1], stmtLhs = ref5[2];
      if (linLhs === false) {
        ref6 = linearizedForConstruction(tree.rhs, ctx), linRhs = ref6[0], baseRhs = ref6[1], stmtRhs = ref6[2];
        if (linRhs === false) {
          tree._linearization = false;
          return [false, baseRhs, void 0];
        }
        tree._linearization = tree._linearization.concat(linRhs);
        tree._statements = tree._statements.concat(stmtRhs);
      } else {
        tree._linearization = tree._linearization.concat(linLhs);
        tree._statements = tree._statements.concat(stmtLhs);
      }
    } else if (tree.type === "NOTHING") {
      tree._linearization = false;
      return [false, tree, void 0];
    } else if (tree.type === "STATEMENTS") {
      tree._linearization.push(tree);
      tree._statements.push(tree);
    } else if (tree.type === "ANY") {

    } else {
      throw new Error("Internal compiler error: Expected a type tree in linearizedForConstruction, got " + tree.type + " tree");
    }
    return [tree._linearization, void 0, tree._statements];
  };


  /* LAZY INFO FUNCTIONS ... TODO: Do we really need these? */

  doTypeCompleters = function(tree, ctx) {
    var j, len, ref, results, st;
    tree.ctx = ctx;
    if (tree.type === "STATEMENTS") {
      ref = tree.statements;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        results.push(doStatementCompleters(st, tree.ctx));
      }
      return results;
    } else if (tree.type === "ID") {

    } else if (tree.type === "TYPE-SELECT") {
      return doTermCompleters(tree.prefix, ctx);
    } else if (tree.type === "AND-TYPE" || tree.type === "OR-TYPE") {
      doTypeCompleters(tree.lhs, ctx);
      return doTypeCompleters(tree.rhs, ctx);
    } else {
      throw new Error("Unexpected " + tree.type + " tree in doTypeCompleters");
    }
  };

  doTermCompleters = function(tree, ctx) {
    if (tree.type === "id") {
      return tree.info = function() {
        return requireMemberInContext(tree.match, ctx, tree);
      };
    } else if (tree.type === "TERM-SELECT") {
      tree.info = function() {
        return requireMemberInType(tree.id, tree.prefix.info(), ctx, tree);
      };
      return doTermCompleters(tree.prefix, ctx);
    } else if (tree.type === "CONSTRUCT") {
      ctx = ctx.fresh(tree.typTree);
      tree.info = function() {
        return tree.typTree;
      };
      return doTypeCompleters(tree.typTree, ctx);
    } else {
      throw new Error("Unexpected " + tree.type + " tree in doTermCompleters");
    }
  };

  doStatementCompleters = function(tree, ctx) {
    if (tree.type === "TERM-DECL") {
      return doTypeCompleters(tree.rhs, ctx);
    } else if (tree.type === "TYPE-DECL") {
      doTypeCompleters(tree.rhsLower, ctx.fresh(tree.rhsLower));
      return doTypeCompleters(tree.rhsUpper, ctx.fresh(tree.rhsUpper));
    } else if (tree.type === "TYPE-ASSIGN") {
      doTypeCompleters(tree.lhs, ctx);
      return doTypeCompleters(tree.rhs, ctx);
    } else if (tree.type === "TERM-ASSIGN") {
      doTermCompleters(tree.lhs, ctx);
      return doTermCompleters(tree.rhs, ctx);
    } else {
      return doTermCompleters(tree, ctx);
    }
  };


  /* TYPE COMPARISONS */

  isSubType = function(t0, t1) {
    var t0ctx, t1ctx;
    log(stderr, "\t" + (t0.stringify(1)) + " <:? " + (t1.stringify(1)));
    if (t0 === t1) {
      return true;
    } else if (t0 === Nothing) {
      return true;
    } else if (t1 === Any) {
      return true;
    } else if (t1.type === "ID") {
      if (t0.type === "ID" && t0.match === t1.match) {
        t0ctx = requireDefContext(t0.match, t0.ctx, t0);
        t1ctx = requireDefContext(t1.match, t1.ctx, t1);
        if (t0ctx === t1ctx) {
          return true;
        }
      }
    } else {
      return false;
    }
  };

  requireCompatibility = function(t0, t1, whereTree) {
    if (isSubType(t0, t1)) {
      return true;
    } else {
      throw new Error("Type error: expected: " + (t1.stringify(0)) + "\n\tGot: " + (t0.stringify(0)) + "\n\tOn line " + whereTree.line + " character " + whereTree.column);
    }
  };


  /* CODEGEN */

  gen = function(tree, ctx, indent, output) {
    var baseWithProblem, bases, defCtx, j, k, len, len1, prefixCtx, prefixType, ref, ref1, ref2, ref3, ref4, ref5, results, st;
    if (tree.type === "STATEMENTS") {
      ref = tree.statements;
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        if (st.type === "TYPE-DECL") {
          ref1 = linearizedForConstruction(st.rhsLower, ctx), bases = ref1[0], baseWithProblem = ref1[1];
          if (bases) {
            output.push(tabs(indent));
            defCtx = requireDefContext(st.lhs.match, ctx, tree);
            output.push("if(!" + defCtx.name + "." + st.lhs.match + "){");
            output.push(defCtx.name + "." + st.lhs.match);
            output.push(" = ");
            genInitializer(bases, st.rhsLower.ctx, ctx, indent, output);
            output.push(";}\n");
          }
        }
      }
      ref2 = tree.statements;
      results = [];
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        st = ref2[k];
        if (st.type === "TERM-ASSIGN") {
          output.push(tabs(indent));
          if (st.guard) {
            output.push("if(");
            gen(st.guard.condition, ctx, indent, output);
            output.push("){ ");
          }
          gen(st.lhs, ctx, indent, output);
          output.push(" = ");
          gen(st.rhs, ctx, indent, output);
          if (st.guard) {
            output.push(" }");
          }
          results.push(output.push(";\n"));
        } else if ((ref3 = st.type) === "id" || ref3 === "TERM-SELECT" || ref3 === "CONSTRUCT") {
          output.push(tabs(indent));
          if (st.guard) {
            output.push("if(");
            gen(st.guard.condition, ctx, indent, output);
            output.push("){ ");
          }
          gen(st, ctx, indent, output);
          if (st.guard) {
            output.push(" }");
          }
          results.push(output.push(";\n"));
        } else {
          if (st.guard) {
            throw new Error("Unexpected guard on " + st.type + " statement on line " + st.guard.line);
          } else {
            results.push(void 0);
          }
        }
      }
      return results;
    } else if (tree.type === "CONSTRUCT") {
      ref4 = linearizedForConstruction(tree.typTree, ctx), bases = ref4[0], baseWithProblem = ref4[1];
      if (bases === false) {
        throw new Error("Cannot construct the object at line " + tree.line + " character " + tree.column + " because base type '" + (baseWithProblem.stringify(0)) + "' is non-constructible.");
      }
      return genConstructor(bases, tree.typTree.ctx, ctx, indent, output);
    } else if (tree.type === "id") {
      if (tree.match === "???") {
        return output.push("(function(){ throw new Error('Not Implemented'); })()");
      } else {
        defCtx = requireDefContext(tree.match, ctx, tree);
        return output.push(defCtx.name + "." + tree.match);
      }
    } else if (tree.type === "TERM-SELECT") {
      ref5 = widen(tree.prefix, ctx), prefixCtx = ref5[0], prefixType = ref5[1];
      requireMemberInType(tree.id, prefixType, prefixCtx, tree);
      gen(tree.prefix, ctx, indent, output);
      output.push(".");
      return output.push(tree.id);
    }
  };

  genInitializer = function(bases, ctx, outer, indent, output) {
    var base, defCtx, j, len;
    output.push("function(" + ctx.name + "){\n");
    for (j = 0, len = bases.length; j < len; j++) {
      base = bases[j];
      if (base.type === "STATEMENTS") {
        gen(base, ctx, indent + 1, output);
      } else if (base.type === "ID") {
        defCtx = requireDefContext(base.match, outer, base);
        output.push(tabs(indent + 1));
        output.push(defCtx.name + "." + base.match + "(" + ctx.name + ");\n");
      } else if (base.type === "TYPE-SELECT") {
        output.push(tabs(indent + 1));
        gen(base.prefix, outer, indent + 1, output);
        output.push("." + base.ID + "(" + ctx.name + ");\n");
      } else if (base.type === "ANY") {

      } else {
        throw new Error("Internal compiler error: Unexpected base type tree " + base.type + " in genConstructor. Line " + tree.line + " character " + tree.column);
      }
    }
    output.push(tabs(indent + 1));
    output.push("return " + ctx.name + ";\n");
    output.push(tabs(indent));
    return output.push("}");
  };

  genConstructor = function(bases, ctx, outer, indent, output) {
    var base, defCtx, j, len;
    output.push("(function(" + ctx.name + "){\n");
    for (j = 0, len = bases.length; j < len; j++) {
      base = bases[j];
      if (base.type === "STATEMENTS") {
        gen(base, ctx, indent + 1, output);
      } else if (base.type === "ID") {
        if (base.match !== "Any") {
          defCtx = requireDefContext(base.match, outer, base);
          output.push(tabs(indent + 1));
          output.push(defCtx.name + "." + base.match + "(" + ctx.name + ");\n");
        }
      } else if (base.type === "TYPE-SELECT") {
        output.push(tabs(indent + 1));
        gen(base.prefix, outer, indent + 1, output);
        output.push("." + base.ID + "(" + ctx.name + ");\n");
      } else if (base.type === "ANY") {

      } else {
        throw new Error("Internal compiler error: Unexpected base type tree " + base.type + " in genConstructor. Line " + tree.line + " character " + tree.column);
      }
    }
    output.push(tabs(indent + 1));
    output.push("return " + ctx.name + ";\n");
    output.push(tabs(indent));
    return output.push("})({})");
  };


  /* PARSER */

  Token = function(tokType, text, line, column) {
    var tk;
    tk = {
      type: tokType,
      match: text,
      line: line,
      column: column,
      isToken: true
    };
    tk.stringify = function() {
      return tk.match.replace('\n', '\\n');
    };
    tk.print = function() {
      return tk.type + ", \"" + (tk.match.replace('\n', '\\n')) + "\", line " + tk.line + ", character " + tk.column;
    };
    return tk;
  };

  TypeDecl = function(lhs, rhsLower, rhsUpper) {
    var t;
    t = {
      type: "TYPE-DECL",
      alttypes: ["STATEMENT"],
      lhs: lhs,
      rhsLower: rhsLower,
      rhsUpper: rhsUpper,
      line: lhs.line,
      column: lhs.column
    };
    t.stringify = function(indent) {
      return t.lhs.stringify(indent) + ": at most " + t.rhsUpper.stringify(indent) + " at least " + t.rhsLower.stringify(indent);
    };
    t.subtrees = function() {
      return [t.lhs, t.rhsLower, t.rhsUpper];
    };
    return t;
  };

  TermDecl = function(lhs, rhs) {
    var t;
    t = {
      type: "TERM-DECL",
      alttypes: ["STATEMENT"],
      lhs: lhs,
      rhs: rhs,
      line: lhs.line,
      column: lhs.column
    };
    t.stringify = function(indent) {
      return t.lhs.stringify(indent) + ": " + t.rhs.stringify(indent);
    };
    t.subtrees = function() {
      return [t.lhs, t.rhs];
    };
    return t;
  };

  WithGuard = function(guard, statement) {
    var prevStringify, prevSubtrees;
    statement.guard = guard;
    prevStringify = statement.stringify;
    statement.stringify = function(indent) {
      return guard.stringify(indent) + prevStringify(indent);
    };
    prevSubtrees = statement.subtrees;
    statement.subtrees = function() {
      return [statement.guard].concat(prevSubtrees());
    };
    return statement;
  };

  parse = function(tokens) {
    var begin, expected, fromTopOfStack, i, matches, reduce, shift, showTypes, stack, stack_contents, t, unreducedTokenCount;
    stack = [];
    unreducedTokenCount = function() {
      var i, j, ref;
      for (i = j = 1, ref = stack.length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        if (!stack[stack.length - i].isToken) {
          return i - 1;
        }
      }
      return stack.length;
    };
    matches = function(types, skip) {
      var elem, i, j, ref, ref1;
      if (skip == null) {
        skip = 0;
      }
      if (types.length <= stack.length - skip) {
        for (i = j = 0, ref = types.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          if (types[i] !== "*") {
            elem = stack[stack.length - types.length + i - skip];
            if (elem.type !== types[i] && !(elem.alttypes && (ref1 = types[i], indexOf.call(elem.alttypes, ref1) >= 0))) {
              return false;
            }
          }
        }
        return true;
      } else {
        return false;
      }
    };
    fromTopOfStack = function(i) {
      if (i == null) {
        i = 0;
      }
      if (i > stack.length - 1) {
        return void 0;
      } else {
        return stack[stack.length - 1 - i];
      }
    };
    shift = function() {
      var t;
      t = tokens.shift();
      if (t.type === "id") {
        t.alttypes = ["TERM"];
      }
      if (t.type === "ID") {
        t.alttypes = ["TYPE"];
      }
      return stack.push(t);
    };
    expected = function(description) {
      var t, value;
      if (stack.length > 0) {
        t = stack[stack.length - 1];
        value = t.isToken ? t.match.replace('\n', '\\n') : t.stringify(0);
        throw "Parse error on line " + t.line + " character " + t.column + " : Expected " + description + "; got " + t.type + " with value \"" + value + "\"";
      } else {
        throw "Parse error with empty stack: Expected " + description;
      }
    };
    reduce = function() {

      /* Handle Comments */
      var ID, _typTree, a, b, condition, construct, guard, id, lhs, lparen, nl, nw, prefix, prevStringify, prevSubtrees, rhs, rhsLower, rhsUpper, statement, stmt, stmts, t, term;
      if (matches(["COMMENT"])) {
        stack.pop();
        return true;
      }
      if (matches(["START-BLOCK-COMMENT", "END-BLOCK-COMMENT"])) {
        stack.pop();
        stack.pop();
        return true;
      }
      if (matches(["START-BLOCK-COMMENT", "START-BLOCK-COMMENT"])) {
        return false;
      }
      if (matches(["START-BLOCK-COMMENT", "*"])) {
        stack.pop();
        return true;
      }

      /* Recognize ids that are really keywords */
      if (matches(["id"])) {
        if (fromTopOfStack(0).match === "new") {
          fromTopOfStack(0).type = "NEW";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "if") {
          fromTopOfStack(0).type = "IF";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "then") {
          fromTopOfStack(0).type = "THEN";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "outer") {
          fromTopOfStack(0).type = "OUTER";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
      }
      if (matches(["id", "id"])) {
        a = fromTopOfStack(1);
        b = fromTopOfStack(0);
        if (a.match === "at" && b.match === "least") {
          stack.pop();
          a.type = "ATLEAST";
          a.match = a.match + " " + b.match;
          a.alttypes = void 0;
          return true;
        }
        if (a.match === "at" && b.match === "most") {
          stack.pop();
          a.type = "ATMOST";
          a.match = a.match + " " + b.match;
          a.alttypes = void 0;
          return true;
        }
      }

      /* Selections */
      if (matches(["IF", "TERM", "THEN"])) {
        stack.pop();
        condition = stack.pop();
        stack.pop();
        guard = {
          type: "GUARD",
          condition: condition,
          line: condition.line,
          column: condition.column
        };
        guard.stringify = function(indent) {
          return "if " + (guard.condition.stringify(indent)) + " then ";
        };
        guard.subtrees = function() {
          return [guard.condition];
        };
        stack.push(guard);
        return true;
      }
      if (matches(["GUARD", "STATEMENT"])) {
        statement = stack.pop();
        guard = stack.pop();
        stack.push(WithGuard(guard, statement));
        return true;
      }
      if (matches(["GUARD", "*", "NEWLINE"])) {
        nl = stack.pop();
        term = stack.pop();
        guard = stack.pop();
        stack.push(WithGuard(guard, term));
        stack.push(nl);
        return true;
      }
      if (matches(["TERM", "DOT", "id"])) {
        id = stack.pop();
        stack.pop();
        prefix = stack.pop();
        t = {
          type: "TERM-SELECT",
          alttypes: ["TERM"],
          prefix: prefix,
          id: id.match,
          line: id.line,
          column: id.column
        };
        t.stringify = function(indent) {
          return t.prefix.stringify(indent) + ("." + t.id);
        };
        t.subtrees = function() {
          return [t.prefix];
        };
        stack.push(t);
        return true;
      }
      if (matches(["TERM", "DOT", "ID"])) {
        ID = stack.pop();
        stack.pop();
        prefix = stack.pop();
        t = {
          type: "TYPE-SELECT",
          alttypes: ["TYPE"],
          prefix: prefix,
          ID: ID.match,
          line: ID.line,
          column: ID.column
        };
        t.stringify = function(indent) {
          return t.prefix.stringify(indent) + ("." + t.ID);
        };
        t.subtrees = function() {
          return [t.prefix];
        };
        stack.push(t);
        return true;
      }
      if (matches(["ID", "COLON", "*", "*", "*", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["ATMOST", "TYPE", "ATLEAST", "TYPE"])) {
          rhsLower = stack.pop();
          stack.pop();
          rhsUpper = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        } else if (matches(["ATLEAST", "TYPE", "ATMOST", "TYPE"])) {
          rhsUpper = stack.pop();
          stack.pop();
          rhsLower = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        }
      }
      if (matches(["ID", "COLON", "*", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["ATMOST", "TYPE"])) {
          rhsUpper = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          rhsLower = Token("ID", "Nothing", rhsUpper.line, rhsUpper.column);
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        } else if (matches(["ATLEAST", "TYPE"])) {
          rhsLower = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          rhsUpper = Token("ID", "Any", rhsLower.line, rhsLower.column);
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        }
      }
      if (matches(["ID", "COLON", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhs, rhs));
          return true;
        } else {
          expected("TYPE in declaration of " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["id", "COLON", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TermDecl(lhs, rhs));
          return true;
        } else {
          expected("TYPE in declaration of " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["ID", "EQUALS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TYPE-ASSIGN",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhs: rhs,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + " = " + t.rhs.stringify(indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhs];
          };
          stack.push(t);
          return true;
        } else {
          expected("TYPE in assignment to " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["id", "EQUALS", "*", "NEWLINE"]) || matches(["TERM-SELECT", "EQUALS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TERM"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TERM-ASSIGN",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhs: rhs,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + " = " + t.rhs.stringify(indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhs];
          };
          stack.push(t);
          return true;
        } else {
          expected("TERM in assignment to " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["TYPE", "AND", "TYPE"])) {
        rhs = stack.pop();
        stack.pop();
        lhs = stack.pop();
        t = {
          type: "AND-TYPE",
          alttypes: ["TYPE"],
          lhs: lhs,
          rhs: rhs,
          line: lhs.line,
          column: lhs.column
        };
        t.stringify = function(indent) {
          return t.lhs.stringify(indent) + " & " + t.rhs.stringify(indent);
        };
        t.subtrees = function() {
          return [t.lhs, t.rhs];
        };
        stack.push(t);
        return true;
      }
      if (matches(["TYPE", "OR", "TYPE"])) {
        rhs = stack.pop();
        stack.pop();
        lhs = stack.pop();
        t = {
          type: "OR-TYPE",
          alttypes: ["TYPE"],
          lhs: lhs,
          rhs: rhs,
          line: lhs.line,
          column: lhs.column
        };
        t.stringify = function(indent) {
          return t.lhs.stringify(indent) + " | " + t.rhs.stringify(indent);
        };
        t.subtrees = function() {
          return [t.lhs, t.rhs];
        };
        stack.push(t);
        return true;
      }
      if (matches(["AT", "id", "TYPE"])) {
        t = stack.pop();
        id = stack.pop();
        stack.pop();
        if (t.annots) {
          t.annots.push(id);
        } else {
          t.annots = [id];
        }
        prevStringify = t.stringify;
        prevSubtrees = t.subtrees;
        t.stringify = function(indent) {
          return "@" + t.id.match + " " + prevStringify(indent);
        };
        t.subtrees = function() {
          return prevSubtrees().concat([t.typ]);
        };
        stack.push(t);
        return true;
      }
      if (matches(["STATEMENTS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TERM"])) {
          stmt = stack.pop();
          stmts = stack.pop();
          stmts.statements.push(stmt);
          stmts.line = stmt.line;
          stmts.column = stmt.column;
          stack.push(stmts);
          return true;
        } else {
          expected("STATEMENT");
        }
      }
      if (matches(["STATEMENTS", "STATEMENT"])) {
        stmt = stack.pop();
        stmts = stack.pop();
        stmts.statements.push(stmt);
        stmts.line = stmt.line;
        stmts.column = stmt.column;
        stack.push(stmts);
        return true;
      }
      if (matches(["LBRACE"])) {
        lparen = fromTopOfStack();
        begin(lparen.line, lparen.column);
        return true;
      }
      if (matches(["LBRACE", "STATEMENTS", "RBRACE"])) {
        stack.pop();
        stmts = stack.pop();
        stack.pop();
        stack.push(stmts);
        return true;
      }
      if (matches(["*", "DOT", "NEW"])) {
        nw = stack.pop();
        stack.pop();
        if (matches(["TYPE"])) {
          _typTree = stack.pop();
          construct = {
            type: "CONSTRUCT",
            alttypes: ["TERM"],
            typTree: _typTree,
            line: nw.line,
            column: nw.column
          };
          construct.stringify = function(indent) {
            return (construct.typTree.stringify(indent)) + ".new";
          };
          construct.subtrees = function() {
            return [construct.typTree];
          };
          stack.push(construct);
          return true;
        } else {
          throw new Error("Expected type in object construction on line " + nw.line + " character " + nw.column + ", got " + (fromTopOfStack(0).stringify(0)));
        }
      }
      if (matches(["STATEMENTS", "NEWLINE"])) {
        stack.pop();
        return true;
      }
    };
    begin = function(ln, col) {
      var stmts;
      stmts = {
        type: "STATEMENTS",
        alttypes: ["TYPE"],
        statements: [],
        line: ln,
        column: col
      };
      stmts.stringify = function(indent) {
        var stmt;
        return "{\n" + ((function() {
          var j, len, ref, results;
          ref = stmts.statements;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            stmt = ref[j];
            results.push(tabs(indent + 1) + stmt.stringify(indent + 1) + "\n");
          }
          return results;
        })()).join("") + tabs(indent) + "}";
      };
      stmts.subtrees = function() {
        return stmts.statements;
      };
      stmts.print = stmts.stringify;
      return stack.push(stmts);
    };
    showTypes = function(t) {
      var s, typ;
      s = t.type;
      if (t.alttypes) {
        s = s + " & " + ((function() {
          var j, len, ref, results;
          ref = t.alttypes;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            typ = ref[j];
            results.push(typ);
          }
          return results;
        })()).join(" & ");
      }
      return s;
    };
    begin(1, 1);
    while (true) {
      while (reduce()) {
        true;
      }
      if (tokens[0].type === "EOF" || unreducedTokenCount() >= 8) {
        break;
      }
      shift();
    }
    if (stack.length !== 1) {
      i = -1;
      stack_contents = ((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = stack.length; j < len; j++) {
          t = stack[j];
          i += 1;
          results.push("Item " + i + ": " + (showTypes(t)) + "\n" + (t.stringify(0)));
        }
        return results;
      })()).join("\n\n");
      throw "Parse error: Unreduced items on stack at End-of-Input. Stack contents:\n\n" + stack_contents;
    }
    return stack[0];
  };

  tokenize = function(input) {
    var Whitespace, column, consumeNextToken, getNextToken, line, t, tk, tokenList, tokens;
    line = 1;
    column = 1;
    tokenList = [
      {
        name: "id",
        regex: /^([a-z][a-zA-z0-9_]*|\?\?\?)/
      }, {
        name: "ID",
        regex: /^[A-Z][a-zA-z0-9_]*/
      }, {
        name: "NEWLINE",
        regex: /^(\n|\r\n|\r)/
      }, {
        name: "COMMENT",
        regex: /^\/\/.*/
      }, {
        name: "START-BLOCK-COMMENT",
        regex: /^\/\*/
      }, {
        name: "END-BLOCK-COMMENT",
        regex: /^\*\//
      }, {
        name: "DOT",
        regex: /^\./
      }, {
        name: "AND",
        regex: /^&/
      }, {
        name: "OR",
        regex: /^\|/
      }, {
        name: "AT",
        regex: /^@/
      }, {
        name: "EQUALS",
        regex: /^=/
      }, {
        name: "LPAREN",
        regex: /^\(/
      }, {
        name: "RPAREN",
        regex: /^\)/
      }, {
        name: "LBRACE",
        regex: /^{/
      }, {
        name: "RBRACE",
        regex: /^}/
      }, {
        name: "COLON",
        regex: /^:/
      }, {
        name: "SEMI",
        regex: /^;/
      }, {
        name: "EOF",
        regex: /^$/
      }
    ];
    Whitespace = {
      name: "SPACE",
      regex: /^[\t \v\f]+/
    };
    getNextToken = function() {
      var j, len, length, matches, tok;
      matches = Whitespace.regex.exec(input);
      if (matches) {
        input = input.substring(matches[0].length);
        column += matches[0].length;
      }
      for (j = 0, len = tokenList.length; j < len; j++) {
        tok = tokenList[j];
        matches = tok.regex.exec(input);
        if (matches) {
          return Token(tok.name, matches[0], line, column);
        }
      }
      length = input.indexOf('\n');
      if (length <= 0) {
        length = input.length;
      }
      throw "Tokenization error on line " + line + " character " + column + " : Unable to match a token starting at '" + (input.substring(0, length)) + "'";
    };
    consumeNextToken = function() {
      var tok;
      tok = getNextToken();
      input = input.substring(tok.match.length);
      column += tok.match.length;
      if (tok.type === "NEWLINE") {
        column = 1;
        line += 1;
      }
      return tok;
    };
    tokens = [];
    while (true) {
      t = consumeNextToken();
      if (t.type === "RBRACE" || t.type === "EOF") {
        tk = Token("NEWLINE", "\n", t.line, t.column);
        tk.stringify = function() {
          return "(synthetic \\n)";
        };
        tk.print = function() {
          return "synthetic NEWLINE on line " + t.line + ", char " + t.column;
        };
        tokens.push(tk);
      }
      tokens.push(t);
      if (t.type === "EOF") {
        break;
      }
    }
    return tokens;
  };

  tabs = function(indent) {
    return "\t".repeat(indent);
  };

}).call(this);
