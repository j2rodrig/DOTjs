// Generated by CoffeeScript 1.10.0
(function() {
  var AndType, Any, HasAnnotation, Nothing, OrType, TermDecl, Token, TypeDecl, WithAnnotation, WithGuard, asConstructed, channels, clearLog, condenseBasesForConstruction, containsBase, contextify, createPredefTree, deepCopyTree, derivedAndOrType, derivedAssignment, derivedConstruction, derivedGuard, derivedNameSelect, derivedTermDecl, derivedTypeDecl, findMember, fullyInlined, gen, genBaseCalls, genCtor, genProgram, genTypeInitializer, isDefinedInSameContext, isSameReference, isSubType, log, maybeGenGuard, parse, replaceSelfWithPrefix, requireCompatibility, requireMember, requireTermCompatibility, shallowCopyTree, stderr, stringifyStatements, tabs, tokenize, types,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.compile = function(input, stopAfter) {
    var allOutput, ast, enclosing, error, error1, fresh, message, output, tok, tokens;
    try {
      clearLog();
      tokens = tokenize(input);
      if (stopAfter === "tokens") {
        return ((function() {
          var j, len, results;
          results = [];
          for (j = 0, len = tokens.length; j < len; j++) {
            tok = tokens[j];
            results.push(tok.print());
          }
          return results;
        })()).join('\n');
      }
      ast = parse(tokens);
      if (stopAfter === "trees") {
        return ast.stringify(0);
      }
      enclosing = createPredefTree();
      fresh = ast;
      contextify(ast, enclosing, fresh);
      output = genProgram(ast);

      /*
      		predefCtx = createPredefContext()   # create a context for predefined types
      		doTypeCompleters(ast, predefCtx.fresh(ast))   # generate subcontexts and info() functions
      
      		outputBuffer = []
      		[bases, ignore] = linearizedForConstruction(ast, predefCtx)
      		genConstructor(bases, ast.ctx, predefCtx, 0, outputBuffer)
      		outputBuffer.push(";")
      		output = outputBuffer.join("")
       */
      allOutput = [output];
      if (channels[types]) {
        allOutput.push("/** Types log:\n\n" + channels[types].join("\n") + "\n**/");
      }
      if (channels[stderr]) {
        allOutput.push("/** Stderr log:\n\n" + channels[stderr].join("\n") + "\n**/");
      }
      return allOutput.join("\n\n");
    } catch (error1) {
      error = error1;
      message = error.message != null ? error.message : error;
      message = message.toUpperCase().startsWith("ERROR") || message.toUpperCase().startsWith("INTERNAL COMPILER ERROR") ? message : "Error: " + message;
      output = [message];
      if (channels[types]) {
        output.push("Types log:\n\n" + channels[types].join("\n"));
      }
      if (channels[stderr]) {
        output.push("Stderr log:\n\n" + channels[stderr].join("\n"));
      }
      if (error.stack != null) {
        output.push("COMPILER STACKTRACE:\n" + error.stack);
      }
      return output.join("\n\n");
    }
  };

  channels = {};

  stderr = "stderr";

  types = "types";

  clearLog = function() {
    return channels = {};
  };

  log = function(ch, msg) {
    if (!channels[ch]) {
      return channels[ch] = [msg];
    } else {
      return channels[ch].push(msg);
    }
  };

  Any = {
    type: "ANY",
    stringify: function(indent) {
      return "Any";
    }
  };

  Nothing = {
    type: "NOTHING",
    stringify: function(indent) {
      return "Nothing";
    }
  };

  AndType = function(lhsTyp, rhsTyp) {
    return {
      type: "AND-TYPE",
      lhs: lhsTyp,
      rhs: rhsTyp,
      stringify: function(indent) {
        return lhsTyp.stringify(indent) + " & " + rhsTyp.stringify(indent);
      }
    };
  };

  OrType = function(lhsTyp, rhsTyp) {
    return {
      type: "OR-TYPE",
      lhs: lhsTyp,
      rhs: rhsTyp,
      stringify: function(indent) {
        return lhsTyp.stringify(indent) + " | " + rhsTyp.stringify(indent);
      }
    };
  };


  /* TYPE OPERATIONS */

  shallowCopyTree = function(t) {
    return {
      type: t.type,
      ctx: t.ctx,
      line: t.line,
      column: t.column,
      annots: t.annots
    };
  };

  derivedNameSelect = function(t, prefix) {
    var t1;
    if (prefix === t.prefix) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.id = t.id;
      t1.ID = t.ID;
      t1.prefix = prefix;
      return t1;
    }
  };

  derivedAndOrType = function(tree, lhs, rhs) {
    if (lhs === tree.lhs && rhs === tree.rhs) {
      return tree;
    } else if (tree.type === "AND-TYPE") {
      return AndType(lhs, rhs);
    } else if (tree.type === "OR-TYPE") {
      return OrType(lhs, rhs);
    }
  };

  derivedTypeDecl = function(t, rhsUpper, rhsLower) {
    var t1;
    if (t.rhsUpper === rhsUpper && t.rhsLower === rhsLower) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.rhsUpper = rhsUpper;
      t1.rhsLower = rhsLower;
      return t1;
    }
  };

  derivedTermDecl = function(t, rhs) {
    var t1;
    if (t.rhs === rhs) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.rhs = rhs;
      return t1;
    }
  };

  derivedAssignment = function(t, guard1, lhs1, rhs1) {
    var t1;
    if (t.guard === guard1 && t.lhs === lhs1 && t.rhs === rhs1) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.guard = guard1;
      t1.lhs = lhs1;
      t1.rhs = rhs1;
      return t1;
    }
  };

  derivedGuard = function(t, condition) {
    var t1;
    if (t.condition === condition) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.condition = condition;
      return t1;
    }
  };

  derivedConstruction = function(t, guard, typTree) {
    var t1;
    if (t.typTree === typTree && t.guard === guard) {
      return t;
    } else {
      t1 = shallowCopyTree(t);
      t1.typTree = typTree;
      t1.guard = guard;
      return t1;
    }
  };

  deepCopyTree = function(t, mutator, insideStatement) {
    var anyDifferent, guard1, lhs1, prefix1, rhs, rhs1, rhsLower, rhsUpper, st, st1, stmt1, t1, typTree1;
    t1 = (function() {
      var j, len, ref;
      if (t.type === "TYPE-SELECT" || t.type === "TERM-SELECT") {
        prefix1 = deepCopyTree(t.prefix, mutator, insideStatement);
        return derivedNameSelect(t, prefix1);
      } else if (t.type === "STATEMENTS") {
        stmt1 = shallowCopyTree(t);
        stmt1.statements = [];
        anyDifferent = false;
        ref = t.statements;
        for (j = 0, len = ref.length; j < len; j++) {
          st = ref[j];
          st1 = deepCopyTree(st, mutator, true);
          if (st1 !== st) {
            anyDifferent = true;
          }
          stmt1.statements.push(st1);
        }
        stmt1.stringify = function(indent) {
          return stringifyStatements(stmt1, indent);
        };
        if (anyDifferent) {
          return stmt1;
        } else {
          return t;
        }
      } else if (t.type === "AND-TYPE" || t.type === "OR-TYPE") {
        lhs1 = deepCopyTree(t.lhs, mutator, insideStatement);
        rhs1 = deepCopyTree(t.rhs, mutator, insideStatement);
        return derivedAndOrType(t, lhs1, rhs1);
      } else if (t.type === "TYPE-DECL") {
        rhsUpper = deepCopyTree(t.rhsUpper, mutator, false);
        rhsLower = deepCopyTree(t.rhsLower, mutator, false);
        return derivedTypeDecl(t, rhsUpper, rhsLower);
      } else if (t.type === "TERM-DECL") {
        rhs = deepCopyTree(t.rhs, mutator, false);
        return derivedTermDecl(t, rhs);
      } else if (t.type === "TERM-ASSIGN") {
        guard1 = t.guard ? derivedGuard(t.guard, deepCopyTree(t.guard.condition, mutator)) : void 0;
        lhs1 = t.lhs.type === "id" ? t.lhs : deepCopyTree(t.lhs, mutator, true);
        rhs1 = deepCopyTree(t.rhs, mutator, true);
        return derivedAssignment(t, guard1, lhs1, rhs1);
      } else if (t.type === "CONSTRUCT") {
        guard1 = t.guard ? derivedGuard(t.guard, deepCopyTree(t.guard.condition, mutator)) : void 0;
        typTree1 = deepCopyTree(t.typTree, mutator, false);
        return derivedConstruction(t, guard1, typTree1);
      } else {
        return t;
      }
    })();
    return mutator(t1, insideStatement);
  };

  createPredefTree = function() {
    var predefTree;
    predefTree = {
      type: "STATEMENTS",
      statements: []
    };
    predefTree.stringify = function(indent) {
      return "{ (predefined symbols) }";
    };
    predefTree.statements.push(TypeDecl(Token("ID", "Any", void 0, void 0), Any, Any));
    predefTree.statements.push(TypeDecl(Token("ID", "Nothing", void 0, void 0), Nothing, Nothing));
    predefTree.statements.push(TermDecl(Token("ID", "???", void 0, void 0), Nothing));
    return predefTree;
  };

  findMember = function(name, typTree, lowerBound) {
    var expanded, j, len, lhsTyp, ref, rhsTyp, st;
    if (typTree.type === "STATEMENTS") {
      ref = typTree.statements;
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        if (st.type === "TYPE-DECL" && st.lhs.match === name) {
          if (lowerBound) {
            return st.rhsLower;
          } else {
            return st.rhsUpper;
          }
        } else if (st.type === "TERM-DECL" && st.lhs.match === name) {
          return st.rhs;
        }
      }
      return void 0;
    } else if (typTree.type === "ID" || typTree.type === "TYPE-SELECT") {
      expanded = requireMember(typTree, false);
      return findMember(name, expanded, lowerBound);
    } else if (typTree.type === "AND-TYPE") {
      lhsTyp = findMember(name, typTree.lhs, lowerBound);
      rhsTyp = findMember(name, typTree.rhs, lowerBound);
      if (lhsTyp && rhsTyp) {
        if (lowerBound) {
          return OrType(lhsTyp, rhsTyp);
        } else {
          return AndType(lhsTyp, rhsTyp);
        }
      } else if (lhsTyp) {
        return lhsTyp;
      } else {
        return rhsTyp;
      }
    } else if (typTree.type === "OR-TYPE") {
      lhsTyp = findMember(name, typTree.lhs, lowerBound);
      rhsTyp = findMember(name, typTree.rhs, lowerBound);
      if (lhsTyp && rhsTyp) {
        if (lowerBound) {
          return AndType(lhsTyp, rhsTyp);
        } else {
          return OrType(lhsTyp, rhsTyp);
        }
      } else {
        return void 0;
      }
    } else if (typTree.type === "CONSTRUCT") {
      return findMember(name, asConstructed(typTree.typTree));
    } else if (typTree.type === "ANY") {
      return void 0;
    } else if (typTree.type === "NOTHING") {
      throw new Error("Attempt to find member '" + name + "' in type Nothing on line " + typTree.line + " character " + typTree.column + ", which contains contradictory definitions of '" + name + "'.");
    } else {
      throw new Error("Internal compiler error: Expected a type tree in findMember(\"" + name + "\"), got '" + typTree.type + "' tree");
    }
  };

  containsBase = function(typTree, base) {
    var ref;
    if (typTree === base) {
      return true;
    } else if (typTree.type === "AND-TYPE") {
      return containsBase(typTree.lhs, base) || containsBase(typTree.rhs, base);
    } else if ((ref = typTree.type) === "STATEMENTS" || ref === "ANY" || ref === "NOTHING" || ref === "ID" || ref === "TYPE-SELECT") {
      return false;
    } else {
      throw new Error("Internal compiler error: Expected a fully-expanded type tree in containsBase, got '" + typTree.type + "' tree");
    }
  };

  condenseBasesForConstruction = function(typTree, expandName) {
    var expanded, lhsExpanded, ref;
    if ((ref = typTree.type) === "STATEMENTS" || ref === "ANY" || ref === "NOTHING") {
      return typTree;
    } else if (typTree.type === "ID" || typTree.type === "TYPE-SELECT") {
      if (expandName(typTree)) {
        expanded = requireMember(typTree, true);
        return condenseBasesForConstruction(expanded, expandName);
      } else {
        return typTree;
      }
    } else if (typTree.type === "AND-TYPE") {
      return AndType(condenseBasesForConstruction(typTree.lhs, expandName), condenseBasesForConstruction(typTree.rhs, expandName));
    } else if (typTree.type === "OR-TYPE") {
      lhsExpanded = condenseBasesForConstruction(typTree.lhs, function(t) {
        return true;
      });
      if (containsBase(lhsExpanded, Nothing)) {
        return condenseBasesForConstruction(typTree.rhs, expandName);
      } else {
        return condenseBasesForConstruction(typTree.lhs, expandName);
      }
    } else {
      throw new Error("Internal compiler error: Expected a type tree in condenseBasesForConstruction, got '" + typTree.type + "' tree");
    }
  };

  asConstructed = function(typTree) {
    if (!typTree.asConstructed) {
      typTree.asConstructed = condenseBasesForConstruction(typTree, function(t) {
        return false;
      });
    }
    return typTree.asConstructed;
  };

  fullyInlined = function(typTree) {
    if (!typTree.fullyInlined) {
      typTree.fullyInlined = condenseBasesForConstruction(typTree, function(t) {
        return true;
      });
    }
    return typTree.fullyInlined;
  };

  requireMember = function(nameTree, lowerBound) {
    var enclosing, prefixTyp, typ, typTree;
    typTree = (function() {
      if (nameTree.type === "id" || nameTree.type === "ID") {
        typ = void 0;
        enclosing = nameTree.enclosing;
        while (enclosing) {
          typ = findMember(nameTree.match, asConstructed(enclosing), lowerBound);
          if (typ) {
            nameTree.definingTree = enclosing;
            break;
          }
          enclosing = enclosing.enclosing;
        }
        return typ;
      } else if (nameTree.type === "TYPE-SELECT") {
        prefixTyp = requireMember(nameTree.prefix, false);
        typ = findMember(nameTree.ID, prefixTyp, lowerBound);
        typ = replaceSelfWithPrefix(typ, prefixTyp, nameTree.prefix);
        return typ;
      } else if (nameTree.type === "TERM-SELECT") {
        prefixTyp = requireMember(nameTree.prefix, false);
        typ = findMember(nameTree.id, prefixTyp, lowerBound);
        typ = replaceSelfWithPrefix(typ, prefixTyp, nameTree.prefix);
        return typ;
      } else if (nameTree.type === "CONSTRUCT") {
        return nameTree;
      } else {
        throw new Error("Internal compiler error: Expected name tree in requireMember, got '" + nameTree.type + "'");
      }
    })();
    if (!typTree) {
      throw new Error("Error: Unable to find type of '" + (nameTree.stringify(0)) + "' on line " + nameTree.line + " character " + nameTree.column);
    } else {
      return typTree;
    }
  };

  replaceSelfWithPrefix = function(typ, enclosing, prefix) {
    return deepCopyTree(typ, function(t) {
      var t1;
      if (t.type === "ID") {
        requireMember(t);
        if (t.definingTree === enclosing) {
          log(types, "Replacing self." + t.match + " with " + (prefix.stringify(0)) + "." + t.match + " where self:" + (enclosing.stringify(0)));
          t1 = shallowCopyTree(t);
          t1.type = "TYPE-SELECT";
          t1.ID = t.match;
          t1.prefix = prefix;
          t1.stringify = function(indent) {
            return (t1.prefix.stringify(indent)) + "." + t1.ID;
          };
          return t1;
        }
      }
      if (t.type === "id") {
        requireMember(t);
        if (t.definingTree === enclosing) {
          log(types, "Replacing self." + t.match + " with " + (prefix.stringify(0)) + "." + t.match + " where self:" + (enclosing.stringify(0)));
          t1 = shallowCopyTree(t);
          t1.type = "TERM-SELECT";
          t1.id = t.match;
          t1.prefix = prefix;
          t1.stringify = function(indent) {
            return "#" + (t1.prefix.stringify(indent)) + ".{t1.id}";
          };
          return t1;
        }
      }
      return t;
    });
  };

  contextify = function(tree, enclosingTree, freshTree) {
    var j, len, ref, results, st;
    if (tree.type === "STATEMENTS") {
      freshTree.enclosing = enclosingTree;
      enclosingTree = freshTree;
      ref = tree.statements;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        if (st.type === "TERM-DECL") {
          results.push(contextify(st.rhs, enclosingTree, st.rhs));
        } else if (st.type === "TYPE-DECL") {
          contextify(st.rhsLower, enclosingTree, st.rhsLower);
          results.push(contextify(st.rhsUpper, enclosingTree, st.rhsUpper));
        } else if (st.type === "TYPE-ASSIGN") {
          results.push(contextify(st.rhs, enclosingTree, st.rhs));
        } else if (st.type === "TERM-ASSIGN") {
          if (st.guard) {
            contextify(st.guard.condition, enclosingTree, freshTree);
          }
          contextify(st.lhs, enclosingTree, freshTree);
          results.push(contextify(st.rhs, enclosingTree, freshTree));
        } else {
          results.push(contextify(st, enclosingTree, freshTree));
        }
      }
      return results;
    } else if (tree.type === "ID" || tree.type === "id") {
      if (tree.guard) {
        contextify(tree.guard.condition, enclosingTree, freshTree);
      }
      return tree.enclosing = enclosingTree;
    } else if (tree.type === "TYPE-SELECT" || tree.type === "TERM-SELECT") {
      if (tree.guard) {
        contextify(tree.guard.condition, enclosingTree, freshTree);
      }
      return contextify(tree.prefix, enclosingTree, freshTree);
    } else if (tree.type === "AND-TYPE" || tree.type === "OR-TYPE") {
      contextify(tree.lhs, enclosingTree, freshTree);
      return contextify(tree.rhs, enclosingTree, freshTree);
    } else if (tree.type === "CONSTRUCT") {
      if (tree.guard) {
        contextify(tree.guard.condition, enclosingTree, freshTree);
      }
      return contextify(tree.typTree, enclosingTree, tree.typTree);
    } else {
      throw new Error("Internal compiler error: Unexpected '" + tree.type + "' tree in contextify");
    }
  };


  /* TYPE COMPARISONS */

  isSubType = function(t0, ctx0, t1, ctx1) {
    var j, len, member0, member0lower, member0upper, ref, ref1, ref2, ref3, ref4, st1, wctx0, wctx1, wtyp0, wtyp1;
    log(types, (t0.stringify(0)) + " <:? " + (t1.stringify(0)));
    if (t0 === t1) {
      return true;
    } else if (t0 === Nothing) {
      return true;
    } else if (t1 === Any) {
      return true;
    } else if (t0 === Any) {
      return false;
    } else if (t1 === Nothing) {
      return false;
    } else if (t1.type === "TYPE-SELECT") {
      if (t0.type === "TYPE-SELECT" && t0.ID === t1.ID && isSameReference(t0.prefix, ctx0, t1.prefix, ctx1)) {
        return true;
      } else {
        ref = widen(t1.prefix, ctx1, true), wctx1 = ref[0], wtyp1 = ref[1];
        substThis();
        return isSubType(t0, ctx0, wtyp1, wctx1);
      }
    } else if (t1.type === "ID") {
      if (t0.type === "ID" && t0.match === t1.match && isDefinedInSameContext(t0, ctx0, t1, ctx1)) {
        return true;
      } else {
        ref1 = widen(t1, ctx1, true), wctx1 = ref1[0], wtyp1 = ref1[1];
        return isSubType(t0, ctx0, wtyp1, wctx1);
      }
    } else if (t1.type === "AND-TYPE") {
      return isSubType(t0, ctx0, t1.lhs, ctx1) && isSubType(t0, ctx0, t1.rhs, ctx1);
    } else if (t1.type === "OR-TYPE") {
      return isSubType(t0, ctx0, t1.lhs, ctx1) || isSubType(t0, ctx0, t1.rhs, ctx1);
    } else if (t0.type === "ID") {
      ref2 = widen(t0, ctx0, false), wctx0 = ref2[0], wtyp0 = ref2[1];
      return isSubType(wtyp0, wctx0, t1, ctx1);
    } else if (t0.type === "TYPE-SELECT") {
      ref3 = widen(t0, ctx0, false), wctx0 = ref3[0], wtyp0 = ref3[1];
      return isSubType(wtyp0, wctx0, t1, ctx1);
    } else if (t0.type === "AND-TYPE") {
      return isSubType(t0.lhs, ctx0, t1, ctx1) || isSubType(t0.rhs, ctx0, t1, ctx1);
    } else if (t0.type === "OR-TYPE") {
      return isSubType(t0.lhs, ctx0, t1, ctx1) && isSubType(t0.rhs, ctx0, t1, ctx1);
    } else if (!(t0.type === "STATEMENTS" && t1.type === "STATEMENTS")) {
      throw new Error("Internal compiler error: Expected types in isSubType, but attempted to compare a " + t0.type + " tree with a " + t1.type + " tree");
    } else {
      ref4 = t1.statements;
      for (j = 0, len = ref4.length; j < len; j++) {
        st1 = ref4[j];
        if (st1.type === "TYPE-DECL") {
          member0upper = findMember(st1.lhs, t0, ctx0, false);
          if (!member0upper) {
            log(types, "Failure to find member " + st.lhs + " in type " + t0);
            return false;
          }
          if (!isSubType(member0upper, ctx0, st1.rhsUpper, ctx1)) {
            log(types, member0upper + ", the upper bound of " + st1.lhs + " in " + t0 + ", is not compatible with " + st1.rhsUpper);
            return false;
          }
          member0lower = findMember(st1.lhs, t0, ctx0, true);
          if (!isSubType(st1.rhsLower, ctx1, member0lower, ctx0)) {
            log(types, st1.rhsLower + " is not compatible with " + member0lower + ", the lower bound of " + st1.lhs + " in " + t0);
            return false;
          }
        } else if (st1.type === "TERM-DECL") {
          member0 = findMember(st1.lhs, t0, ctx0, false);
          if (!member0) {
            log(types, "Failure to find member " + st1.lhs + " in type " + t0);
            return false;
          }
          if (!isSubType(member0, ctx0, st1.rhs, ctx1)) {
            log(types, "Type " + member0 + " declared for field " + st1.lhs + " is not compatible with type " + st1.rhs);
            return false;
          }
          if (!isSubType(st1.rhs, ctx1, member0, ctx0)) {
            log(types, "Type " + st1.rhs + " declared for field " + st1.lhs + " is not compatible with type " + member0);
            return false;
          }
        }
      }
      return true;
    }
  };

  isSameReference = function(tree0, ctx0, tree1, ctx1) {
    if (tree0.type === "id") {
      return tree1.type === "id" && tree0.match === tree1.match && isDefinedInSameContext(tree0, ctx0, tree1, ctx1);
    } else if (tree0.type === "TERM-SELECT") {
      return tree1.type === "TERM-SELECT" && tree0.id === tree1.id && isSameReference(tree0.prefix, ctx0, tree1.prefix, ctx1);
    } else {
      return false;
    }
  };

  isDefinedInSameContext = function(tree0, ctx0, tree1, ctx1) {
    return requireDefContext(tree0.match, ctx0, tree0) === requireDefContext(tree1.match, ctx1, tree1);
  };

  requireCompatibility = function(t0, ctx0, t1, ctx1, whereTree) {
    if (isSubType(t0, ctx0, t1, ctx1)) {
      return true;
    } else {
      throw new Error("Type error: expected: " + (t1.stringify(0)) + "\n\tGot: " + (t0.stringify(0)) + "\n\tOn line " + whereTree.line + " character " + whereTree.column);
    }
  };

  requireTermCompatibility = function(tree0, tree1, ctx) {
    var ctx0, ctx1, ref, ref1, ref2, ref3, t0, t1;
    if (!((ref = tree0.type) === "id" || ref === "TERM-SELECT" || ref === "CONSTRUCT")) {
      throw new Error("Internal compiler error: Expected term in requireTermCompatibility, got " + tree0.type);
    }
    if (!((ref1 = tree1.type) === "id" || ref1 === "TERM-SELECT" || ref1 === "CONSTRUCT")) {
      throw new Error("Internal compiler error: Expected term in requireTermCompatibility, got " + tree1.type);
    }
    ref2 = widen(tree0, ctx, false), ctx0 = ref2[0], t0 = ref2[1];
    ref3 = widen(tree1, ctx, false), ctx1 = ref3[0], t1 = ref3[1];
    requireCompatibility(t0, ctx0, t1, ctx1, tree1);
    return log(types, "Successfully compared type " + (t0.stringify(0)) + " to " + (t1.stringify(0)) + " on line " + tree1.line);
  };


  /* CODEGEN */

  genProgram = function(ast) {
    var getId, output, uniqueId;
    uniqueId = -1;
    getId = function() {
      uniqueId += 1;
      return uniqueId;
    };
    output = [];
    genCtor(ast, true, getId, 0, output);
    output.push(";");
    return output.join("");
  };

  genBaseCalls = function(base, fresh, getId, indent, output) {
    var j, k, len, len1, ref, ref1, ref2, results, selfName, st;
    if (base.type === "STATEMENTS") {
      ref = base.statements;
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        if (st.type === "TYPE-DECL") {
          genTypeInitializer(fresh, st.lhs.match, st.rhsLower, getId, indent + 1, output);
        }
      }
      ref1 = base.statements;
      results = [];
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        st = ref1[k];
        if (st.type === "TERM-ASSIGN") {
          output.push(tabs(indent + 1));
          maybeGenGuard(st, getId, indent + 1, output);
          gen(st.lhs, getId, indent + 1, output);
          output.push(" = ");
          gen(st.rhs, getId, indent + 1, output);
          results.push(output.push(";\n"));
        } else if ((ref2 = st.type) === "id" || ref2 === "TERM-SELECT" || ref2 === "CONSTRUCT") {
          output.push(tabs(indent + 1));
          maybeGenGuard(st, getId, indent + 1, output);
          gen(st, getId, indent + 1, output);
          results.push(output.push(";\n"));
        } else {
          results.push(void 0);
        }
      }
      return results;
    } else if (base.type === "ID") {
      if (base.match !== "Any") {
        requireMember(base, true);
        selfName = base.definingTree.selfName;
        output.push(tabs(indent + 1));
        return output.push(selfName + "." + base.match + "(" + fresh.selfName + ");\n");
      }
    } else if (base.type === "TYPE-SELECT") {
      output.push(tabs(indent + 1));
      gen(base.prefix, getId, indent + 1, output);
      return output.push("." + base.ID + "(" + fresh.selfName + ");\n");
    } else if (base.type === "AND-TYPE") {
      genBaseCalls(base.lhs, fresh, getId, indent, output);
      return genBaseCalls(base.rhs, fresh, getId, indent, output);
    } else if (base.type === "ANY") {

    } else {
      throw new Error("Internal compiler error: Unexpected base type tree " + base.type + " in genBaseCalls. Line " + base.line + " character " + base.column);
    }
  };

  maybeGenGuard = function(tree, getId, indent, output) {
    if (tree.guard) {
      output.push("if (");
      gen(guard.condition, getId, indent, output);
      return output.push(") ");
    }
  };

  genCtor = function(tree, isConcrete, getId, indent, output) {
    var cType, cannotBeNothing;
    tree.selfName = "self" + getId();
    cType = asConstructed(tree);
    cannotBeNothing = isConcrete ? fullyInlined(cType) : cType;
    if (containsBase(cannotBeNothing, Nothing)) {
      throw new Error("Error: Attempt to initialize an object with a base type of Nothing on line " + tree.line + " character " + tree.column);
    }
    if (isConcrete) {
      output.push("(");
    }
    output.push("function(" + tree.selfName + "){\n");
    genBaseCalls(cType, tree, getId, indent, output);
    output.push(tabs(indent + 1));
    output.push("return " + tree.selfName + ";\n");
    output.push(tabs(indent));
    output.push("}");
    if (isConcrete) {
      return output.push(")({})");
    }
  };

  genTypeInitializer = function(fresh, name, typTree, getId, indent, output) {
    if (!containsBase(asConstructed(typTree), Nothing)) {
      output.push(tabs(indent));
      output.push("if(!" + fresh.selfName + "." + name + "){");
      output.push(fresh.selfName + "." + name);
      output.push(" = ");
      genCtor(typTree, false, getId, indent, output);
      return output.push(";}\n");
    }
  };

  gen = function(tree, getId, indent, output) {
    if (tree.type === "id") {
      requireMember(tree, true);
      output.push(tree.definingTree.selfName);
      output.push(".");
      return output.push(tree.match);
    } else if (tree.type === "TERM-SELECT") {
      gen(tree.prefix, getId, indent, output);
      output.push(".");
      return output.push(tree.id);
    } else if (tree.type === "CONSTRUCT") {
      return genCtor(tree.typTree, true, getId, indent, output);
    } else {
      throw new Error("Internal compiler error: Expected term tree in gen function, got " + tree.type + " tree");
    }
  };


  /* PARSER */

  Token = function(tokType, text, line, column) {
    var tk;
    tk = {
      type: tokType,
      match: text,
      line: line,
      column: column,
      isToken: true
    };
    tk.stringify = function() {
      return tk.match.replace('\n', '\\n');
    };
    tk.print = function() {
      return tk.type + ", \"" + (tk.match.replace('\n', '\\n')) + "\", line " + tk.line + ", character " + tk.column;
    };
    return tk;
  };

  TypeDecl = function(lhs, rhsLower, rhsUpper) {
    var t;
    t = {
      type: "TYPE-DECL",
      alttypes: ["STATEMENT"],
      lhs: lhs,
      rhsLower: rhsLower,
      rhsUpper: rhsUpper,
      line: lhs.line,
      column: lhs.column
    };
    t.stringify = function(indent) {
      return t.lhs.stringify(indent) + ": at most " + t.rhsUpper.stringify(indent) + " at least " + t.rhsLower.stringify(indent);
    };
    t.subtrees = function() {
      return [t.lhs, t.rhsLower, t.rhsUpper];
    };
    return t;
  };

  TermDecl = function(lhs, rhs) {
    var t;
    t = {
      type: "TERM-DECL",
      alttypes: ["STATEMENT"],
      lhs: lhs,
      rhs: rhs,
      line: lhs.line,
      column: lhs.column
    };
    if (t.lhs.isVal) {
      WithAnnotation(t, "@final");
    }
    t.stringify = function(indent) {
      return t.lhs.stringify(indent) + ": " + t.rhs.stringify(indent);
    };
    t.subtrees = function() {
      return [t.lhs, t.rhs];
    };
    return t;
  };

  WithAnnotation = function(t, annot) {
    if (t.annots) {
      return t.annots.push(annot);
    } else {
      return t.annots = [annot];
    }
  };

  HasAnnotation = function(t, annot) {
    return t.annots && (indexOf.call(t.annots, annot) >= 0);
  };

  WithGuard = function(guard, statement) {
    var prevStringify, prevSubtrees;
    statement.guard = guard;
    prevStringify = statement.stringify;
    statement.stringify = function(indent) {
      return guard.stringify(indent) + prevStringify(indent);
    };
    prevSubtrees = statement.subtrees;
    statement.subtrees = function() {
      return [statement.guard].concat(prevSubtrees());
    };
    return statement;
  };

  parse = function(tokens) {
    var begin, expected, fromTopOfStack, i, matches, reduce, shift, showTypes, stack, stack_contents, t, unreducedTokenCount;
    stack = [];
    unreducedTokenCount = function() {
      var i, j, ref;
      for (i = j = 1, ref = stack.length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        if (!stack[stack.length - i].isToken) {
          return i - 1;
        }
      }
      return stack.length;
    };
    matches = function(types, skip) {
      var elem, i, j, ref, ref1;
      if (skip == null) {
        skip = 0;
      }
      if (types.length <= stack.length - skip) {
        for (i = j = 0, ref = types.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          if (types[i] !== "*") {
            elem = stack[stack.length - types.length + i - skip];
            if (elem.type !== types[i] && !(elem.alttypes && (ref1 = types[i], indexOf.call(elem.alttypes, ref1) >= 0))) {
              return false;
            }
          }
        }
        return true;
      } else {
        return false;
      }
    };
    fromTopOfStack = function(i) {
      if (i == null) {
        i = 0;
      }
      if (i > stack.length - 1) {
        return void 0;
      } else {
        return stack[stack.length - 1 - i];
      }
    };
    shift = function() {
      var t;
      t = tokens.shift();
      if (t.type === "id") {
        t.alttypes = ["TERM"];
      }
      if (t.type === "ID") {
        t.alttypes = ["TYPE"];
      }
      return stack.push(t);
    };
    expected = function(description) {
      var t, value;
      if (stack.length > 0) {
        t = stack[stack.length - 1];
        value = t.isToken ? t.match.replace('\n', '\\n') : t.stringify(0);
        throw "Parse error on line " + t.line + " character " + t.column + " : Expected " + description + "; got " + t.type + " with value \"" + value + "\"";
      } else {
        throw "Parse error with empty stack: Expected " + description;
      }
    };
    reduce = function() {

      /* Handle Comments */
      var ID, _typTree, a, b, c, condition, construct, guard, id, lhs, lparen, nl, nw, prefix, prevStringify, prevSubtrees, rhs, rhsLower, rhsUpper, statement, stmt, stmts, t, term;
      if (matches(["COMMENT"])) {
        stack.pop();
        return true;
      }
      if (matches(["START-BLOCK-COMMENT", "END-BLOCK-COMMENT"])) {
        stack.pop();
        stack.pop();
        return true;
      }
      if (matches(["START-BLOCK-COMMENT", "START-BLOCK-COMMENT"])) {
        return false;
      }
      if (matches(["START-BLOCK-COMMENT", "*"])) {
        stack.pop();
        return true;
      }

      /* Recognize ids that are really keywords */
      if (matches(["id"])) {
        if (fromTopOfStack(0).match === "new") {
          fromTopOfStack(0).type = "NEW";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "var") {
          fromTopOfStack(0).type = "VAR";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "val") {
          fromTopOfStack(0).type = "VAL";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "type") {
          fromTopOfStack(0).type = "TYPE-KEYWORD";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "if") {
          fromTopOfStack(0).type = "IF";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "then") {
          fromTopOfStack(0).type = "THEN";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "outer") {
          fromTopOfStack(0).type = "OUTER";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
      }
      if (matches(["id", "id"])) {
        a = fromTopOfStack(1);
        b = fromTopOfStack(0);
        if (a.match === "at" && b.match === "least") {
          stack.pop();
          a.type = "ATLEAST";
          a.match = a.match + " " + b.match;
          a.alttypes = void 0;
          return true;
        }
        if (a.match === "at" && b.match === "most") {
          stack.pop();
          a.type = "ATMOST";
          a.match = a.match + " " + b.match;
          a.alttypes = void 0;
          return true;
        }
      }

      /* Selections */
      if (matches(["IF", "TERM", "THEN"])) {
        stack.pop();
        condition = stack.pop();
        stack.pop();
        guard = {
          type: "GUARD",
          condition: condition,
          line: condition.line,
          column: condition.column
        };
        guard.stringify = function(indent) {
          return "if " + (guard.condition.stringify(indent)) + " then ";
        };
        guard.subtrees = function() {
          return [guard.condition];
        };
        stack.push(guard);
        return true;
      }
      if (matches(["GUARD", "STATEMENT"])) {
        statement = stack.pop();
        guard = stack.pop();
        stack.push(WithGuard(guard, statement));
        return true;
      }
      if (matches(["GUARD", "*", "NEWLINE"])) {
        nl = stack.pop();
        term = stack.pop();
        guard = stack.pop();
        stack.push(WithGuard(guard, term));
        stack.push(nl);
        return true;
      }
      if (matches(["TERM", "DOT", "id"])) {
        id = stack.pop();
        stack.pop();
        prefix = stack.pop();
        t = {
          type: "TERM-SELECT",
          alttypes: ["TERM"],
          prefix: prefix,
          id: id.match,
          line: id.line,
          column: id.column
        };
        t.stringify = function(indent) {
          return t.prefix.stringify(indent) + ("." + t.id);
        };
        t.subtrees = function() {
          return [t.prefix];
        };
        stack.push(t);
        return true;
      }
      if (matches(["TERM", "DOT", "ID"])) {
        ID = stack.pop();
        stack.pop();
        prefix = stack.pop();
        t = {
          type: "TYPE-SELECT",
          alttypes: ["TYPE"],
          prefix: prefix,
          ID: ID.match,
          line: ID.line,
          column: ID.column
        };
        t.stringify = function(indent) {
          return t.prefix.stringify(indent) + ("." + t.ID);
        };
        t.subtrees = function() {
          return [t.prefix];
        };
        stack.push(t);
        return true;
      }
      if (matches(["VAR", "id", "COLON"])) {
        c = stack.pop();
        id = stack.pop();
        stack.pop();
        id.isVar = true;
        stack.push(id);
        stack.push(c);
        return true;
      }
      if (matches(["VAL", "id", "COLON"])) {
        c = stack.pop();
        id = stack.pop();
        stack.pop();
        id.isVal = true;
        stack.push(id);
        stack.push(c);
        return true;
      }
      if (matches(["TYPE-KEYWORD", "ID", "COLON"])) {
        c = stack.pop();
        ID = stack.pop();
        stack.pop();
        stack.push(ID);
        stack.push(c);
        return true;
      }
      if (matches(["ID", "COLON", "*", "*", "*", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["ATMOST", "TYPE", "ATLEAST", "TYPE"])) {
          rhsLower = stack.pop();
          stack.pop();
          rhsUpper = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        } else if (matches(["ATLEAST", "TYPE", "ATMOST", "TYPE"])) {
          rhsUpper = stack.pop();
          stack.pop();
          rhsLower = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        }
      }
      if (matches(["ID", "COLON", "*", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["ATMOST", "TYPE"])) {
          rhsUpper = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          rhsLower = Token("ID", "Nothing", rhsUpper.line, rhsUpper.column);
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        } else if (matches(["ATLEAST", "TYPE"])) {
          rhsLower = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          rhsUpper = Token("ID", "Any", rhsLower.line, rhsLower.column);
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        }
      }
      if (matches(["ID", "COLON", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhs, rhs));
          return true;
        } else {
          expected("TYPE in declaration of " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["id", "COLON", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TermDecl(lhs, rhs));
          return true;
        } else {
          expected("TYPE in declaration of " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["ID", "EQUALS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TYPE-ASSIGN",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhs: rhs,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + " = " + t.rhs.stringify(indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhs];
          };
          stack.push(t);
          return true;
        } else {
          expected("TYPE in assignment to " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["id", "EQUALS", "*", "NEWLINE"]) || matches(["TERM-SELECT", "EQUALS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TERM"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TERM-ASSIGN",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhs: rhs,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + " = " + t.rhs.stringify(indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhs];
          };
          stack.push(t);
          return true;
        } else {
          expected("TERM in assignment to " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["TYPE", "AND", "TYPE"])) {
        rhs = stack.pop();
        stack.pop();
        lhs = stack.pop();
        t = {
          type: "AND-TYPE",
          alttypes: ["TYPE"],
          lhs: lhs,
          rhs: rhs,
          line: lhs.line,
          column: lhs.column
        };
        t.stringify = function(indent) {
          return t.lhs.stringify(indent) + " & " + t.rhs.stringify(indent);
        };
        t.subtrees = function() {
          return [t.lhs, t.rhs];
        };
        stack.push(t);
        return true;
      }
      if (matches(["TYPE", "OR", "TYPE"])) {
        rhs = stack.pop();
        stack.pop();
        lhs = stack.pop();
        t = {
          type: "OR-TYPE",
          alttypes: ["TYPE"],
          lhs: lhs,
          rhs: rhs,
          line: lhs.line,
          column: lhs.column
        };
        t.stringify = function(indent) {
          return t.lhs.stringify(indent) + " | " + t.rhs.stringify(indent);
        };
        t.subtrees = function() {
          return [t.lhs, t.rhs];
        };
        stack.push(t);
        return true;
      }
      if (matches(["AT", "id", "TYPE"])) {
        t = stack.pop();
        id = stack.pop();
        stack.pop();
        WithAnnotation(t, id);
        prevStringify = t.stringify;
        prevSubtrees = t.subtrees;
        t.stringify = function(indent) {
          return "@" + t.id.match + " " + prevStringify(indent);
        };
        t.subtrees = function() {
          return prevSubtrees().concat([t.typ]);
        };
        stack.push(t);
        return true;
      }
      if (matches(["STATEMENTS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TERM"])) {
          stmt = stack.pop();
          stmts = stack.pop();
          stmts.statements.push(stmt);
          stmts.line = stmt.line;
          stmts.column = stmt.column;
          stack.push(stmts);
          return true;
        } else {
          expected("STATEMENT");
        }
      }
      if (matches(["STATEMENTS", "STATEMENT"])) {
        stmt = stack.pop();
        stmts = stack.pop();
        stmts.statements.push(stmt);
        stmts.line = stmt.line;
        stmts.column = stmt.column;
        stack.push(stmts);
        return true;
      }
      if (matches(["LBRACE"])) {
        lparen = fromTopOfStack();
        begin(lparen.line, lparen.column);
        return true;
      }
      if (matches(["LBRACE", "STATEMENTS", "RBRACE"])) {
        stack.pop();
        stmts = stack.pop();
        stack.pop();
        stack.push(stmts);
        return true;
      }
      if (matches(["*", "DOT", "NEW"])) {
        nw = stack.pop();
        stack.pop();
        if (matches(["TYPE"])) {
          _typTree = stack.pop();
          construct = {
            type: "CONSTRUCT",
            alttypes: ["TERM"],
            typTree: _typTree,
            line: nw.line,
            column: nw.column
          };
          construct.stringify = function(indent) {
            return (construct.typTree.stringify(indent)) + ".new";
          };
          construct.subtrees = function() {
            return [construct.typTree];
          };
          stack.push(construct);
          return true;
        } else {
          throw new Error("Expected type in object construction on line " + nw.line + " character " + nw.column + ", got " + (fromTopOfStack(0).stringify(0)));
        }
      }
      if (matches(["STATEMENTS", "NEWLINE"])) {
        stack.pop();
        return true;
      }
    };
    begin = function(ln, col) {
      var stmts;
      stmts = {
        type: "STATEMENTS",
        alttypes: ["TYPE"],
        statements: [],
        line: ln,
        column: col
      };
      stmts.stringify = function(indent) {
        return stringifyStatements(stmts, indent);
      };
      stmts.subtrees = function() {
        return stmts.statements;
      };
      stmts.print = stmts.stringify;
      return stack.push(stmts);
    };
    showTypes = function(t) {
      var s, typ;
      s = t.type;
      if (t.alttypes) {
        s = s + " & " + ((function() {
          var j, len, ref, results;
          ref = t.alttypes;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            typ = ref[j];
            results.push(typ);
          }
          return results;
        })()).join(" & ");
      }
      return s;
    };
    begin(1, 1);
    while (true) {
      while (reduce()) {
        true;
      }
      if (tokens[0].type === "EOF" || unreducedTokenCount() >= 8) {
        break;
      }
      shift();
    }
    if (stack.length !== 1) {
      i = -1;
      stack_contents = ((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = stack.length; j < len; j++) {
          t = stack[j];
          i += 1;
          results.push("Item " + i + ": " + (showTypes(t)) + "\n" + (t.stringify(0)));
        }
        return results;
      })()).join("\n\n");
      throw "Parse error: Unreduced items on stack at End-of-Input. Stack contents:\n\n" + stack_contents;
    }
    return stack[0];
  };

  tokenize = function(input) {
    var Whitespace, column, consumeNextToken, getNextToken, line, t, tk, tokenList, tokens;
    line = 1;
    column = 1;
    tokenList = [
      {
        name: "id",
        regex: /^([a-z][a-zA-z0-9_]*|\?\?\?)/
      }, {
        name: "ID",
        regex: /^[A-Z][a-zA-z0-9_]*/
      }, {
        name: "NEWLINE",
        regex: /^(\n|\r\n|\r)/
      }, {
        name: "COMMENT",
        regex: /^\/\/.*/
      }, {
        name: "START-BLOCK-COMMENT",
        regex: /^\/\*/
      }, {
        name: "END-BLOCK-COMMENT",
        regex: /^\*\//
      }, {
        name: "DOT",
        regex: /^\./
      }, {
        name: "AND",
        regex: /^&/
      }, {
        name: "OR",
        regex: /^\|/
      }, {
        name: "AT",
        regex: /^@/
      }, {
        name: "EQUALS",
        regex: /^=/
      }, {
        name: "LPAREN",
        regex: /^\(/
      }, {
        name: "RPAREN",
        regex: /^\)/
      }, {
        name: "LBRACE",
        regex: /^{/
      }, {
        name: "RBRACE",
        regex: /^}/
      }, {
        name: "COLON",
        regex: /^:/
      }, {
        name: "SEMI",
        regex: /^;/
      }, {
        name: "EOF",
        regex: /^$/
      }
    ];
    Whitespace = {
      name: "SPACE",
      regex: /^[\t \v\f]+/
    };
    getNextToken = function() {
      var j, len, length, matches, tok;
      matches = Whitespace.regex.exec(input);
      if (matches) {
        input = input.substring(matches[0].length);
        column += matches[0].length;
      }
      for (j = 0, len = tokenList.length; j < len; j++) {
        tok = tokenList[j];
        matches = tok.regex.exec(input);
        if (matches) {
          return Token(tok.name, matches[0], line, column);
        }
      }
      length = input.indexOf('\n');
      if (length <= 0) {
        length = input.length;
      }
      throw "Tokenization error on line " + line + " character " + column + " : Unable to match a token starting at '" + (input.substring(0, length)) + "'";
    };
    consumeNextToken = function() {
      var tok;
      tok = getNextToken();
      input = input.substring(tok.match.length);
      column += tok.match.length;
      if (tok.type === "NEWLINE") {
        column = 1;
        line += 1;
      }
      return tok;
    };
    tokens = [];
    while (true) {
      t = consumeNextToken();
      if (t.type === "RBRACE" || t.type === "EOF") {
        tk = Token("NEWLINE", "\n", t.line, t.column);
        tk.stringify = function() {
          return "(synthetic \\n)";
        };
        tk.print = function() {
          return "synthetic NEWLINE on line " + t.line + ", char " + t.column;
        };
        tokens.push(tk);
      }
      tokens.push(t);
      if (t.type === "EOF") {
        break;
      }
    }
    return tokens;
  };

  stringifyStatements = function(stmts, indent) {
    var stmt;
    return "{\n" + ((function() {
      var j, len, ref, results;
      ref = stmts.statements;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        stmt = ref[j];
        results.push(tabs(indent + 1) + stmt.stringify(indent + 1) + "\n");
      }
      return results;
    })()).join("") + tabs(indent) + "}";
  };

  tabs = function(indent) {
    return "\t".repeat(indent);
  };

}).call(this);
