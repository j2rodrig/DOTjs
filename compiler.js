// Generated by CoffeeScript 1.10.0
(function() {
  var AndType, Any, Nothing, OrType, TermDecl, Token, TypeBounds, TypeDecl, WithGuard, channels, clearLog, createPredefContext, derivedAndOrType, derivedTypeBounds, doStatementCompleters, doTermCompleters, doTypeCompleters, findBaseStatementBlocks, findMember, findMemberInContext, freshContext, gen, genConstructor, genInitializer, getBaseTypes, getDefContext, isSubType, log, lowerBound, parse, requireCompatibility, requireDefContext, requireMemberInContext, requireMemberInType, simplifyType, stderr, tabs, tokenize, typeAsConstructed, types, upperBound, widen,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.compile = function(input, stopAfter) {
    var allOutput, ast, error, error1, message, output, outputBuffer, predefCtx, tok, tokens;
    try {
      clearLog();
      tokens = tokenize(input);
      if (stopAfter === "tokens") {
        return ((function() {
          var j, len, results;
          results = [];
          for (j = 0, len = tokens.length; j < len; j++) {
            tok = tokens[j];
            results.push(tok.print());
          }
          return results;
        })()).join('\n');
      }
      ast = parse(tokens);
      if (stopAfter === "trees") {
        return ast.print(0);
      }
      predefCtx = createPredefContext();
      doTypeCompleters(ast, predefCtx.fresh(ast));
      if (stopAfter === "symbols") {
        printSymbolTables(ast);
      }
      outputBuffer = [];
      genConstructor(ast, predefCtx, 0, outputBuffer);
      outputBuffer.push(";");
      output = outputBuffer.join("");
      allOutput = [output];
      if (channels[types]) {
        allOutput.push("/** Types log:\n\n" + channels[types].join("\n") + "\n**/");
      }
      if (channels[stderr]) {
        allOutput.push("/** Stderr log:\n\n" + channels[stderr].join("\n") + "\n**/");
      }
      return allOutput.join("\n\n");
    } catch (error1) {
      error = error1;
      message = error.message != null ? error.message : error;
      message = message.toUpperCase().startsWith("ERROR") || message.toUpperCase().startsWith("INTERNAL COMPILER ERROR") ? message : "Error: " + message;
      output = [message];
      if (channels[types]) {
        output.push("Types log:\n\n" + channels[types].join("\n"));
      }
      if (channels[stderr]) {
        output.push("Stderr log:\n\n" + channels[stderr].join("\n"));
      }
      if (error.stack != null) {
        output.push("COMPILER STACKTRACE:\n" + error.stack);
      }
      return output.join("\n\n");
    }
  };

  channels = {};

  stderr = "stderr";

  types = "types";

  clearLog = function() {
    return channels = {};
  };

  log = function(ch, msg) {
    if (!channels[ch]) {
      return channels[ch] = [msg];
    } else {
      return channels[ch].push(msg);
    }
  };


  /*
  
  NOTES
  
  Compilers are Databases
  
  	Should I structure this compiler like Odersky's core ER (Entity Relationship) diagram?
  	Yes, that seems like a good idea.
  
  	Should I literally build tables of entities here?
  	No. But something more flexible than what Martin did is a good idea.
  
  	Is the flexibility issue I'm seeing an interface problem?
  	Yes.
  
  	How do I do infterfaces better?
  	Just think - ...
  
  What's a Type?
  
  	A type is what we know (or assume) about something.
  
  	A type may be associated with a tree (but it doesn't have to be).
  	A type may be associated with a symbol (but it doesn't have to be).
  
  	So what does a type do?
  
  	What do we want to do with a type?
  
  	We want to make sure that for every term selection p.x, p contains x.
  	We want to make sure that for every type selection p.T, p contains T.
  	We want to make sure that for every term assignment a = b, b is substitutable for a.
  	We want to make sure that for every term assignment a = b, a is assignable.
  	(Assignability is [among other things] related to variance and privacy: a field is not writable/assignable if its type is covariant and non-private [which is notably the case for all fields in DOT].)
  	We want to make sure that for every instance creation T.new, all needed members of T are known.
  	For every declaration block '{ stmts }', we want to know what declarations it contains.
  	The type of a statement block must be related to: 1. The declarations in that block (which may be inferred), and 2. the sequence of assignments in that block (term and type assignments).
  
  	What about subtyping?
  	'{ stmts1 }' <: '{ stmts2 }' if for every declaration in stmts2 there is a compatible declaration in stmts1. That is, for all D2 in stmts2, there exists a D1 in stmts1 s.t. D1 <: D2. This interpretation of statement-block subtyping is compatible with the idea that the type of a statement block is the intersection of all declarations in that block.
  
  
  	Declaration subsumption
  	We only have 2 kinds of declarations.
  	Type declarations have the form 'ID : A .. B' where A and B are types.
  	Term declarations have the form 'id : T' where T is a type.
  
  	'id1:T1' <: 'id2:T2' if T1 == T2. (May be relaxed if T1 or T2 is covariant or contravariant.)
  
  	'ID1:A1..B1 <: ID2:A2..B2' if A2 <: A1 and B1 <: B2.
  
  
  	Inheritance of Field Types
  	Despite DOT, it seems like field types should be invariant under inheritance, unless stated otherwise.
  	What does this mean for subtyping?
  
  	Scala has separate notions of a getter and setter.
  	Say, for example, A <: B. And:
  		trait D { var f: A }
  		trait E extends D { var f: B = ??? }
  	If we try
  		new E{}
  	Scala won't take it because the setter for f:A has not been defined.
  	The getter for f:A is overridden by f:B, so that part's OK.
  
  	Maybe we need to find out how getters and setters work in DOTjs:
  	{
  		f: A
  		GetF = {
  			out value: A
  			value = f
  		}
  		SetF = {
  			in value: A
  			f = value
  		}
  	}
  	Calling:
  	{
  		fOut = GetF.new.value
  		SetF{ value = fIn }.new
  	}
  	Mixing in:
  	{
  		f: B
  		GetF = {  // presence of public getter constrains f's type <: A&B
  			out value: B  // "out" means there's no way to assign outside of this object*
  			value = f
  		}
  		SetF = {  // presence of public setter constrains A|B <: f's type
  			in value: B   // "in" means there's no way to read outside of this object**
  			f = value
  		}
  	}
  	* Assignments to the value can occur within the statement block where the value is declared.
  	  Field f can be arbitrarily assigned within the block because mixin composition occurs
  	  over such assignments, and they can be type-checked at the time of object instantiation.
  	** Reads of the value can occur within the statement block where the value is declared.
  	  Like assignments, reads of values within the statement block are type-checked at the
  	  point of object creation. Access to the final type of the field allows this.
  
  
  	Mixins, declarations, and assignments
  
  	Declarations are order-agnostic. Regardless of mixin ordering, all declarations must be satisfied.
  	Satisfaction of declarations means:
  		For every declared type T, the upper bound must be no less than the lower bound.
  		All assignments to T must be within those bounds.
  		For every publically-readable field fo declared with type FO, FO serves as an upper bound
  		of the actual type of fo. For every publically-writable field fi with type FI, FI serves
  		as a lower bound of the actual type of fi.
  
  	Assignments are order-dependent.
  
  	Type assignments must be evaluated at compile time.
  	Term assignments may be evaluated at runtime.
  
  	A type assignment remains in effect only until the type is re-assigned
  	(a type assignment is a temporary narrowing of type bounds).
  
  	Here's the key:
  	Declarations participate in the static type of an object, but assignments do not.
  	(Although it is possible to infer certain declarations given a set of assignments.)
  
  	Example of type assignment:
  	J = {
  		L = Int
  		f: L
  		f = 3
  		L = String  // changes the type of L for subsequent statements
  		g: L
  		g = "Hi!"
  	}
  	j = J.new
  	l: j.L   // j.L is a string here, since that was the last assignment to L in j
  	l = "Hi again!"
  
  	Key note: (
  		All term members start as undefined, all type members as Undefined.
  		When are errors generated on use of undefined or Undefined?
  	)
  
  	Path-dependent subtyping rules allow j.L to be equal to j.L,
  	but another path k.L is not necessarily equal to j.L.
  
  (Triple venti vanilla frappucino)
   */


  /*
  APPROACH TO TYPE CHECKING
  
  A function to get the bounds on a tree's type. (What's the result here?)
  
  A function to get the declarations on a tree's type. There are lower- and upper-bound versions.
  
  A function to get the assignments on a tree's type. Ther result is always a constructible lower bound.
  
  
  HOW TO TYPECHECK: A & { x = y } . new
  
  Register a new context for A & { x = y }    # reflects creation of new object
  Linearize statements in A & { x = y }
  Resolve and check explicit declarations in A & { x = y }
  	(the declarations in A are thereby entered into the newly-created current context.)
  Generate type aliases from type assignments (and check that they are within declared bounds).
  Infer field types (term declarations) from term assignments (where needed).
  
  Specific to { x = y }:
  	Check that y.type <: x.widen.
  	Which involves:
  		Look up y in the context where y is used (in this case, the newly-created current context)
  		Look up x in the context where x is used (in this case, the newly-created current context)
  Generalization:
  	Check that term assignments have compatible types.
  	The type of a path p is simply p itself.
  	If necessary, p is widened to its declared type.
  
  Path-dependence and A:
  	( assume A is { y: Y;  y = a } )
  	Lookup of y from { x = y } produces type Y, which may be in A's outer context.
  	( assume { Y: at least L at most U ; A = { y: Y;  y = a } } )
  	The type of p.y in "p = A & { x = y } . new" is: p.Y
  		because Y is invariant with respect to a particular object reference p.
  	So Y without a prefix is always equal to Y without a prefix, and p.Y === p.Y.
  		But: Y != p.Y and p.Y != q.Y  ---> path-dependence.
  		(unless Y is aliased to another type which does compare.)
  
  Code Generation
  
  {
  	A : at least {
  		y: Y
  		y = ???
  	}
  
  	bar = A & { x = y }.new
  	bar.x
  }
  
  (function (c0) {
  	c0.A = function (c1) {
  		c1.y = throw "Not Implemented";
  	};
  	c0.bar = (function (c2) {
  		c0.A(c2);
  		c2.x = c2.y;
  		return c2;   // return is only generated for ".new"
  	})({});
  	c0.bar.x;
  	return c0;
  })({});
   */


  /*
  Progress Notes, June 14, 2016.
  
  	It seems that I should do an overhaul of how contexts are generated and used.
  Specifically, contexts should be given unique names. All user-specified names without
  prefixes are prefixed with the appropriate context name.
  
  	My previous approach is probably incorrect in another way also. Previously, I was
  assuming that all statements in all constructors could be simply linearized upon
  instantiation. However, that approach does not account for the possibility that
  constructors will access names in their enclosing contexts. Instead, I now think that
  the linearization really needs to identify not merely inherited statements, but rather
  the appropriate base-class constructors. These constructors ought to be called as
  functions in linearization order.
  
  	Javascript will handle referencing enclosing contexts via is closure mechanism.
  
  Notes, June 15
  
  	Name mangling: If I want to support custom/hidden/private(?) attributes,
  I can use a name starting with a low-frequency letter (e.g., "q"). Some escape pattern
  can be used for any user names that happen to start with that letter.
  
  	For private fields, perhaps codegen can produce Javascript variables. The closure
  mechanism will still be able to access those variables, but they will never be present
  within derived types. 
  
  	How do I proceed?
  	1. Codegen. Write it out.
  	2. ...
  
  Notes, June 17
  
  	On membership:
  	The reasons I need to know about membership are:
  	1. To determine whether a name selection is always valid (either in the current context, constructor context, or prefix context),
  	2. To find out which constructors should be called on named type instantiation.
  
  	Abstract execution plan:
  	1. Generate code for constructors. Which depends on:
  		a. Finding a sequence of base trees.
  		a1. Looking up base trees from named types in the current or enclosing contexts.
  			b1. Name declarations must be registered in their current contexts.
  			b2. Looking up declarations in a constructor context must search base trees for matching declarations.
  				c1. 
  		a2. 
  
  
  June 19.
  
  	Due to the recurive nature of path-dependent typing, I am now skeptical that a simple bottom-up approach to typing
  and linearization will work. Finding the complete membership of a type involves finding membership of its term prefix,
  which involves finding the membership of that term's type.
  
  	First, we need to be able to move from contexts to trees. This will allow examination of type trees to determine
  members, base types, etc.
  
  	Second, we may need a findMember that searches type trees for specific named members. The inputs to findMember are
  a prefix type tree and a name. The result of findMember is a type tree. To support unions and intersections, synthetic type trees
  may be created.*
  
  	Third, we need a findMember that searches within a context. If searching a constructor context, we switch to the
  findMember that searches through type trees.
  
  *There is a canonical form for any type tree: (S1 & ... & SN) | ... | (T1 & ... & TM) where every Sn and Tm is a
  statement block.
  
  June 21.
  
  	How do we generate mixin constructors?
  
  	Say we have:
  		T : { a } & { b }
  	When we go to construct an instance of T:
  		T.new
  	we need to have a mixin constructor for T that builds an object with a type compatiable with T.
  	Compatibility with T means that the constructed object's type must be compatible with T's lower bound.
  
  	As for the statments that go into T's mixin constructor, we can select any statements we want.
  	However, we should at least make an effort to ensure that all fields declared in T's lower bound get initialized
  	and initialized in a reasonable order, even if the lower bound of T contains union types.
  	The solution here is to traverse the lower-bound type of T all the way down to concrete statements,
  	and generate all term-like statements in the order that they appear.
  	For consistency, we may say that Nothing contains no statements (although it contains all possible
  	declarations). By saying that Nothing contains no statements, the lower bound of an intersection type
  	A & B -- although quite possibly containing a union with Nothing -- will still be constructible and
  	generate all expected statements. There is still an issue with implementation inheritance, however:
  	after narrowing a type member's bounds, one would expect that the statements in a newly-declared
  	lower bound would supercede -- not append to -- statements in the previously-declared lower bound.
  
  	The issue of implementation inheritance would benefit from some more thought...
  
  	For now, it suffices to say that side-effect-free constructors called in linearization order should
  	produce a reasonable result; term-member initializations override any prior conflicting initializations
  	at runtime, and indeed unneeded prior initializations are potentially elidable through optimization.
  
  	Perhaps the best thing to do here is try some examples after codegen is completed.
  
  
  	Another issue is what to do about out-of-order statements. For now, nothing. Ideally, statements
  would be reordered based on depenency. But this doesn't have to happen yet.
  
  
  June 24.
  
  	I may need to re-think exactly how/when symbols are added to contexts. There are problems with circular references in symbol lookups.
  
  	1. Remove contexts on STATEMENTS trees, leaving only constructor/mixin-constructor contexts.
  	2. Constructor membership is evaluated lazily. Basically, requesting a member of a context forces
  	   computation of the entire memberhsip set for that context. For each constructor, the membership
  	   set is always computed before any element is selected from it.
  
  	Possible way to break this approach:
  		x: L
  		L: x.K   // the membership of L depends on a member of L. It's probably OK to treat this as an error
  
  	Possible counter-counter example:
  	L: {
  		H: at most L   // OK. The mixin context surrounding L here is evaluated lazily, so all members of L are established before we get here.
  	}
  
  July 2.
  
  	The problem of symbol lookup seems to be solved. Up next: Type comparison.
  
  July 4.
  
  	There is a problem with type lookup:
  		Which context do we start with when looking into a type?
  		If we use the original context, that works, but the result is conservative, so we don't get all the benefits of path-dependent typing.
  		Specifically, we don't get type polymorphism.
  	Instead, we need to look up type IDs from the current context (rather than the original context).
   */

  Any = {
    type: "ANY",
    stringify: function(indent) {
      return "Any";
    }
  };

  Nothing = {
    type: "NOTHING",
    stringify: function(indent) {
      return "Nothing";
    }
  };

  AndType = function(lhsTyp, rhsTyp) {
    return {
      type: "AND-TYPE",
      lhs: lhsTyp,
      rhs: rhsTyp,
      stringify: function(indent) {
        return lhsTyp.stringify(indent) + " & " + rhsTyp.stringify(indent);
      }
    };
  };

  OrType = function(lhsTyp, rhsTyp) {
    return {
      type: "OR-TYPE",
      lhs: lhsTyp,
      rhs: rhsTyp,
      stringify: function(indent) {
        return lhsTyp.stringify(indent) + " & " + rhsTyp.stringify(indent);
      }
    };
  };

  TypeBounds = function(typLower, typUpper) {
    return {
      type: "TYPE-BOUNDS",
      lower: typLower,
      upper: typUpper,
      stringify: function(indent) {
        return "at least " + (typLower.stringify(indent)) + " at most " + (typUpper.stringify(indent));
      }
    };
  };


  /* TYPE OPERATIONS */

  derivedTypeBounds = function(tree, lower, upper) {
    if (lower === tree.lower && upper === tree.upper) {
      return tree;
    } else {
      return TypeBounds(lower, upper);
    }
  };

  derivedAndOrType = function(tree, lhs, rhs) {
    if (lhs === tree.lhs && rhs === tree.rhs) {
      return tree;
    } else if (tree.type === "AND-TYPE") {
      return AndType(lhs, rhs);
    } else if (tree.type === "OR-TYPE") {
      return OrType(lhs, rhs);
    }
  };

  lowerBound = function(tree) {
    if (tree.type === "TYPE-BOUNDS") {
      return tree.lower;
    } else {
      return tree;
    }
  };

  upperBound = function(tree) {
    if (tree.type === "TYPE-BOUNDS") {
      return tree.upper;
    } else {
      return tree;
    }
  };

  simplifyType = function(tree) {
    var tree2;
    if (tree.type === "TYPE-BOUNDS") {
      tree2 = derivedTypeBounds(tree, simplifyType(tree.lower), simplifyType(tree.upper));
      if (tree2.lower === tree2.upper) {
        return tree2.lower;
      } else {
        return tree2;
      }
    } else if (tree.type === "AND-TYPE") {
      tree2 = derivedAndOrType(tree, simplifyType(tree.lhs), simplifyType(tree.rhs));
      if (tree2.lhs === tree2.rhs) {
        return tree2.lhs;
      } else if (tree2.lhs === Nothing || tree2.rhs === Nothing) {
        return Nothing;
      } else if (tree2.lhs === Any) {
        return tree2.rhs;
      } else if (tree2.rhs === Any) {
        return tree2.lhs;
      } else {
        return tree2;
      }
    } else if (tree.type === "OR-TYPE") {
      tree2 = derivedAndOrType(tree, simplifyType(tree.lhs), simplifyType(tree.rhs));
      if (tree2.lhs === tree2.rhs) {
        return tree2.lhs;
      } else if (tree2.lhs === Any || tree2.rhs === Any) {
        return Any;
      } else if (tree2.lhs === Nothing) {
        return tree2.rhs;
      } else if (tree2.rhs === Nothing) {
        return tree2.lhs;
      } else {
        return tree2;
      }
    } else {
      return tree;
    }
  };


  /* CONTEXTS AND SYMBOL/MEMBER LOOKUP */

  createPredefContext = function() {
    var ctx, predefTree;
    predefTree = {
      type: "STATEMENTS",
      statements: []
    };
    predefTree.statements.push(TypeDecl(Token("ID", "Any", void 0, void 0), Any, Any));
    predefTree.statements.push(TypeDecl(Token("ID", "Nothing", void 0, void 0), Nothing, Nothing));
    predefTree.statements.push(TermDecl(Token("ID", "???", void 0, void 0), Nothing));
    ctx = freshContext(void 0, predefTree);
    Any.ctx = ctx;
    Nothing.ctx = ctx;
    return ctx;
  };

  freshContext = function(outer, typTree) {
    var ctx;
    ctx = {};
    if (outer) {
      ctx.nestLevel = outer.nestLevel + 1;
      ctx.outer = outer;
    } else {
      ctx.nestLevel = 0;
      ctx.outer = void 0;
    }
    ctx.indents = tabs(ctx.nestLevel);
    ctx.name = "c" + ctx.nestLevel;
    ctx.fresh = function(typTree) {
      return freshContext(ctx, typTree);
    };
    ctx.findMember = function(name, returnLowerBound, logIndent) {
      var asConstructed;
      asConstructed = typeAsConstructed(typTree, ctx.outer);
      return findMember(name, asConstructed, void 0, returnLowerBound, logIndent);
    };
    return ctx;
  };

  findMember = function(name, typTree, ctx, returnLowerBound, logIndent) {
    var found, j, len, lhsType, ref, ref1, ref2, rhsType, st, widenedCtx, widenedIdCtx, widenedIdTree, widenedTyp;
    if (typTree.type === "STATEMENTS") {
      found = void 0;
      ref = typTree.statements;
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        if (st.type === "TYPE-DECL" && st.lhs.match === name) {
          if (found) {
            throw new Error("Duplicate definition of '" + name + "' on line " + st.lhs.line + " character " + st.lhs.column);
          }
          found = returnLowerBound ? st.rhsLower : st.rhsUpper;
        } else if (st.type === "TERM-DECL" && st.lhs.match === name) {
          if (found) {
            throw new Error("Duplicate definition of '" + name + "' on line " + st.lhs.line + " character " + st.lhs.column);
          }
          found = st.rhs;
        }
      }
      return found;
    } else if (typTree.type === "ANY") {
      return void 0;
    } else if (typTree.type === "NOTHING") {
      throw new Error("Attempt to find member '" + name + "' in type Nothing, which contains contradictory definitions of '" + name + "'.");
    } else if (typTree.type === "ID") {
      ref1 = widen(typTree, ctx), widenedIdCtx = ref1[0], widenedIdTree = ref1[1];
      return findMember(name, widenedIdTree, widenedIdCtx, returnLowerBound);
    } else if (typTree.type === "TYPE-SELECT") {
      ref2 = widen(typTree, ctx), widenedCtx = ref2[0], widenedTyp = ref2[1];
      return findMember(name, widenedTyp, widenedCtx, returnLowerBound);
    } else if (typTree.type === "AND-TYPE") {
      lhsType = findMember(name, typTree.lhs, ctx, returnLowerBound);
      rhsType = findMember(name, typTree.rhs, ctx, returnLowerBound);
      if ((!lhsType) || (lhsType === rhsType)) {
        return rhsType;
      } else if (!rhsType) {
        return lhsType;
      } else {
        return AndType(lhsType, rhsType);
      }
    } else {
      throw new Error("Internal compiler error: Unexpected " + typTree.type + " tree in findMember");
    }
  };

  widen = function(tree, ctx, returnLowerBound, logIndent) {
    var asConstructed, prefixCtx, prefixTyp, ref, ref1;
    if (logIndent == null) {
      logIndent = 0;
    }
    if (tree.type === "id") {
      return [ctx, requireMemberInContext(tree.match, ctx, tree, returnLowerBound, logIndent + 1)];
    } else if (tree.type === "ID") {
      log(types, tabs(logIndent) + ("Widening ID " + tree.match + " starting from context " + ctx.name));
      return [ctx, requireMemberInContext(tree.match, ctx, tree, returnLowerBound, logIndent + 1)];
    } else if (tree.type === "TERM-SELECT") {
      log(types, tabs(logIndent) + ("Widening term selection " + (tree.stringify(logIndent + 1)) + " starting from context " + ctx.name));
      ref = widen(tree.prefix, ctx, false, logIndent + 1), prefixCtx = ref[0], prefixTyp = ref[1];
      return [prefixCtx, requireMemberInType(tree.id, prefixTyp, prefixCtx, tree, returnLowerBound)];
    } else if (tree.type === "TYPE-SELECT") {
      log(types, tabs(logIndent) + ("Widening type selection " + (tree.stringify(logIndent + 1)) + " starting from context " + ctx.name));
      ref1 = widen(tree.prefix, ctx, false, logIndent + 1), prefixCtx = ref1[0], prefixTyp = ref1[1];
      return [prefixCtx, requireMemberInType(tree.ID, prefixTyp, prefixCtx, tree, returnLowerBound)];
    } else if (tree.type === "CONSTRUCT") {
      asConstructed = typeAsConstructed(tree.typTree, ctx);
      log(types, tabs(logIndent) + ("Widening constructor " + (asConstructed.stringify(logIndent + 1)) + " starting from context " + ctx.name));
      return [tree.typTree.ctx, asConstructed];
    } else {
      throw new Error("Unexpected " + tree.type + " tree in widen");
    }
  };

  findMemberInContext = function(name, ctx, returnLowerBound, logIndent) {
    var found;
    if (!ctx) {
      return void 0;
    } else {
      found = ctx.findMember(name, returnLowerBound, logIndent);
      if (found) {
        return found;
      } else {
        return findMemberInContext(name, ctx.outer, returnLowerBound, logIndent);
      }
    }
  };

  getDefContext = function(name, ctx) {
    if (!ctx) {
      return void 0;
    } else {
      if (ctx.findMember(name)) {
        return ctx;
      } else {
        return getDefContext(name, ctx.outer);
      }
    }
  };

  requireMemberInContext = function(name, ctx, sourceTree, returnLowerBound, logIndent) {
    var typTree;
    typTree = findMemberInContext(name, ctx, returnLowerBound, logIndent);
    if (!typTree) {
      throw new Error("Name '" + name + "' is not defined at line " + sourceTree.line + " character " + sourceTree.column);
    }
    return typTree;
  };

  requireMemberInType = function(name, typTree, ctx, sourceTree, returnLowerBound, logIndent) {
    var found;
    found = findMember(name, typTree, ctx, returnLowerBound, logIndent);
    if (!found) {
      throw new Error("Member '" + name + "' at line " + sourceTree.line + " character " + sourceTree.column + " could not be found");
    }
    return found;
  };

  requireDefContext = function(name, ctx, sourceTree) {
    var found;
    found = getDefContext(name, ctx);
    if (!found) {
      throw new Error("Name '" + name + "' is not defined at line " + sourceTree.line + " character " + sourceTree.column);
    }
    return found;
  };


  /* BASE/CONSTRUCTOR TYPE QUERIES */

  typeAsConstructed = function(typTree, ctx) {
    var block, j, len, ref, typ;
    typ = Any;
    ref = findBaseStatementBlocks(typTree, ctx);
    for (j = 0, len = ref.length; j < len; j++) {
      block = ref[j];
      typ = AndType(typ, block);
    }
    return typ;
  };

  findBaseStatementBlocks = function(typTree, ctx) {
    var base, basesSeen, ignore, j, k, len, len1, ref, ref1, ref2, ref3, ref4, statementsFound, stmts, widenedType;
    if (typTree._baseStatementBlocks) {
      return typTree._baseStatementBlocks;
    }
    statementsFound = [];
    basesSeen = [];
    ref = getBaseTypes(typTree);
    for (j = 0, len = ref.length; j < len; j++) {
      base = ref[j];
      if (!(indexOf.call(basesSeen, base) >= 0)) {
        basesSeen.push(base);
        if ((ref1 = base.type) === "STATEMENTS" || ref1 === "ANY" || ref1 === "NOTHING") {
          statementsFound.push(base);
        } else if ((ref2 = base.type) === "ID" || ref2 === "TYPE-SELECT") {
          ref3 = widen(base, ctx, true), ignore = ref3[0], widenedType = ref3[1];
          ref4 = findBaseStatementBlocks(widenedType, widenedType.ctx.outer);
          for (k = 0, len1 = ref4.length; k < len1; k++) {
            stmts = ref4[k];
            if (!(indexOf.call(basesSeen, stmts) >= 0)) {
              basesSeen.push(stmts);
              statementsFound.push(stmts);
            }
          }
        } else if (base.type === Any || base.type === Nothing) {
          statementsFound.push(base);
        } else {
          throw new Error("Internal complier error: unexpected base tree type " + base.type + " in findBaseStatementBlocks");
        }
      }
    }
    typTree._baseStatementBlocks = statementsFound;
    return statementsFound;
  };

  getBaseTypes = function(typTree) {
    var b, j, len, lhsBases, ref, ref1, rhsBases;
    if ((ref = typTree.type) === "ID" || ref === "TYPE-SELECT") {
      return [typTree];
    } else if (typTree.type === "TYPE-BOUNDS") {
      return getBaseTypes(typTree.lower);
    } else if (typTree.type === "AND-TYPE") {
      return getBaseTypes(typTree.lhs).concat(getBaseTypes(typTree.rhs));
    } else if (typTree.type === "OR-TYPE") {
      lhsBases = getBaseTypes(typTree.lhs);
      rhsBases = getBaseTypes(typTree.rhs);
      for (j = 0, len = lhsBases.length; j < len; j++) {
        b = lhsBases[j];
        if (b === Nothing || b.match === "Nothing") {
          return rhsBases;
        }
      }
      return lhsBases;
    } else if ((ref1 = typTree.type) === "STATEMENTS" || ref1 === "ANY" || ref1 === "NOTHING") {
      return [typTree];
    } else {
      throw new Error("Internal compiler error: Expected a type tree in getBaseTypes, got " + typTree.type + " tree");
    }
  };


  /* LAZY INFO FUNCTIONS ... TODO: Do we really need these? */

  doTypeCompleters = function(tree, ctx) {
    var j, len, ref, results, st;
    tree.ctx = ctx;
    if (tree.type === "STATEMENTS") {
      ref = tree.statements;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        results.push(doStatementCompleters(st, tree.ctx));
      }
      return results;
    } else if (tree.type === "ID") {

    } else if (tree.type === "TYPE-SELECT") {
      return doTermCompleters(tree.prefix, ctx);
    } else if (tree.type === "AND-TYPE" || tree.type === "OR-TYPE") {
      doTypeCompleters(tree.lhs, ctx);
      return doTypeCompleters(tree.rhs, ctx);
    } else {
      throw new Error("Unexpected " + tree.type + " tree in doTypeCompleters");
    }
  };

  doTermCompleters = function(tree, ctx) {
    if (tree.type === "id") {
      return tree.info = function() {
        return requireMemberInContext(tree.match, ctx, tree);
      };
    } else if (tree.type === "TERM-SELECT") {
      tree.info = function() {
        return requireMemberInType(tree.id, tree.prefix.info(), ctx, tree);
      };
      return doTermCompleters(tree.prefix, ctx);
    } else if (tree.type === "CONSTRUCT") {
      ctx = ctx.fresh(tree.typTree);
      tree.info = function() {
        return tree.typTree;
      };
      return doTypeCompleters(tree.typTree, ctx);
    } else {
      throw new Error("Unexpected " + tree.type + " tree in doTermCompleters");
    }
  };

  doStatementCompleters = function(tree, ctx) {
    if (tree.type === "TERM-DECL") {
      return doTypeCompleters(tree.rhs, ctx);
    } else if (tree.type === "TYPE-DECL") {
      doTypeCompleters(tree.rhsLower, ctx.fresh(tree.rhsLower));
      return doTypeCompleters(tree.rhsUpper, ctx.fresh(tree.rhsUpper));
    } else if (tree.type === "TYPE-ASSIGN") {
      doTypeCompleters(tree.lhs, ctx);
      return doTypeCompleters(tree.rhs, ctx);
    } else if (tree.type === "TERM-ASSIGN") {
      doTermCompleters(tree.lhs, ctx);
      return doTermCompleters(tree.rhs, ctx);
    } else {
      return doTermCompleters(tree, ctx);
    }
  };


  /* TYPE COMPARISONS */

  isSubType = function(t0, t1) {
    var t0ctx, t1ctx;
    log(stderr, "\t" + (t0.stringify(1)) + " <:? " + (t1.stringify(1)));
    if (t0 === t1) {
      return true;
    } else if (t0 === Nothing) {
      return true;
    } else if (t1 === Any) {
      return true;
    } else if (t1.type === "ID") {
      if (t0.type === "ID" && t0.match === t1.match) {
        t0ctx = requireDefContext(t0.match, t0.ctx, t0);
        t1ctx = requireDefContext(t1.match, t1.ctx, t1);
        if (t0ctx === t1ctx) {
          return true;
        }
      }
    } else {
      return false;
    }
  };

  requireCompatibility = function(t0, t1, whereTree) {
    if (isSubType(t0, t1)) {
      return true;
    } else {
      throw new Error("Type error: expected: " + (t1.stringify(0)) + "\n\tGot: " + (t0.stringify(0)) + "\n\tOn line " + whereTree.line + " character " + whereTree.column);
    }
  };


  /* CODEGEN */

  gen = function(tree, ctx, indent, output) {
    var defCtx, j, k, len, len1, prefixCtx, prefixType, ref, ref1, ref2, ref3, results, st;
    if (tree.type === "STATEMENTS") {
      ref = tree.statements;
      for (j = 0, len = ref.length; j < len; j++) {
        st = ref[j];
        if (st.type === "TYPE-DECL") {
          output.push(tabs(indent));
          defCtx = requireDefContext(st.lhs.match, ctx, tree);
          output.push(defCtx.name + "." + st.lhs.match);
          output.push(" = ");
          genInitializer(st.rhsLower, indent, output);
          output.push(";\n");
        }
      }
      ref1 = tree.statements;
      results = [];
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        st = ref1[k];
        if (st.type === "TERM-ASSIGN") {
          output.push(tabs(indent));
          if (st.guard) {
            output.push("if(");
            gen(st.guard.condition, ctx, indent, output);
            output.push("){ ");
          }
          gen(st.lhs, ctx, indent, output);
          output.push(" = ");
          gen(st.rhs, ctx, indent, output);
          if (st.guard) {
            output.push(" }");
          }
          results.push(output.push(";\n"));
        } else if ((ref2 = st.type) === "id" || ref2 === "TERM-SELECT" || ref2 === "CONSTRUCT") {
          output.push(tabs(indent));
          if (st.guard) {
            output.push("if(");
            gen(st.guard.condition, ctx, indent, output);
            output.push("){ ");
          }
          gen(st, ctx, indent, output);
          if (st.guard) {
            output.push(" }");
          }
          results.push(output.push(";\n"));
        } else {
          if (st.guard) {
            throw new Error("Unexpected guard on " + st.type + " statement on line " + st.guard.line);
          } else {
            results.push(void 0);
          }
        }
      }
      return results;
    } else if (tree.type === "CONSTRUCT") {
      return genConstructor(tree.typTree, ctx, indent, output);
    } else if (tree.type === "id") {
      if (tree.match === "???") {
        return output.push("(function(){ throw new Error('Not Implemented'); })()");
      } else {
        defCtx = requireDefContext(tree.match, ctx, tree);
        return output.push(defCtx.name + "." + tree.match);
      }
    } else if (tree.type === "TERM-SELECT") {
      ref3 = widen(tree.prefix, ctx), prefixCtx = ref3[0], prefixType = ref3[1];
      requireMemberInType(tree.id, prefixType, prefixCtx, tree);
      gen(tree.prefix, ctx, indent, output);
      output.push(".");
      return output.push(tree.id);
    }
  };

  genInitializer = function(tree, indent, output) {
    var base, bases, ctx, j, len;
    ctx = tree.ctx;
    output.push("function(" + ctx.name + "){\n");
    bases = getBaseTypes(tree);
    for (j = 0, len = bases.length; j < len; j++) {
      base = bases[j];
      if (base.type === "STATEMENTS") {
        gen(base, ctx, indent + 1, output);
      }
    }
    output.push(tabs(indent + 1));
    output.push("return " + ctx.name + ";\n");
    output.push(tabs(indent));
    return output.push("}");
  };

  genConstructor = function(tree, outer, indent, output) {
    var base, bases, ctx, defCtx, j, len;
    ctx = tree.ctx;
    output.push("(function(" + ctx.name + "){\n");
    bases = getBaseTypes(tree);
    for (j = 0, len = bases.length; j < len; j++) {
      base = bases[j];
      if (base.type === "STATEMENTS") {
        gen(base, ctx, indent + 1, output);
      } else if (base.type === "ID") {
        defCtx = requireDefContext(base.match, outer, base);
        output.push(tabs(indent + 1));
        output.push(defCtx.name + "." + base.match + "(" + ctx.name + ");\n");
      } else if (base.type === "TYPE-SELECT") {
        output.push(tabs(indent + 1));
        gen(base.prefix, outer, indent + 1, output);
        output.push("." + base.ID + "(" + ctx.name + ");\n");
      } else if (base.type === "ANY") {

      } else if (base.type === "NOTHING") {
        throw new Error("Cannot construct an object with a base class of Nothing. Constructor at line " + tree.line + " character " + tree.column);
      } else {
        throw new Error("Internal compiler error: Unexpected base type tree " + base.type + " in genConstructor. Line " + tree.line + " character " + tree.column);
      }
    }
    output.push(tabs(indent + 1));
    output.push("return " + ctx.name + ";\n");
    output.push(tabs(indent));
    return output.push("})({})");
  };


  /* PARSER */

  Token = function(tokType, text, line, column) {
    var tk;
    tk = {
      type: tokType,
      match: text,
      line: line,
      column: column,
      isToken: true
    };
    tk.stringify = function() {
      return tk.match.replace('\n', '\\n');
    };
    tk.print = function() {
      return tk.type + ", \"" + (tk.match.replace('\n', '\\n')) + "\", line " + tk.line + ", character " + tk.column;
    };
    return tk;
  };

  TypeDecl = function(lhs, rhsLower, rhsUpper) {
    var t;
    t = {
      type: "TYPE-DECL",
      alttypes: ["STATEMENT"],
      lhs: lhs,
      rhsLower: rhsLower,
      rhsUpper: rhsUpper,
      line: lhs.line,
      column: lhs.column
    };
    t.stringify = function(indent) {
      return t.lhs.stringify(indent) + ": at most " + t.rhsUpper.stringify(indent) + " at least " + t.rhsLower.stringify(indent);
    };
    t.subtrees = function() {
      return [t.lhs, t.rhsLower, t.rhsUpper];
    };
    return t;
  };

  TermDecl = function(lhs, rhs) {
    var t;
    t = {
      type: "TERM-DECL",
      alttypes: ["STATEMENT"],
      lhs: lhs,
      rhs: rhs,
      line: lhs.line,
      column: lhs.column
    };
    t.stringify = function(indent) {
      return t.lhs.stringify(indent) + ": " + t.rhs.stringify(indent);
    };
    t.subtrees = function() {
      return [t.lhs, t.rhs];
    };
    return t;
  };

  WithGuard = function(guard, statement) {
    var prevStringify, prevSubtrees;
    statement.guard = guard;
    prevStringify = statement.stringify;
    statement.stringify = function(indent) {
      return guard.stringify(indent) + prevStringify(indent);
    };
    prevSubtrees = statement.subtrees;
    statement.subtrees = function() {
      return [statement.guard].concat(prevSubtrees());
    };
    return statement;
  };

  parse = function(tokens) {
    var begin, expected, fromTopOfStack, i, matches, reduce, shift, showTypes, stack, stack_contents, t, unreducedTokenCount;
    stack = [];
    unreducedTokenCount = function() {
      var i, j, ref;
      for (i = j = 1, ref = stack.length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        if (!stack[stack.length - i].isToken) {
          return i - 1;
        }
      }
      return stack.length;
    };
    matches = function(types, skip) {
      var elem, i, j, ref, ref1;
      if (skip == null) {
        skip = 0;
      }
      if (types.length <= stack.length - skip) {
        for (i = j = 0, ref = types.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          if (types[i] !== "*") {
            elem = stack[stack.length - types.length + i - skip];
            if (elem.type !== types[i] && !(elem.alttypes && (ref1 = types[i], indexOf.call(elem.alttypes, ref1) >= 0))) {
              return false;
            }
          }
        }
        return true;
      } else {
        return false;
      }
    };
    fromTopOfStack = function(i) {
      if (i == null) {
        i = 0;
      }
      if (i > stack.length - 1) {
        return void 0;
      } else {
        return stack[stack.length - 1 - i];
      }
    };
    shift = function() {
      var t;
      t = tokens.shift();
      if (t.type === "id") {
        t.alttypes = ["TERM"];
      }
      if (t.type === "ID") {
        t.alttypes = ["TYPE"];
      }
      return stack.push(t);
    };
    expected = function(description) {
      var t, value;
      if (stack.length > 0) {
        t = stack[stack.length - 1];
        value = t.isToken ? t.match.replace('\n', '\\n') : t.stringify(0);
        throw "Parse error on line " + t.line + " character " + t.column + " : Expected " + description + "; got " + t.type + " with value \"" + value + "\"";
      } else {
        throw "Parse error with empty stack: Expected " + description;
      }
    };
    reduce = function() {

      /* Handle Comments */
      var ID, _typTree, a, b, condition, construct, guard, id, lhs, lparen, nl, nw, prefix, rhs, rhsLower, rhsUpper, statement, stmt, stmts, t, term;
      if (matches(["COMMENT"])) {
        stack.pop();
        return true;
      }
      if (matches(["START-BLOCK-COMMENT", "END-BLOCK-COMMENT"])) {
        stack.pop();
        stack.pop();
        return true;
      }
      if (matches(["START-BLOCK-COMMENT", "START-BLOCK-COMMENT"])) {
        return false;
      }
      if (matches(["START-BLOCK-COMMENT", "*"])) {
        stack.pop();
        return true;
      }

      /* Recognize ids that are really keywords */
      if (matches(["id"])) {
        if (fromTopOfStack(0).match === "new") {
          fromTopOfStack(0).type = "NEW";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "if") {
          fromTopOfStack(0).type = "IF";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "then") {
          fromTopOfStack(0).type = "THEN";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
        if (fromTopOfStack(0).match === "outer") {
          fromTopOfStack(0).type = "OUTER";
          fromTopOfStack(0).alttypes = void 0;
          return true;
        }
      }
      if (matches(["id", "id"])) {
        a = fromTopOfStack(1);
        b = fromTopOfStack(0);
        if (a.match === "at" && b.match === "least") {
          stack.pop();
          a.type = "ATLEAST";
          a.match = a.match + " " + b.match;
          a.alttypes = void 0;
          return true;
        }
        if (a.match === "at" && b.match === "most") {
          stack.pop();
          a.type = "ATMOST";
          a.match = a.match + " " + b.match;
          a.alttypes = void 0;
          return true;
        }
      }

      /* Selections */
      if (matches(["IF", "TERM", "THEN"])) {
        stack.pop();
        condition = stack.pop();
        stack.pop();
        guard = {
          type: "GUARD",
          condition: condition,
          line: condition.line,
          column: condition.column
        };
        guard.stringify = function(indent) {
          return "if " + (guard.condition.stringify(indent)) + " then ";
        };
        guard.subtrees = function() {
          return [guard.condition];
        };
        stack.push(guard);
        return true;
      }
      if (matches(["GUARD", "STATEMENT"])) {
        statement = stack.pop();
        guard = stack.pop();
        stack.push(WithGuard(guard, statement));
        return true;
      }
      if (matches(["GUARD", "*", "NEWLINE"])) {
        nl = stack.pop();
        term = stack.pop();
        guard = stack.pop();
        stack.push(WithGuard(guard, term));
        stack.push(nl);
        return true;
      }
      if (matches(["TERM", "DOT", "id"])) {
        id = stack.pop();
        stack.pop();
        prefix = stack.pop();
        t = {
          type: "TERM-SELECT",
          alttypes: ["TERM"],
          prefix: prefix,
          id: id.match,
          line: id.line,
          column: id.column
        };
        t.stringify = function(indent) {
          return t.prefix.stringify(indent) + ("." + t.id);
        };
        t.subtrees = function() {
          return [t.prefix];
        };
        stack.push(t);
        return true;
      }
      if (matches(["TERM", "DOT", "ID"])) {
        ID = stack.pop();
        stack.pop();
        prefix = stack.pop();
        t = {
          type: "TYPE-SELECT",
          alttypes: ["TYPE"],
          prefix: prefix,
          ID: ID.match,
          line: ID.line,
          column: ID.column
        };
        t.stringify = function(indent) {
          return t.prefix.stringify(indent) + ("." + t.ID);
        };
        t.subtrees = function() {
          return [t.prefix];
        };
        stack.push(t);
        return true;
      }
      if (matches(["ID", "COLON", "*", "*", "*", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["ATMOST", "TYPE", "ATLEAST", "TYPE"])) {
          rhsLower = stack.pop();
          stack.pop();
          rhsUpper = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        } else if (matches(["ATLEAST", "TYPE", "ATMOST", "TYPE"])) {
          rhsUpper = stack.pop();
          stack.pop();
          rhsLower = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        }
      }
      if (matches(["ID", "COLON", "*", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["ATMOST", "TYPE"])) {
          rhsUpper = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          rhsLower = Token("ID", "Nothing", rhsUpper.line, rhsUpper.column);
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        } else if (matches(["ATLEAST", "TYPE"])) {
          rhsLower = stack.pop();
          stack.pop();
          stack.pop();
          lhs = stack.pop();
          rhsUpper = Token("ID", "Any", rhsLower.line, rhsLower.column);
          stack.push(TypeDecl(lhs, rhsLower, rhsUpper));
          return true;
        }
      }
      if (matches(["ID", "COLON", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TypeDecl(lhs, rhs, rhs));
          return true;
        } else {
          expected("TYPE in declaration of " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["id", "COLON", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          stack.push(TermDecl(lhs, rhs));
          return true;
        } else {
          expected("TYPE in declaration of " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["ID", "EQUALS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TYPE"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TYPE-ASSIGN",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhs: rhs,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + " = " + t.rhs.stringify(indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhs];
          };
          stack.push(t);
          return true;
        } else {
          expected("TYPE in assignment to " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["id", "EQUALS", "*", "NEWLINE"]) || matches(["TERM-SELECT", "EQUALS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TERM"])) {
          rhs = stack.pop();
          stack.pop();
          lhs = stack.pop();
          t = {
            type: "TERM-ASSIGN",
            alttypes: ["STATEMENT"],
            lhs: lhs,
            rhs: rhs,
            line: lhs.line,
            column: lhs.column
          };
          t.stringify = function(indent) {
            return t.lhs.stringify(indent) + " = " + t.rhs.stringify(indent);
          };
          t.subtrees = function() {
            return [t.lhs, t.rhs];
          };
          stack.push(t);
          return true;
        } else {
          expected("TERM in assignment to " + (fromTopOfStack(2).stringify(0)));
        }
      }
      if (matches(["TYPE", "AND", "TYPE"])) {
        rhs = stack.pop();
        stack.pop();
        lhs = stack.pop();
        t = {
          type: "AND-TYPE",
          alttypes: ["TYPE"],
          lhs: lhs,
          rhs: rhs,
          line: lhs.line,
          column: lhs.column
        };
        t.stringify = function(indent) {
          return t.lhs.stringify(indent) + " & " + t.rhs.stringify(indent);
        };
        t.subtrees = function() {
          return [t.lhs, t.rhs];
        };
        stack.push(t);
        return true;
      }
      if (matches(["TYPE", "OR", "TYPE"])) {
        rhs = stack.pop();
        stack.pop();
        lhs = stack.pop();
        t = {
          type: "OR-TYPE",
          alttypes: ["TYPE"],
          lhs: lhs,
          rhs: rhs,
          line: lhs.line,
          column: lhs.column
        };
        t.stringify = function(indent) {
          return t.lhs.stringify(indent) + " | " + t.rhs.stringify(indent);
        };
        t.subtrees = function() {
          return [t.lhs, t.rhs];
        };
        stack.push(t);
        return true;
      }
      if (matches(["STATEMENTS", "*", "NEWLINE"])) {
        stack.pop();
        if (matches(["TERM"])) {
          stmt = stack.pop();
          stmts = stack.pop();
          stmts.statements.push(stmt);
          stmts.line = stmt.line;
          stmts.column = stmt.column;
          stack.push(stmts);
          return true;
        } else {
          expected("STATEMENT");
        }
      }
      if (matches(["STATEMENTS", "STATEMENT"])) {
        stmt = stack.pop();
        stmts = stack.pop();
        stmts.statements.push(stmt);
        stmts.line = stmt.line;
        stmts.column = stmt.column;
        stack.push(stmts);
        return true;
      }
      if (matches(["LBRACE"])) {
        lparen = fromTopOfStack();
        begin(lparen.line, lparen.column);
        return true;
      }
      if (matches(["LBRACE", "STATEMENTS", "RBRACE"])) {
        stack.pop();
        stmts = stack.pop();
        stack.pop();
        stack.push(stmts);
        return true;
      }
      if (matches(["*", "DOT", "NEW"])) {
        nw = stack.pop();
        stack.pop();
        if (matches(["TYPE"])) {
          _typTree = stack.pop();
          construct = {
            type: "CONSTRUCT",
            alttypes: ["TERM"],
            typTree: _typTree,
            line: nw.line,
            column: nw.column
          };
          construct.stringify = function(indent) {
            return (construct.typTree.stringify(indent)) + ".new";
          };
          construct.subtrees = function() {
            return [construct.typTree];
          };
          stack.push(construct);
          return true;
        } else {
          throw new Error("Expected type in object construction on line " + nw.line + " character " + nw.column + ", got " + (fromTopOfStack(0).stringify(0)));
        }
      }
      if (matches(["STATEMENTS", "NEWLINE"])) {
        stack.pop();
        return true;
      }
    };
    begin = function(ln, col) {
      var stmts;
      stmts = {
        type: "STATEMENTS",
        alttypes: ["TYPE"],
        statements: [],
        line: ln,
        column: col
      };
      stmts.stringify = function(indent) {
        var stmt;
        return "{\n" + ((function() {
          var j, len, ref, results;
          ref = stmts.statements;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            stmt = ref[j];
            results.push(tabs(indent + 1) + stmt.stringify(indent + 1) + "\n");
          }
          return results;
        })()).join("") + tabs(indent) + "}";
      };
      stmts.subtrees = function() {
        return stmts.statements;
      };
      stmts.print = stmts.stringify;
      return stack.push(stmts);
    };
    showTypes = function(t) {
      var s, typ;
      s = t.type;
      if (t.alttypes) {
        s = s + " & " + ((function() {
          var j, len, ref, results;
          ref = t.alttypes;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            typ = ref[j];
            results.push(typ);
          }
          return results;
        })()).join(" & ");
      }
      return s;
    };
    begin(1, 1);
    while (true) {
      while (reduce()) {
        true;
      }
      if (tokens[0].type === "EOF" || unreducedTokenCount() >= 8) {
        break;
      }
      shift();
    }
    if (stack.length !== 1) {
      i = -1;
      stack_contents = ((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = stack.length; j < len; j++) {
          t = stack[j];
          i += 1;
          results.push("Item " + i + ": " + (showTypes(t)) + "\n" + (t.stringify(0)));
        }
        return results;
      })()).join("\n\n");
      throw "Parse error: Unreduced items on stack at End-of-Input. Stack contents:\n\n" + stack_contents;
    }
    return stack[0];
  };

  tokenize = function(input) {
    var Whitespace, column, consumeNextToken, getNextToken, line, t, tk, tokenList, tokens;
    line = 1;
    column = 1;
    tokenList = [
      {
        name: "GUARD_ARROW",
        regex: /^=>/
      }, {
        name: "id",
        regex: /^([a-z][a-zA-z0-9_]*|\?\?\?)/
      }, {
        name: "ID",
        regex: /^[A-Z][a-zA-z0-9_]*/
      }, {
        name: "NEWLINE",
        regex: /^(\n|\r\n|\r)/
      }, {
        name: "COMMENT",
        regex: /^\/\/.*/
      }, {
        name: "START-BLOCK-COMMENT",
        regex: /^\/\*/
      }, {
        name: "END-BLOCK-COMMENT",
        regex: /^\*\//
      }, {
        name: "DOT",
        regex: /^\./
      }, {
        name: "AND",
        regex: /^&/
      }, {
        name: "OR",
        regex: /^\|/
      }, {
        name: "EQUALS",
        regex: /^=/
      }, {
        name: "LPAREN",
        regex: /^\(/
      }, {
        name: "RPAREN",
        regex: /^\)/
      }, {
        name: "LBRACE",
        regex: /^{/
      }, {
        name: "RBRACE",
        regex: /^}/
      }, {
        name: "COLON",
        regex: /^:/
      }, {
        name: "EOF",
        regex: /^$/
      }
    ];
    Whitespace = {
      name: "SPACE",
      regex: /^[\t \v\f]+/
    };
    getNextToken = function() {
      var j, len, length, matches, tok;
      matches = Whitespace.regex.exec(input);
      if (matches) {
        input = input.substring(matches[0].length);
        column += matches[0].length;
      }
      for (j = 0, len = tokenList.length; j < len; j++) {
        tok = tokenList[j];
        matches = tok.regex.exec(input);
        if (matches) {
          return Token(tok.name, matches[0], line, column);
        }
      }
      length = input.indexOf('\n');
      if (length <= 0) {
        length = input.length;
      }
      throw "Tokenization error on line " + line + " character " + column + " : Unable to match a token starting at '" + (input.substring(0, length)) + "'";
    };
    consumeNextToken = function() {
      var tok;
      tok = getNextToken();
      input = input.substring(tok.match.length);
      column += tok.match.length;
      if (tok.type === "NEWLINE") {
        column = 1;
        line += 1;
      }
      return tok;
    };
    tokens = [];
    while (true) {
      t = consumeNextToken();
      if (t.type === "RBRACE" || t.type === "EOF") {
        tk = Token("NEWLINE", "\n", t.line, t.column);
        tk.stringify = function() {
          return "(synthetic \\n)";
        };
        tk.print = function() {
          return "synthetic NEWLINE on line " + t.line + ", char " + t.column;
        };
        tokens.push(tk);
      }
      tokens.push(t);
      if (t.type === "EOF") {
        break;
      }
    }
    return tokens;
  };

  tabs = function(indent) {
    return "\t".repeat(indent);
  };

}).call(this);
